<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>C++ Tip of The Week</title>
        <link>https://tip-of-the-week.github.io/cpp/</link>
        <atom:link rel="self" type="application/rss+xml" href="https://tip-of-the-week.github.io/cpp/feed.xml"/>
        <language>en</language>
        <description>Your weekly dose of modern C++ challenge (Release every Sunday).</description>
        <item>
            <title>369 - Did you know that C++17 added Hardware interference size?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/369.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/369.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 added Hardware interference size?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0154">https://wg21.link/P0154</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;new&gt;
static_assert(64u == std::hardware_destructive_interference_size); // x86-64
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/haPq9583q">https://godbolt.org/z/haPq9583q</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>**Can you implement <code>cache_aligned_array</code> function which returns cache size aligned std::array with provided values?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto cache_aligned_array(auto... args) {
    // TODO
    return std::array{args...};
};

static_assert(std::hardware_destructive_interference_size == alignof(cache_aligned_array(1, 2, 3)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EvKco4fG7">https://godbolt.org/z/EvKco4fG7</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto cache_aligned_array(auto... args) {
    struct alignas(std::hardware_destructive_interference_size) 
      : decltype(std::array{args...}) { } array {args...};
    return array;
};

static_assert(std::hardware_destructive_interference_size == alignof(cache_aligned_array(1, 2, 3)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oTezYjsW4">https://godbolt.org/z/oTezYjsW4</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>368 - Did you know that C++23 added Explicit lifetime management (1/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/368.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/368.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added Explicit lifetime management (1/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2590">https://wg21.link/P2590</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">std::array&lt;std::byte, 1024&gt; data{};
std::fill(std::begin(data), std::end(data), std::byte{42});

struct foo {
  std::uint8_t x;
  std::uint8_t y;
};

auto* f = std::start_lifetime_as&lt;foo&gt;(std::data(data));
std::cout &lt;&lt; f-&gt;x &lt;&lt; f-&gt;y; // prints 4242
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4ozs8hTr5">https://godbolt.org/z/4ozs8hTr5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>**Can you implement <code>start_lifetime_as</code>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto start_lifetime_as(void* p) noexcept -&gt; T*; // TODO 

int main() {
  using namespace boost::ut;

  &quot;start_lifetime_as&quot;_test = [] {
    std::array&lt;std::byte, 1024&gt; data{};
    std::fill(std::begin(data), std::end(data), std::byte{42});

    struct foo {
      std::uint8_t x;
      std::uint8_t y;
    };

    auto* f = start_lifetime_as&lt;foo&gt;(std::data(data));
    expect(42_i == f-&gt;x);
    expect(42_i == f-&gt;y);
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fqsEz8YGr">https://godbolt.org/z/fqsEz8YGr</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto start_lifetime_as(void* p) noexcept -&gt; T* {
  const auto bytes = new (p) std::byte[sizeof(T)];
  const auto ptr = reinterpret_cast&lt;T*&gt;(bytes);
  (void*)ptr;
  return ptr;
}

int main() {
  using namespace boost::ut;

  &quot;start_lifetime_as&quot;_test = [] {
    std::array&lt;std::byte, 1024&gt; data{};
    std::fill(std::begin(data), std::end(data), std::byte{42});

    struct foo {
      std::uint8_t x;
      std::uint8_t y;
    };

    auto* f = start_lifetime_as&lt;foo&gt;(std::data(data));
    expect(42_i == f-&gt;x);
    expect(42_i == f-&gt;y);
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W18nWPbE3">https://godbolt.org/z/W18nWPbE3</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>367 - Did you know about C++26 simd proposal (1/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/367.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/367.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 simd proposal (1/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1928">https://wg21.link/P1928</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;experimental/simd&gt;

int main() {
    std::experimental::simd&lt;int&gt; s{};
    s = 1;

    for (auto i = 0; i &lt; std::size(s); ++i) {
        std::print(&quot;{}&quot;, int(s[i])); // prints 1111 (depending on the arch)
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7dhGs7Mz3">https://godbolt.org/z/7dhGs7Mz3</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>**Can you show use cases for all simd constructors?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO simd constructors
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M8EKbozEe">https://godbolt.org/z/M8EKbozEe</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>366 - Did you know about C++26 static reflection proposal (6/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/366.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/366.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (6/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; struct counter {
  static constexpr auto value = N;
};

[[nodiscard]] consteval auto next() {
  for (auto i = 0;; ++i) {
    if (auto mi = substitute(^counter, { std::meta::reflect_value(i) }); std::meta::is_incomplete_type(mi)) {
      return std::meta::value_of&lt;decltype(i)&gt;(std::meta::static_data_members_of(mi)[0]);
    }
  }
}

static_assert(next() == 0);
static_assert(next() == 1);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/91M56a5dd">https://godbolt.org/z/91M56a5dd</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement compile-time type list?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; using append_t;// TODO
template&lt;auto = []{}&gt; using get_list_t; // TODO

int main() {
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;&gt;));

  append_t&lt;int&gt;{};
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;int&gt;));

  append_t&lt;float&gt;{};
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;int, float&gt;));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W7s5TW8ss">https://godbolt.org/z/W7s5TW8ss</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto&gt; struct type_list_impl;

consteval auto append(auto new_member) {
  std::vector&lt;std::meta::info&gt; members{};
  for (auto i = 0;; ++i) {
    if (auto mi = substitute(^type_list_impl, { std::meta::reflect_value(i) }); std::meta::is_incomplete_type(mi)) {
      std::vector&lt;std::meta::nsdm_description&gt; new_members{};
      for (const auto&amp; member: members) {
        new_members.push_back({std::meta::type_of(member), {.name = std::meta::name_of(member)}});
      }
      const char name[]{'_', char(i+'0'), 0};
      new_members.push_back({{new_member}, {.name = std::string_view(name, 2)}});
      return define_class(mi, new_members);
    } else {
      members = std::meta::nonstatic_data_members_of(mi);
    }
  }
}

consteval auto get_list(auto type_list) {
  std::vector&lt;std::meta::info&gt; members{};
  for (auto i = 0;; ++i) {
    if (auto mi = substitute(^type_list_impl, { std::meta::reflect_value(i) }); std::meta::is_incomplete_type(mi)) {
      break;
    } else {
      members = std::meta::nonstatic_data_members_of(mi);
    }
  }
  std::vector&lt;std::meta::info&gt; new_members{};
  for (auto member : members) {
    new_members.push_back(std::meta::type_of(member));
  }
  return substitute(type_list, new_members);
}

template&lt;class...&gt; struct type_list{};

template&lt;class T&gt; using append_t = [:append(^T):];
template&lt;auto = []{}&gt; using get_list_t = [:get_list(^type_list):];

int main() {
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;&gt;));

  append_t&lt;int&gt;{};
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;int&gt;));

  append_t&lt;float&gt;{};
  static_assert(typeid(get_list_t&lt;&gt;{}) == typeid(type_list&lt;int, float&gt;));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P6sTdPEG8">https://godbolt.org/z/P6sTdPEG8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct type_list {};
template&lt;auto&gt; struct nth { auto friend get(nth); auto friend get(nth); };
template&lt;auto N, class T&gt; struct set { auto friend get(nth&lt;N&gt;) { return T{}; } };

template&lt;class T, template&lt;class...&gt; class TList, class... Ts&gt; auto append_impl(TList&lt;Ts...&gt;) -&gt; TList&lt;Ts..., T&gt;;

template&lt;class T, auto N = 0, auto unique = []{}&gt;
consteval auto append() {
    if constexpr (requires { get(nth&lt;N&gt;{}); }) {
        append&lt;T, N+1, unique&gt;();
    } else if constexpr (N == 0) {
        void(set&lt;N, type_list&lt;T&gt;&gt;{});
    } else {
        void(set&lt;N, decltype(append_impl&lt;T&gt;(get(nth&lt;N-1&gt;{})))&gt;{});
    }
}

template&lt;auto unique = []{}, auto N = 0&gt;
consteval auto get_list() {
    if constexpr (requires { get(nth&lt;N&gt;{}); }) {
        return get_list&lt;unique, N+1&gt;();
    } else if constexpr (N == 0) {
        return type_list{};
    } else {
        return get(nth&lt;N-1&gt;{});
    }
}

int main() {
  static_assert(typeid(get_list()) == typeid(type_list&lt;&gt;));

  append&lt;int&gt;();
  static_assert(typeid(get_list()) == typeid(type_list&lt;int&gt;));

  append&lt;float&gt;();
  static_assert(typeid(get_list()) == typeid(type_list&lt;int, float&gt;));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d7GrW1j76">https://godbolt.org/z/d7GrW1j76</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>365 - Did you know about C++26 static reflection proposal (5/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/365.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/365.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (5/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo;
[[maybe_unused]] constexpr auto _ =
  define_class(^foo, {std::meta::nsdm_description(^int, {.name = &quot;bar&quot;})});
foo f{.bar = 42}; // has bar int member
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aqxanTe3r">https://godbolt.org/z/aqxanTe3r</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement template alias <code>pack</code> which will pack given struct by sorting members by their size?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; using pack; // TODO

struct unpacked {
  short s;
  int i;
  bool b;
};
static_assert(12 == sizeof(unpacked));

using packed = pack&lt;unpacked&gt;;
static_assert(8 == sizeof(packed));
static_assert(requires(packed p) { p.i; p.s; p.b; });
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hnPvsE9h3">https://godbolt.org/z/hnPvsE9h3</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template&lt;class T&gt; struct packed;
template&lt;class T&gt; [[nodiscard]] consteval auto pack() {
  std::vector members = std::meta::nonstatic_data_members_of(^T);
  sort(members, [](auto lhs, auto rhs) consteval { return std::meta::size_of(lhs) &lt; std::meta::size_of(rhs); });
  std::vector&lt;std::meta::nsdm_description&gt; new_members{};
  for (const auto&amp; member: members) {
      new_members.push_back({std::meta::type_of(member), {.name = std::meta::name_of(member)}});
  }
  return define_class(^packed&lt;T&gt;, new_members);
}
} // namespace detail
template&lt;class T&gt; using pack = [:detail::pack&lt;T&gt;():];

struct unpacked {
  short s;
  int i;
  bool b;
};
static_assert(12 == sizeof(unpacked));

using packed = pack&lt;unpacked&gt;;
static_assert(8 == sizeof(packed));
static_assert(requires(packed p) { p.i; p.s; p.b; });
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ExYfTv4nK">https://godbolt.org/z/ExYfTv4nK</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>364 - Did you know about C++26 static reflection proposal (4/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/364.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/364.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (4/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">[[maybe_unused]] constexpr [:substitute(^std::tuple, {^int, ^float}):] tuple{}; // std::tuple&lt;int, float&gt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T6oxh48dc">https://godbolt.org/z/T6oxh48dc</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>soa_vector</code> with reflection?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
class soa_vector; // TODO

int main() {
  struct vec3_t {
      float x, y, z;
  };

  soa_vector&lt;vec3_t&gt; v{};
  v.push_back({.x = 1, .y = 2, .z = 3});
  assert(1 == v[0].x and 2 == v[0].y and 3 == v[0].z);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TrWYxre8v">https://godbolt.org/z/TrWYxre8v</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
class soa_vector {
public:
  constexpr void push_back(const T value) {
    v.push_back(value~member_values)...;
  }

  [[nodiscard]] constexpr auto operator[](const auto pos) const {
    return T{v[pos]...};
  }

private:
  std::vector&lt;T~member_types&gt; ...v;
};

int main() {
  struct vec3_t { float x, y, z; };

  soa_vector&lt;vec3_t&gt; v{};
  v.push_back({.x=1, .y=2, .z=3});
  assert(1 == v[0].x and 2 == v[0].y and 3 == v[0].z);
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/ojzvKr98q">https://circle.godbolt.org/z/ojzvKr98q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
class soa_vector {
 public:
    constexpr void push_back(const T value) {
      [&amp;, this]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) { (std::get&lt;Ns&gt;(v).push_back(value.[:std::meta::nonstatic_data_members_of(^T)[Ns]:]), ...); }(members);
    }

    [[nodiscard]] constexpr auto operator[](const auto pos) const {
      return [&amp;, this]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) { return T{std::get&lt;Ns&gt;(v)[pos]...}; }(members);
    }

 private:
    template&lt;class... Ts&gt; using vector = std::vector&lt;Ts...&gt;;

    [[nodiscard]] static consteval auto tuple_of_vectors(const auto type) {
        std::vector&lt;std::meta::info&gt; members{};
        for (auto member : nonstatic_data_members_of(type)) {
            members.push_back(substitute(^vector, {type_of(member)})); // with std::vector -&gt; std::vector&lt;float, allocator&lt;_Tp&gt;&gt;
        }
        return substitute(^std::tuple, members); // define_class can also be used instead
    }

    static constexpr auto members = std::make_index_sequence&lt;std::size(std::meta::nonstatic_data_members_of(^T))&gt;{};

    [:tuple_of_vectors(^T):] v;
};

int main() {
  struct vec3_t {
    float x, y, z;
  };

  soa_vector&lt;vec3_t&gt; v{};
  v.push_back({.x = 1, .y = 2, .z = 3});
  assert(1 == v[0].x and 2 == v[0].y and 3 == v[0].z);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yvo83bc4d">https://godbolt.org/z/Yvo83bc4d</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace impl {
template &lt;typename... Ts&gt;
using vector = std::vector&lt;Ts...&gt;;
template &lt;class T&gt;
struct soa_base_t;
consteval auto make_soa_t(std::meta::info type) -&gt; std::meta::info {
    auto members = std::meta::nonstatic_data_members_of(type);
    std::vector&lt;std::meta::nsdm_description&gt; new_members;
    for (const auto&amp; member : members) {
        auto new_type = std::meta::substitute(^vector, {
                                                           std::meta::type_of(member)});
        auto new_member =
            std::meta::nsdm_description(new_type, {.name = std::meta::name_of(member)});
        new_members.push_back(new_member);
    }
    return std::meta::define_class(std::meta::substitute(^soa_base_t,
                                                         {
                                                             type}),
                                   new_members);
}

template &lt;class T&gt;
using soa_t = [:make_soa_t(^T):];
}  // namespace impl

template &lt;class T&gt;
class soa_vector : impl::soa_t&lt;T&gt; {
    constexpr static auto C = std::meta::nonstatic_data_members_of(^T).size();

   public:
    void push_back(const T&amp; value) {
        [&amp;value, this]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
            (this-&gt;[:std::meta::nonstatic_data_members_of(^impl::soa_t&lt;T&gt;)[Is]:]
                 .push_back(value.[:std::meta::nonstatic_data_members_of(^T)[Is]:]), ...);
        }(std::make_index_sequence&lt;C&gt;());
    }
    [[nodiscard]] constexpr auto operator[](std::size_t index) const -&gt; T {
        return [&amp;index, this]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
            return T{
                this-&gt;[:std::meta::nonstatic_data_members_of(^impl::soa_t&lt;T&gt;)[Is]:].at(index)...};
        }(std::make_index_sequence&lt;C&gt;());
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bddnjsj8M">https://godbolt.org/z/bddnjsj8M</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>363 - Did you know about C++26 static reflection proposal (3/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/363.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/363.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (3/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  std::size_t bar;
};

int main() {
  std::cout &lt;&lt; std::meta::offset_of(^foo::bar); // 0
  std::cout &lt;&lt; std::meta::size_of(^foo::bar); // 8
  std::cout &lt;&lt; std::meta::alignment_of(^foo::bar); // 8
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4cz9x5zhq">https://godbolt.org/z/4cz9x5zhq</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>layout</code> function which returns a range of <code>desc</code> describing the layout for given type <code>T</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct foo {
  char a;
  int b;
  float c;
};

struct desc {
  std::size_t size{};
  std::size_t offset{};
  std::size_t alignment{};
  constexpr auto operator&lt;=&gt;(const desc&amp;) const = default;
};

template&lt;class T, class TDesc&gt;
concept range_of = std::ranges::range&lt;T&gt; and std::same_as&lt;std::ranges::range_value_t&lt;T&gt;, TDesc&gt;;

template&lt;class T&gt;
[[nodiscard]] constexpr auto layout() -&gt; range_of&lt;desc&gt; auto; // TODO

static_assert(std::array{desc{1u, 0u, 1u}, desc{4u, 4u, 4u}, desc{4u, 8u, 4u}} == layout&lt;foo&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o5KKe9jhK">https://godbolt.org/z/o5KKe9jhK</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
struct foo {<br />
  char a;<br />
  int b;<br />
  float c;<br />
};</p>
<p>struct desc {<br />
  std::size_t size{};<br />
  std::size_t offset{};<br />
  std::size_t alignment{};<br />
  constexpr auto operator&lt;=&gt;(const desc&amp;) const = default;<br />
};</p>
<p>template<class T, class TDesc><br />
concept range_of = std::ranges::range<T> and std::same_as<std::ranges::range_value_t\<T>, TDesc>;</p>
<p>consteval std::size_t vectorSize(auto vec) noexcept {                                                    <br />
  return vec.size();           <br />
}    </p>
<p>template <typename T><br />
[[nodiscard]] constexpr auto layout() noexcept -&gt; range_of<desc> auto {<br />
  std::array<desc, vectorSize(std::meta::nonstatic_data_members_of(^T))> layouts;<br />
  int index = 0;<br />
  [: expand(std::meta::nonstatic_data_members_of(^T)) :] &gt;&gt; [&amp;layouts, &amp;index]<auto t>() mutable {<br />
      layouts[index] = desc {.size = size_of(t), .offset = offset_of(t), .alignment = alignment_of(t)};<br />
      index ++;<br />
  };<br />
  return layouts;<br />
}</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/5aeG5xKaE](https://godbolt.org/z/5aeG5xKaE)

```cpp
struct foo {
    char a;
    int b;
    float c;
};

struct desc {
    std::size_t size{};
    std::size_t offset{};
    std::size_t alignment{};
    constexpr auto operator&lt;=&gt;(const desc&amp;) const = default;
};

template &lt;class T, class TDesc&gt;
concept range_of = std::ranges::range&lt;T&gt; and std::same_as&lt;std::ranges::range_value_t&lt;T&gt;, TDesc&gt;;

template &lt;class T&gt;
[[nodiscard]] constexpr auto layout() -&gt; range_of&lt;desc&gt; auto {
    std::array&lt;desc, std::size(nonstatic_data_members_of(^T))&gt; layout{};
    [:expand(nonstatic_data_members_of(^T)):] &gt;&gt; [&amp;, i = 0]&lt;auto V&gt;() mutable {
        layout[i++] = {.size = std::meta::size_of(V),
                       .offset = std::meta::offset_of(V),
                       .alignment = std::meta::alignment_of(V)};
    };
    return layout;
}

static_assert(std::array{desc{1u, 0u, 1u}, desc{4u, 4u, 4u}, desc{4u, 8u, 4u}} == layout&lt;foo&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/564szqv6M">https://godbolt.org/z/564szqv6M</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>362 - Did you know about C++26 static reflection proposal (2/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/362.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/362.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (2/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  int a{};
  int b{};
  int c{};
};

static_assert(3 == std::size(std::meta::nonstatic_data_members_of(^foo)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hr8WvMGYG">https://godbolt.org/z/hr8WvMGYG</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>get</code> and <code>get_name</code> for struct members?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class T&gt;
[[nodiscard]] constexpr auto get(const T&amp; t) -&gt; decltype(auto); // TODO

template&lt;auto N, class T&gt;
[[nodiscard]] constexpr auto get_name(const T&amp; t) -&gt; std::string_view; // TODO

struct foo {
  int a{};
  int b{};
  int c{};
};

constexpr foo f{.a=1, .b=2, .c=3};

static_assert(1 == get&lt;0&gt;(f));
static_assert(2 == get&lt;1&gt;(f));
static_assert(3 == get&lt;2&gt;(f));

using std::literals::operator&quot;&quot;sv;
static_assert(&quot;a&quot;sv == get_name&lt;0&gt;(f));
static_assert(&quot;b&quot;sv == get_name&lt;1&gt;(f));
static_assert(&quot;c&quot;sv == get_name&lt;2&gt;(f));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YGjnhWhzK">https://godbolt.org/z/YGjnhWhzK</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class T&gt;
[[nodiscard]] constexpr auto get(const T&amp; t) -&gt; decltype(auto) {
  return t.[:std::meta::nonstatic_data_members_of(^T)[N]:];
}

template&lt;auto N, class T&gt;
[[nodiscard]] constexpr auto get_name(const T&amp; t) -&gt; std::string_view {
  return std::meta::name_of(std::meta::nonstatic_data_members_of(^T)[N]);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qK7K948jn">https://godbolt.org/z/qK7K948jn</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>361 - Did you know about C++26 static reflection proposal (1/N)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/361.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/361.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 static reflection proposal (1/N)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2996">https://wg21.link/P2996</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;meta&gt;

int main() {
    struct foo {};
    std::cout &lt;&lt; std::meta::name_of(^foo); // prints foo
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y8a9bWvea">https://godbolt.org/z/Y8a9bWvea</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>enum_to_string</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;meta&gt;

[[nodiscard]] constexpr auto enum_to_string(auto); // TODO

enum Color { red, green, blue };
static_assert(enum_to_string(Color::red) == &quot;red&quot;);
static_assert(enum_to_string(Color::green) == &quot;green&quot;);
static_assert(enum_to_string(Color::blue) == &quot;blue&quot;);
static_assert(enum_to_string(Color(42)) == &quot;&lt;unnamed&gt;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3nEqWbv8f">https://godbolt.org/z/3nEqWbv8f</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class E&gt; requires std::is_enum_v&lt;E&gt;
[[nodiscard]] constexpr auto enum_to_string(E value) -&gt; std::string {
    std::string result = &quot;&lt;unnamed&gt;&quot;;
    [:expand(std::meta::enumerators_of(^E)):] &gt;&gt; [&amp;]&lt;auto e&gt; {
        if (value == [:e:]) {
            result = std::meta::name_of(e);
        }
    };
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dsMTTxqTW">https://godbolt.org/z/dsMTTxqTW</a><br />
</p></details></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>360 - Did you know that C++23 added spanstream - A strstream replacement using span&lt;charT&gt; as buffer?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/360.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/360.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added spanstream - A strstream replacement using span<charT> as buffer?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0448">https://wg21.link/P0448</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;spanstream&gt;

int main() {
    char output[30]{};
    std::ospanstream os{std::span&lt;char&gt;{output}};
    os &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 30;
    auto const sp = os.span();
    std::cout &lt;&lt; sp.size(); // prints 6
    std::cout &lt;&lt; std::string(sp.data(),sp.size()); // prints 102030
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3Te1aPe1d">https://godbolt.org/z/3Te1aPe1d</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>strcat</code> using spanstream?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto strcat(auto...); // TODO

int main() {
    using namespace boost::ut;

    &quot;strcat&quot;_test = [] {
        expect(std::string{&quot;&quot;} ==  strcat());
        expect(std::string{&quot;1&quot;} ==  strcat(1));
        expect(std::string{&quot;1&quot;} ==  strcat(&quot;1&quot;));
        expect(std::string{&quot;42&quot;} ==  strcat(&quot;42&quot;));
        expect(std::string{&quot;42&quot;} ==  strcat(&quot;4&quot;, 2));
        expect(std::string{&quot;123&quot;} ==  strcat(1, &quot;2&quot;, 3));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/75cMqdKx1">https://godbolt.org/z/75cMqdKx1</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto strcat(auto&amp;&amp;... args) {
    char buf[256]{};
    std::ospanstream oss{std::span{buf}};
    ((oss &lt;&lt; args), ...);
    const auto span = oss.span();
    return std::string{span.data(), span.size()};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z5bn7vq3x">https://godbolt.org/z/z5bn7vq3x</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>359 - Did you know that C++20 `source_location` can be used to get the member names?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/359.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/359.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 <code>source_location</code> can be used to get the member names?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1208">https://wg21.link/P1208</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;class, auto&gt;
[[nodiscard]] consteval auto member_name() -&gt; std::string_view {
    return std::source_location::current().function_name();
}
template &lt;class T&gt; extern const T external;
consteval auto get(auto&amp; obj) {
    auto&amp; [p1] = obj;
    return &amp;p1;
}
} // namespace deatil

template &lt;class T&gt;
constexpr auto member_name = detail::member_name&lt;T, detail::get(detail::external&lt;T&gt;)&gt;();

struct foo {
  int bar;
};

static_assert(member_name&lt;foo&gt;.find(&quot;bar&quot;) != std::string_view::npos);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sMKMWa35W">https://godbolt.org/z/sMKMWa35W</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_tuple</code> which returns a tuple from a struct with names?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;fixed_string Name, class T&gt;
struct named {
    static constexpr auto name = Name;
    T value{};
};

[[nodiscard]] consteval auto to_tuple(auto&amp;&amp; t); // TODO

struct foo {
    int a;
    int b;
};

constexpr auto t = to_tuple(foo{.a=42, .b=87});
static_assert(&quot;a&quot; == std::get&lt;0&gt;(t).name and 42 == std::get&lt;0&gt;(t).value);
static_assert(&quot;b&quot; == std::get&lt;1&gt;(t).name and 87 == std::get&lt;1&gt;(t).value);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fWxPdj7v6">https://godbolt.org/z/fWxPdj7v6</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t N&gt;
class fixed_string final {
   public:
    constexpr explicit(true) fixed_string(const auto... cs) : data{cs...} {}
    constexpr explicit(false) fixed_string(const char (&amp;str)[N + 1]) {
        std::copy_n(str, N + 1, std::data(data));
    }
    [[nodiscard]] constexpr auto operator&lt;=&gt;(const fixed_string&amp;) const =
        default;
    [[nodiscard]] constexpr explicit(false) operator std::string_view() const {
        return {std::data(data), N};
    }
    [[nodiscard]] constexpr auto size() const -&gt; std::size_t { return N; }
    std::array&lt;char, N + 1&gt; data{};
};

template &lt;std::size_t N&gt;
fixed_string(const char (&amp;str)[N]) -&gt; fixed_string&lt;N - 1&gt;;

template &lt;fixed_string Name, class T&gt;
struct named {
    static constexpr auto name = Name;
    T value{};
};

struct any_type {
    template &lt;class T&gt;
    constexpr operator T();
};

template &lt;class TPtr&gt;
struct ptr {
    const TPtr* ptr;
};

namespace detail {
template &lt;class T&gt;
extern const T external;
struct any_type {
    template &lt;class T&gt;
    constexpr operator T();
};
template &lt;class TPtr&gt;
struct ptr {
    const TPtr* ptr;
};

template &lt;auto N, class T&gt;
[[nodiscard]] constexpr auto nth_ptr(T&amp;&amp; t) {
    if constexpr (requires { T{any_type{}, any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2, p3] = t;
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
        if constexpr (N == 1) return ptr&lt;decltype(p2)&gt;{&amp;p2};
        if constexpr (N == 2) return ptr&lt;decltype(p3)&gt;{&amp;p3};
    } else if constexpr (requires { T{any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2] = t;
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
        if constexpr (N == 1) return ptr&lt;decltype(p2)&gt;{&amp;p2};
    } else if constexpr (requires { T{any_type{}}; }) {
        auto&amp;&amp; [p1] = t;
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
    }
}

template &lt;auto Ptr&gt;
[[nodiscard]] consteval auto get_name() -&gt; std::string_view {
    return std::source_location::current().function_name();
}

template &lt;auto N, class T&gt;
constexpr auto get_name_impl =
    detail::get_name&lt;detail::nth_ptr&lt;N&gt;(detail::external&lt;T&gt;)&gt;();

struct $struct$ {
    int $field$;
};
constexpr auto $name = get_name_impl&lt;0, detail::$struct$&gt;;
constexpr auto $end =
    $name.substr($name.find(&quot;$field$&quot;) + sizeof(&quot;$field$&quot;) - 1);
constexpr auto $begin = $name[$name.find(&quot;$field$&quot;) - 1];
}  // namespace detail

template &lt;auto N, class T&gt;
constexpr auto get_name = [] {
    const auto name = detail::get_name_impl&lt;N, T&gt;;
    const auto begin = name.find(detail::$end);
    const auto tmp = name.substr(0, begin);
    return tmp.substr(tmp.find_last_of(detail::$begin) + 1);
}();

template &lt;auto N&gt;
[[nodiscard]] consteval auto nth(auto... args) {
    return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return [](decltype((void*)Ns)..., auto* nth, auto*...) {
            return *nth;
        }(&amp;args...);
    }(std::make_index_sequence&lt;N&gt;{});
}

template &lt;auto N, class T&gt;
constexpr auto get(T&amp;&amp; t) {
    if constexpr (requires { T{any_type{}, any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2, p3] = t;
        // structure bindings is not constexpr :/
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
        if constexpr (N == 1) return ptr&lt;decltype(p2)&gt;{&amp;p2};
        if constexpr (N == 2) return ptr&lt;decltype(p3)&gt;{&amp;p3};
    } else if constexpr (requires { T{any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2] = t;
        // structure bindings is not constexpr :/
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
        if constexpr (N == 1) return ptr&lt;decltype(p2)&gt;{&amp;p2};
    } else if constexpr (requires { T{any_type{}}; }) {
        auto&amp;&amp; [p1] = t;
        // structure bindings is not constexpr :/
        if constexpr (N == 0) return ptr&lt;decltype(p1)&gt;{&amp;p1};
    }
}

template &lt;class T, auto N&gt;
[[nodiscard]] consteval auto member_name() {
    constexpr auto name = get_name&lt;N, T&gt;;
    return [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return fixed_string&lt;sizeof...(Ns)&gt;{name[Ns]...};
    }(std::make_index_sequence&lt;name.size()&gt;{});
}

template &lt;class T&gt;
[[nodiscard]] constexpr auto to_tuple(const T&amp; t) {
    if constexpr (requires { T{any_type{}, any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2, p3] = t;
        return std::tuple(
            named&lt;member_name&lt;T, 0&gt;(), decltype(p1)&gt;{.value = p1},
            named&lt;member_name&lt;T, 1&gt;(), decltype(p2)&gt;{.value = p2},
            named&lt;member_name&lt;T, 2&gt;(), decltype(p2)&gt;{.value = p3});
    } else if constexpr (requires { T{any_type{}, any_type{}}; }) {
        auto&amp;&amp; [p1, p2] = t;
        return std::tuple(
            named&lt;member_name&lt;T, 0&gt;(), decltype(p1)&gt;{.value = p1},
            named&lt;member_name&lt;T, 1&gt;(), decltype(p2)&gt;{.value = p2});
    } else if constexpr (requires { T{any_type{}}; }) {
        auto&amp;&amp; [p1] = t;
        return std::tuple(
            named&lt;member_name&lt;T, 0&gt;(), decltype(p1)&gt;{.value = p1});
    } else {
        return std::tuple();
    }
}

struct foo {
    int a;
    int b;
};

constexpr auto t = to_tuple(foo{.a=42, .b=87});
static_assert(&quot;a&quot; == std::get&lt;0&gt;(t).name and 42 == std::get&lt;0&gt;(t).value);
static_assert(&quot;b&quot; == std::get&lt;1&gt;(t).name and 87 == std::get&lt;1&gt;(t).value);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/beq5reqdE">https://godbolt.org/z/beq5reqdE</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>358 - Did you know that C++26 added `Pack Indexing`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/358.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/358.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added <code>Pack Indexing</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2662">https://wg21.link/P2662</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; consteval auto nth(auto... ts) { return ts...[N]; }
static_assert(1 == nth&lt;0&gt;(1, 2, 3));
static_assert(2 == nth&lt;1&gt;(1, 2, 3));
static_assert(3 == nth&lt;2&gt;(1, 2, 3));
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/f1Pav4e9x">https://circle.godbolt.org/z/f1Pav4e9x</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement <code>first</code> and <code>last</code> with Pack Indexing feature and without it?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">consteval auto first(auto... ts); // TODO
consteval auto last(auto... ts);  // TODO

static_assert(1 == first(1, 2, 3));
static_assert(3 == last(1, 2, 3));
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/6cxxdos9r">https://circle.godbolt.org/z/6cxxdos9r</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;size_t Index, class T0, class... Types&gt;
constexpr decltype(auto) nth(T0&amp;&amp; p0, Types&amp;&amp;... pack) noexcept
{
   if constexpr (0 == Index)
       return std::forward&lt;T0&gt;(p0);
   else
       return nth_value&lt;Index-1&gt;(std::forward&lt;Types&gt;(pack)...);
}

consteval auto first(auto... ts) {
    return nth&lt;0&gt;(ts...);
}

consteval auto last(auto... ts) {
    return nth&lt;sizeof...(ts) - 1&gt;(ts...);
}
static_assert(1 == first(1, 2, 3));
static_assert(3 == last(1, 2, 3));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bc71YxGY1">https://godbolt.org/z/bc71YxGY1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// pack indexing
consteval auto first(auto... ts) { return ts...[0]; }
consteval auto last(auto... ts)  { return ts...[sizeof...(ts)-1]; }

// Without pack indexing
consteval auto first(auto... ts) { return [](auto first, auto...) { return first; }(ts...); }
consteval auto last(auto... ts)  { return (ts, ...); }
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/d7K35shjh">https://circle.godbolt.org/z/d7K35shjh</a> </p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>357 - Did you know that C++23 added standard support for `flat_map`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/357.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/357.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added standard support for <code>flat_map</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0429">https://wg21.link/P0429</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  stdext::flat_map&lt;int, int&gt; fm{};
  fm.emplace(1, 2);
  fm.emplace(3, 4);
  assert(fm.size() == 2);
  assert(fm[1]==2 and fm[2]==3);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v7Tf1vj48">https://godbolt.org/z/v7Tf1vj48</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement benchmark between <code>std::map, std::unordered_map, and std::flat_map</code>?</strong></p>
<ul>
<li><a href="https://quick-bench.com/">https://quick-bench.com/</a></li>
</ul>
</li>
</ul>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr int N = 2048;

template &lt;template &lt;class...&gt; typename MapType&gt;
constexpr auto get_values() {
    MapType&lt;int, int&gt; ret;
    for (auto i = 0; i &lt; N; ++i) {
        ret.emplace(std::pair{i, i});
    }
    return ret;
}

const auto values = get_values&lt;std::map&gt;();
void FlatMapInsertion(benchmark::State&amp; state) {
    stdext::flat_map&lt;int, int&gt; m;
    for (auto _ : state) {
        state.PauseTiming();
        m.clear();
        state.ResumeTiming();
        m.insert(values.cbegin(), values.cend());
    }
}

void MapInsertion(benchmark::State&amp; state) {
    std::map&lt;int, int&gt; m;
    for (auto _ : state) {
        state.PauseTiming();
        m.clear();
        state.ResumeTiming();
        m.insert(values.cbegin(), values.cend());
    }
}

void UnorderedMapInsertion(benchmark::State&amp; state) {
    std::unordered_map&lt;int, int&gt; m;
    for (auto _ : state) {
        state.PauseTiming();
        m.clear();
        state.ResumeTiming();
        m.insert(values.cbegin(), values.cend());
    }
}

void FlatMapLookup(benchmark::State&amp; state) {
    const auto m = get_values&lt;stdext::flat_map&gt;();
    for (auto _ : state) {
        for (auto i = 0; i &lt; N; ++i) {
            auto is_present = m.contains(i);
            benchmark::DoNotOptimize(is_present);
        }
    }
}

void MapLookup(benchmark::State&amp; state) {
    const auto m = get_values&lt;std::map&gt;();
    for (auto _ : state) {
        for (auto i = 0; i &lt; N; ++i) {
            auto is_present = m.contains(i);
            benchmark::DoNotOptimize(is_present);
        }
    }
}

void UnorderedMapLookup(benchmark::State&amp; state) {
    const auto m = get_values&lt;std::unordered_map&gt;();
    for (auto _ : state) {
        for (auto i = 0; i &lt; N; ++i) {
            auto is_present = m.contains(i);
            benchmark::DoNotOptimize(is_present);
        }
    }
}
</code></pre>

<blockquote>
<p><a href="https://quick-bench.com/">https://quick-bench.com/</a>q/6MCXQDX5VGG2FOt0sO8TWjwhz9A</p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>356 - Did you know that C++20's `no_unique_address` can be used to find unique types?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/356.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/356.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20's <code>no_unique_address</code> can be used to find unique types?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0840">https://wg21.link/P0840</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class&gt; struct box{};

struct unique {
    [[no_unique_address]] box&lt;int&gt; _1;
    [[no_unique_address]] box&lt;bool&gt; _2;
};
static_assert(sizeof(unique)==1);

struct no_unique {
    [[no_unique_address]] box&lt;int&gt; _1;
    [[no_unique_address]] box&lt;int&gt; _2;
};

static_assert(sizeof(no_unique)!=1);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mdsa16rWT">https://godbolt.org/z/Mdsa16rWT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement generic version of <code>is_unique</code> leveraging described concept?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
constexpr auto is_unique = false; // TODO

static_assert(is_unique&lt;int, bool, char, double, float&gt;);
static_assert(not is_unique&lt;int, bool, char, double, float, int&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Exjdf4sbx">https://godbolt.org/z/Exjdf4sbx</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt; struct box {};

template &lt;class... Ts&gt; struct unique;

template &lt;&gt;
struct unique&lt;&gt; {};

template &lt;class T, class ...Args&gt;
struct unique&lt;T, Args ...&gt; : public unique&lt;Args ...&gt; {
    constexpr explicit unique(T&amp;&amp; t, Args&amp;&amp;... args) : unique&lt;Args...&gt;(args ...) {

    }
    [[no_unique_address]] box&lt;T&gt; t_;
};

template &lt;class... Ts&gt;
constexpr auto is_unique = (sizeof(unique&lt;Ts...&gt;) == 1);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nnPz6djMW">https://godbolt.org/z/nnPz6djMW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class&gt;
struct box {
    box() = delete;
};
template &lt;class... Ts&gt;
struct S;
template &lt;&gt;
struct S&lt;&gt; {};
template &lt;class T, class... Ts&gt;
struct S&lt;T, Ts...&gt; : S&lt;Ts...&gt; {
    [[no_unique_address]] box&lt;T&gt; _;
};

template &lt;class... Ts&gt;
constexpr auto is_unique = sizeof(S&lt;Ts...&gt;) == 1;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rM5q93WEh">https://godbolt.org/z/rM5q93WEh</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>355 - Did you know that C++20 added constinit keyword?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/355.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/355.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added constinit keyword?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1143">https://wg21.link/P1143</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constinit static auto i = 42;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8xWqf9vE8">https://godbolt.org/z/8xWqf9vE8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement example showing constinit with thread_local storage?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">extern constinit thread_local int var;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zznznchEE">https://godbolt.org/z/zznznchEE</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">extern constinit thread_local int var;
auto fn() { return var; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rshcj6Tq5">https://godbolt.org/z/rshcj6Tq5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>354 - Did you know that C++23 added range `string_view` constructor?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/354.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/354.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added range <code>string_view</code> constructor?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1989">https://wg21.link/P1989</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr std::string text = &quot;Hello, World!&quot;;
constexpr std::string_view view(text.c_str() + 7, 5);
static_assert(view == std::string_view{&quot;World&quot;});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GYfWxPc17">https://godbolt.org/z/GYfWxPc17</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>buffer</code> with explicit conversion to string_view?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
struct buffer; // TODO

constexpr buffer&lt;42&gt; b;
static_assert(42 == std::string_view{b}.size());
static_assert(&amp;b.data[0] == std::string_view{b}.begin());
static_assert(&amp;b.data[42] == std::string_view{b}.end());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hKjo8Pr88">https://godbolt.org/z/hKjo8Pr88</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
struct buffer {
    constexpr buffer() {}
    constexpr char const* begin() const { return data; }
    constexpr char const* end() const { return data + N; }
    constexpr operator std::basic_string_view&lt;char&gt;() const {
        return std::basic_string_view&lt;char&gt;(begin(), end());
    }
    char data[N]{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1cY8enTqc">https://godbolt.org/z/1cY8enTqc</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>353 - Did you know that the underlying visit implementation of std::visit has changed since GCC12+, Clang15+?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/353.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/353.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that the underlying visit implementation of std::visit has changed since GCC12+, Clang15+?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/variant.mod#lib:emplace,variant">https://eel.is/c++draft/variant.mod#lib:emplace,variant</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct inc {
    std::variant&lt;Ts...&gt; v{};

    auto operator++() {
        std::visit([&amp;](auto&amp; v) { ++v; }, v);
    }

    template&lt;class T&gt;
    operator T() const {
        T result{};
        std::visit(
            overloaded{
                [&amp;](T v) { result = v; },
                [](auto&amp;&amp;) {}
            }
        , v);
        return result;
    }
};

auto visit(std::int16_t size, std::int32_t iterations) {
    auto it = inc&lt;std::int8_t, std::int16_t, std::int32_t&gt;{size};

    for (auto i = 0; i &lt; iterations; ++i, ++it)
        ;

    return std::int16_t(it);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1813rceKv">https://godbolt.org/z/1813rceKv</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p>**Can you implement different versions of std::visit dispatching and compare its performance?</p>
<ul>
<li>generated switch case</li>
<li>jump table</li>
<li>fold expression</li>
<li>if/else</li>
<li>generted goto</li>
<li>...</li>
</ul>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto visit(auto&amp;&amp; f, auto&amp;&amp; v); // TODO
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eac6YarnG">https://godbolt.org/z/eac6YarnG</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class F, class V, class R, std::size_t N, std::size_t Size&gt;
constexpr auto visit_impl([[maybe_unused]] F&amp;&amp; f, [[maybe_unused]] V&amp;&amp; v) -&gt; R {
  if constexpr (N &lt; Size) {
    switch (v.index()) {
      default:
        return visit_impl&lt;F, V, R, N+1, Size&gt;(std::forward&lt;F&gt;(f), std::forward&lt;V&gt;(v));
      case N:
        return std::forward&lt;F&gt;(f)(std::get&lt;N&gt;(std::forward&lt;V&gt;(v)));
    }
  } else {
    __builtin_unreachable();
  }
}

template&lt;class F, class V, template&lt;class...&gt; class T, class... Ts&gt;
auto result_type(T&lt;Ts...&gt;&amp;&amp;) -&gt;
  std::common_type_t&lt;decltype(std::declval&lt;F&gt;()(std::get&lt;Ts&gt;(std::declval&lt;V&gt;())))...&gt;;

template&lt;class F, class V, template&lt;class...&gt; class T, class... Ts&gt;
auto result_type(T&lt;std::monostate, Ts...&gt;&amp;&amp;) -&gt;
  std::common_type_t&lt;decltype(std::declval&lt;F&gt;()(std::get&lt;Ts&gt;(std::declval&lt;V&gt;())))...&gt;;

template&lt;class F, class V&gt;
constexpr decltype(auto) visit(F&amp;&amp; f, V&amp;&amp; v) {
  using variant_t = std::remove_const_t&lt;std::remove_reference_t&lt;V&gt;&gt;;
  constexpr auto size = std::variant_size_v&lt;variant_t&gt;;
  static_assert(size &gt; 0, &quot;Empty variant is not supported!&quot;);
  using result_t = decltype(result_type&lt;F, V&gt;(std::declval&lt;variant_t&gt;()));
  return visit_impl&lt;F, V, result_t, 0u, size&gt;(std::forward&lt;F&gt;(f), std::forward&lt;V&gt;(v));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YPqGzKP95">https://godbolt.org/z/YPqGzKP95</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>352 - Did you know about C++26 proposal - `variadic friends`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/352.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/352.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 proposal - <code>variadic friends</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2893">https://wg21.link/P2893</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class FriendClass;

class MyClass {
    friend class FriendClass;

public:
    constexpr MyClass(int data) : privateData(data) {}

private:
    int privateData;
};

struct FriendClass {
    constexpr auto accessPrivateData(const MyClass&amp; obj) const {
        return obj.privateData;
    }
};

constexpr MyClass obj{42};
constexpr FriendClass friend_obj{};
static_assert(42 == friend_obj.accessPrivateData(obj));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Te8zzEoPd">https://godbolt.org/z/Te8zzEoPd</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you extend <code>MyClass</code> so that all <code>Ts...</code> will have access to <code>privateData</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class MyClass {
   // TODO

   public:
    constexpr explicit MyClass(int data) : privateData(data) {}

   private:
    int privateData{};
};

template&lt;auto&gt;
struct FriendClass {
    constexpr auto accessPrivateData(const auto&amp; obj) const {
        return obj.privateData;
    }
};

constexpr MyClass&lt;FriendClass&lt;0&gt;, FriendClass&lt;1&gt;, FriendClass&lt;2&gt;&gt; obj{42};
constexpr FriendClass&lt;0&gt; friend_obj0{};
constexpr FriendClass&lt;1&gt; friend_obj1{};
constexpr FriendClass&lt;2&gt; friend_obj2{};

static_assert(42 == friend_obj0.accessPrivateData(obj));
static_assert(42 == friend_obj1.accessPrivateData(obj));
static_assert(42 == friend_obj2.accessPrivateData(obj));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/81dn33e41">https://godbolt.org/z/81dn33e41</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
class MyClass {
   friend Ts...;

   public:
    constexpr explicit MyClass(int data) : privateData(data) {}

   private:
    int privateData{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/noradhE18">https://godbolt.org/z/noradhE18</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>351 - Did you know about C++26 proposal - `inplace_vector`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/351.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/351.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 proposal - <code>inplace_vector</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0843">https://wg21.link/P0843</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    std::inplace_vector&lt;int, 2&gt; v{};
    assert(v.empty());

    v.push_back(1);
    assert(1 == v.size());

    v.push_back(2);
    assert(2 == v.size());

    v.push_back(3); // throws
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o365eWeEb">https://godbolt.org/z/o365eWeEb</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement simplified constexpr version of inplace_vector?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, auto Size&gt;
class inplace_vector; // TODO

static_assert([] {
    inplace_vector&lt;int, 1&gt; v{};
    v.push_back(1);
    return v.size();
}() == 1);

static_assert([] {
    inplace_vector&lt;int, 2&gt; v{};
    v.push_back(1);
    v.push_back(2);
    return v.size();
}() == 2);

static_assert([] {
    inplace_vector&lt;int, 2&gt; v{};
    v.push_back(4);
    v.push_back(2);
    return v[0] + v[1];
}() == 6);

// should not compile
static_assert([] {
    inplace_vector&lt;int, 2&gt; v{};
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    return v.size();
}() == 2)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z51faxfa9">https://godbolt.org/z/z51faxfa9</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct inplace_vector {
    constexpr void push_back(T value) { data_[index_++] = value; }
    constexpr const auto&amp; operator[](auto index) const { return data_[index]; }
    constexpr auto size() const { return index_; }
    constexpr auto clear() { index_ = {}; }

   private:
    std::array&lt;T, Size&gt; data_{};
    std::size_t index_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/acsa59PdG">https://godbolt.org/z/acsa59PdG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
class inplace_vector {
   public:
    constexpr T&amp; push_back(const T&amp; t) {
        if (size_ == Size) {
            throw std::bad_alloc();
        }
        return arr_[size_++].emplace(t);
    }

    constexpr std::size_t size() const { return size_; }

    constexpr T&amp; operator[](std::size_t idx) { return *arr_[idx]; }

   private:
    std::array&lt;std::optional&lt;T&gt;, Size&gt; arr_;
    std::size_t size_ = 0;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/scz4EfTa5">https://godbolt.org/z/scz4EfTa5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>350 - Did you know about C++26 proposal - Aggregates are named tuples?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/350.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/350.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++26 proposal - Aggregates are named tuples?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2141">https://wg21.link/P2141</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;tuple&gt;

struct foo {
    int i{};
    bool b{};
    float f{};
};

constexpr auto f  = foo{.i = 42, .b = true, .f = 4.2f};
static_assert(42 == std::get&lt;0&gt;(f) and std::get&lt;1&gt;(f) and 4.2f == std::get&lt;2&gt;(f));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r5vozndxb">https://godbolt.org/z/r5vozndxb</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you extend std::get to support aggregates?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;tuple&gt;

struct foo {
    int i{};
    bool b{};
    float f{};
};

constexpr auto f  = foo{.i = 42, .b = true, .f = 4.2};
static_assert(42 == std::get&lt;0&gt;(f) and std::get&lt;1&gt;(f) and 4.2 == std::get&lt;2&gt;(f));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MfWEcdh7s">https://godbolt.org/z/MfWEcdh7s</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, std::size_t I, typename = void&gt;
struct has_get : std::false_type {};
template &lt;typename T, std::size_t I&gt;
struct has_get&lt;T, I, std::void_t&lt;decltype(std::get&lt;I&gt;(std::declval&lt;T&gt;()))&gt;&gt;
    : std::true_type {};

namespace std {
template &lt;typename T&gt;
concept DoesNotHaveGetConcept = requires(T t) { !has_get&lt;T, 0&gt;::value; };
namespace mp = boost::mp;
template &lt;std::size_t I&gt;
constexpr auto get(DoesNotHaveGetConcept auto s) {
    return std::get&lt;I&gt;(mp::reflection::to_tuple(s));
}
}  // namespace std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WsTj1Tr79">https://godbolt.org/z/WsTj1Tr79</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>349 - Did you know that C++26 added new SI prefixes?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/349.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/349.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added new SI prefixes?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2734">https://wg21.link/P2734</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;ratio&gt;

static_assert(std::ronna::num == std::quetta::num);
static_assert(std::ronna::den == std::quetta::den);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E16fqd9Ma">https://godbolt.org/z/E16fqd9Ma</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you verify that multiplying femto and exta will produce kilo using ratio helpers</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">static_assert(std::femto * std::exa == std::kilo); // TODO apply ratio helpers
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ko1jhEhWj">https://godbolt.org/z/Ko1jhEhWj</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;std::intmax_t Num1, std::intmax_t Den1, std::intmax_t Num2,
          std::intmax_t Den2&gt;
consteval auto operator*(const std::ratio&lt;Num1, Den1&gt; r,
                         const std::ratio&lt;Num2, Den2&gt; r2) {
    return std::ratio_multiply&lt;decltype(r), decltype(r2)&gt;{};
}

template &lt;std::intmax_t Num1, std::intmax_t Den1, std::intmax_t Num2,
          std::intmax_t Den2&gt;
consteval bool operator==(const std::ratio&lt;Num1, Den1&gt; r,
                          const std::ratio&lt;Num2, Den2&gt; r2) {
    return std::ratio_equal_v&lt;decltype(r), decltype(r2)&gt;;
}

static_assert(std::femto{} * std::exa{} == std::kilo{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qEYnGnvhY">https://godbolt.org/z/qEYnGnvhY</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>348 - Did you know that C++26 changed arithmetic overloads of std::to_string and std::to_wstring to use std::format?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/348.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/348.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 changed arithmetic overloads of std::to_string and std::to_wstring to use std::format?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2587">https://wg21.link/P2587</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    setlocale(LC_ALL, &quot;C&quot;);
    std::cout &lt;&lt; std::to_string(42); // prints 42
    std::cout &lt;&lt; std::to_string(.42); // prints 0.42
    std::cout &lt;&lt; std::to_string(-1e7); // prints -1e+07
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a7xMEq336">https://godbolt.org/z/a7xMEq336</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you add required <code>locale</code> to match expectations?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    using std::literals::string_literals::operator&quot;&quot;s;

    &quot;locale.to_string (all.us)&quot;_test = [] {
        // TODO
        expect(&quot;-1e+07&quot;s == std::to_string(-1e7));
    };

    &quot;locale.to_string (numeric.eu)&quot;_test = [] {
        // TODO
        expect(&quot;1,23&quot;s == std::to_string(1.23));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jocqoM7xd">https://godbolt.org/z/jocqoM7xd</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    using std::literals::string_literals::operator&quot;&quot;s;

    &quot;locale.to_string (all.us)&quot;_test = [] {
        std::setlocale(LC_ALL, &quot;C&quot;);
        expect(&quot;-1e+07&quot;s == std::to_string(-1e7));
    };

    &quot;locale.to_string (numeric.eu)&quot;_test = [] {
       std::setlocale(LC_NUMERIC, &quot;de_DE.UTF-8&quot;);
       expect(&quot;1.23&quot;s == std::to_string(1.23)); // env dependent, should be 1,23
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bd3dn6Eqb">https://godbolt.org/z/bd3dn6Eqb</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>347 - Did you know that C++26 added more constexpr for &lt;cmath&gt; and &lt;complex&gt;?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/347.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/347.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<p>*** <strong>Did you know that C++26 added more constexpr for <cmath> and <complex>?</strong></p>
<ul>
<li><a href="https://wg21.link/P1383">https://wg21.link/P1383</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;cmath&gt;
constexpr auto positive = std::abs(-2);
static_assert(positive == 2);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ar1drdohP">https://godbolt.org/z/ar1drdohP</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>number</code> user defined literal (UDL) which uses constexpr <cmath> functions?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;cmath&gt;

template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_number(); // TODO

static_assert(0 == 0_number);
static_assert(42 == 42_number);
static_assert(123 == 123_number);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8r4frajnv">https://godbolt.org/z/8r4frajnv</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_number() {
    return []&lt;auto... Is, class T = int&gt;(std::index_sequence&lt;Is...&gt;) {
        return std::integral_constant&lt;
            T, (((Cs - '0') * T(std::pow(T(10), sizeof...(Is) - Is - 1))) +
                ...)&gt;{};
    }
    (std::make_index_sequence&lt;sizeof...(Cs)&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qMvKcc8ff">https://godbolt.org/z/qMvKcc8ff</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_number() {
    int result = 0;
    ((result = result * 10 + (Cs - '0')), ...);
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7vs1d51no">https://godbolt.org/z/7vs1d51no</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>346 - Did you know that C++26 added testing for success or failure of &lt;charconv&gt; functions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/346.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/346.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added testing for success or failure of <charconv> functions?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2497">https://wg21.link/P2497</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr std::to_chars_result result{{}};
static_assert(result);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q16djPn3P">https://godbolt.org/z/q16djPn3P</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>format</code> fn which optionally converts given value to chars?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto format(const auto value) -&gt; std::optional&lt;std::array&lt;char, N&gt;&gt;; // TODO

constexpr auto fmt_0 = format&lt;1&gt;(0);
static_assert(fmt_0 and std::string_view{fmt_0-&gt;cbegin(), fmt_0-&gt;cend()} == std::string_view{&quot;0&quot;});

constexpr auto fmt_42 = format&lt;2&gt;(42);
static_assert(fmt_42 and std::string_view{fmt_42-&gt;cbegin(), fmt_42-&gt;cend()} == std::string_view{&quot;42&quot;});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rf7rWc3ee">https://godbolt.org/z/rf7rWc3ee</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto format(const auto value) -&gt; std::optional&lt;std::array&lt;char, N&gt;&gt; {
    std::array&lt;char, N&gt; buffer;
    return std::to_chars(buffer.begin(), buffer.end(), value)
               ? std::optional(buffer)
               : std::nullopt;
};

constexpr auto fmt_0 = format&lt;1&gt;(0);
static_assert(fmt_0 and std::string_view{fmt_0-&gt;cbegin(), fmt_0-&gt;cend()} ==
                            std::string_view{&quot;0&quot;});

constexpr auto fmt_42 = format&lt;2&gt;(42);
static_assert(fmt_42 and std::string_view{fmt_42-&gt;cbegin(), fmt_42-&gt;cend()} ==
                             std::string_view{&quot;42&quot;});

constexpr auto fmt_error = format&lt;1&gt;(42);
static_assert(!fmt_error);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c8vWbGKWf">https://godbolt.org/z/c8vWbGKWf</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>345 - Did you know that C++26 allows constexpr cast from `void*`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/345.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/345.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 allows constexpr cast from <code>void*</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2738">https://wg21.link/P2738</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo{};
constexpr auto f1 = foo{};
constexpr auto ptr = static_cast&lt;const void*&gt;(&amp;f1);
constexpr auto f2 = static_cast&lt;const foo*&gt;(ptr); // okay in C++26
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/noWqb4d5K">https://godbolt.org/z/noWqb4d5K</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement constexpr type-erasure <code>Animal_View</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct Sheep {
    constexpr std::string_view speak() const noexcept { return &quot;Baaaaaa&quot;; }
};

struct Cow {
    constexpr std::string_view speak() const noexcept { return &quot;Mooo&quot;; }
};

// TODO Animal_View

std::string_view do_speak(Animal_View av) { return av.speak(); }

int main() {
    using namespace boost::ut;

    &quot;constexpr cast from void*&quot;_test = [] {
        should(&quot;say Mooo for cow&quot;) = [] {
            constexpr Cow cow;
            auto result = do_speak(cow);
            expect(std::string_view{&quot;Mooo&quot;} == result);
        };

        should(&quot;say Baaaaaa for sheep&quot;) = [] {
            constexpr Sheep sheep;
            auto result = do_speak(sheep);
            expect(std::string_view{&quot;Baaaaaa&quot;} == result);
        };
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aonE3dvcs">https://godbolt.org/z/aonE3dvcs</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct Animal_View {
    const void *animal;
    std::string_view (*speak_func)(const void *animal);

    template &lt;class Animal&gt;
    Animal_View(const Animal &amp;animal)
        : animal(&amp;animal), speak_func([](const void *animal) {
              return static_cast&lt;const Animal *&gt;(animal)-&gt;speak();
          }) {}

    constexpr std::string_view speak() { return speak_func(animal); }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fq6Y8snW5">https://godbolt.org/z/fq6Y8snW5</a><br />
<a href="https://godbolt.org/z/TfxzvTGYT">https://godbolt.org/z/TfxzvTGYT</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>344 - Did you know that C++26 added `Member visit`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/344.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/344.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added <code>Member visit</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2637">https://wg21.link/P2637</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">// C++23
std::visit(overload{
  [](int i){ std::print(&quot;i={}\n&quot;, i); },
  [](std::string s){ std::print(&quot;s={:?}\n&quot;, s); }
}, value);

// C++26
value.visit(overload{
  [](int i){ std::print(&quot;i={}\n&quot;, i); },
  [](std::string s){ std::print(&quot;s={:?}\n&quot;, s); }
});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dMf9b5xMq">https://godbolt.org/z/dMf9b5xMq</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>member visit</code> for variant?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO: variant

int main() {
    constexpr variant&lt;int, double, float&gt; value = 42;

    static_assert(42 == value.visit(overload{
        [](int i) { return i; },
        [](auto)  { return 0; }
    }));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zcqj553dc">https://godbolt.org/z/zcqj553dc</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct overload : Ts... {
    using Ts::operator()...;
};
template &lt;class... Ts&gt;
overload(Ts...) -&gt; overload&lt;Ts...&gt;;

template &lt;class... Ts&gt;
struct variant : std::variant&lt;Ts...&gt; {
    using std::variant&lt;Ts...&gt;::variant;

    constexpr auto visit(auto f) const { return std::visit(f, *this); }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EGMvP963G">https://godbolt.org/z/EGMvP963G</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>343 - Did you know that C++26 std.format added formatting pointers ability?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/343.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/343.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 std.format added formatting pointers ability?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2510">https://wg21.link/P2510</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    auto i = 42;
    std::cout &lt;&lt; std::format(&quot;{:#018X}&quot;, reinterpret_cast&lt;uintptr_t&gt;(&amp;i)); // prints 0X00007FFD9D71776C
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/18rhfdT8x">https://godbolt.org/z/18rhfdT8x</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you fill format strings to properly format given pointers?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    using std::literals::operator&quot;&quot;sv;

    &quot;std.format ptr&quot;_test = [] {
        auto ptr = reinterpret_cast&lt;std::uintptr_t&gt;(nullptr);

        expect(&quot;0&quot;sv == std::format(&quot;TODO&quot;, ptr));
        expect(&quot;000000000000000000&quot;sv == std::format(&quot;TODO&quot;, ptr));
        expect(&quot;0x0000000000000000&quot;sv == std::format(&quot;TODO&quot;, ptr));
        expect(&quot;0X0000000000000000&quot;sv == std::format(&quot;TODO&quot;, ptr));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4eqznEh4q">https://godbolt.org/z/4eqznEh4q</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">&quot;std.format ptr&quot;_test = [] {
    auto ptr = reinterpret_cast&lt;std::uintptr_t&gt;(nullptr);

    expect(&quot;0&quot;sv == std::format(&quot;{:#0}&quot;, ptr));
    expect(&quot;000000000000000000&quot;sv == std::format(&quot;{:#018}&quot;, ptr));
    expect(&quot;0x0000000000000000&quot;sv == std::format(&quot;{:#018x}&quot;, ptr));
    expect(&quot;0X0000000000000000&quot;sv == std::format(&quot;{:#018X}&quot;, ptr));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/seEahYP4T">https://godbolt.org/z/seEahYP4T</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>342 - Did you know that C++26 added 'A nice placeholder with no name'?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/342.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/342.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added 'A nice placeholder with no name'?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2169">https://wg21.link/P2169</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto foo() { return 42; }

int main() {
    auto unused = foo(); // warning in C++23
    auto _ = foo();      // no warning in C++26
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5sY6zs9Yh">https://godbolt.org/z/5sY6zs9Yh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you apply 'A nice placeholder with no name` to the following C++ constructions?</strong></p>
<ul>
<li>guard</li>
<li>structure bindings</li>
<li>assert</li>
<li>NTTP</li>
</ul>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO: guard
// TODO: structure bindings
// TODO: assert
// TODO: NTTP
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1xsqhr93z">https://godbolt.org/z/1xsqhr93z</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">auto guard() {
    std::mutex m;
    std::lock_guard _{m};
    // ...
}

auto structure_bindigns() {
    auto [a, _, c] = std::tuple{1, 2, 3};
    (void)a;
    (void)c;
}

auto assert_() {
    auto _ = 42;
    assert(_ == 42);
}

template&lt;auto _&gt; auto nttp() {}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dx9691YKn">https://godbolt.org/z/dx9691YKn</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>341 - Did you know that C++26 added user-generated static_assert messages?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/341.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/341.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added user-generated static_assert messages?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2741">https://wg21.link/P2741</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(false, std::string_view{&quot;message&quot;});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/njoWdn7T7">https://godbolt.org/z/njoWdn7T7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you apply format for static_assert messages?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO format
struct foo {};
static_assert(sizeof(foo) == 0, format(&quot;Unexpected sizeof: expected 0, got {}&quot;_s, sizeof(foo)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9scM35GzP">https://godbolt.org/z/9scM35GzP</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Cs&gt;
constexpr auto format(const string&lt;Cs...&gt; fmt, auto&amp;&amp;... args) {
    std::array&lt;char, sizeof...(Cs)&gt; a{};
    for (auto i = 0; i &lt; sizeof...(Cs); ++i) {
        if (fmt.str[i] == '{' and fmt.str[i+1] == '}') {
            a[i] = '0'+(args,...);
            a[++i] = ' ';
        } else {
            a[i] = fmt.str[i];
        }
    }
    return a;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oMd7aMqKz">https://godbolt.org/z/oMd7aMqKz</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>340 - Did you know that C++26 added bind front and back to NTTP callables?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/340.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/340.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added bind front and back to NTTP callables?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2714">https://wg21.link/P2714</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  auto bar(int v) { return v; }
};

static_assert(42 == std::bind_front&lt;&amp;foo::bar&gt;(foo{}, 42));
</code></pre>

</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement simplified version of <code>std::bind_front</code> with NTTP callables?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO bind_front

struct foo {
    constexpr auto bar(int n) const { return n; }
};

int main() {
    constexpr auto f = foo{};
    constexpr auto fn = bind_front&lt;&amp;foo::bar&gt;(f);
    static_assert(42 == fn(42));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vKed9Y3a6">https://godbolt.org/z/vKed9Y3a6</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Fn&gt;
[[nodiscard]] constexpr auto bind_front(auto&amp;&amp; obj,auto&amp;&amp;...bound_args) {
    return [=](auto&amp;&amp;...args){
        return (obj.*Fn)(bound_args..., args...);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EExd3rdrx">https://godbolt.org/z/EExd3rdrx</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>339 - Did you know that C++26 added `@, $, and `` to the basic character set?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/339.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/339.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++26 added `@, $, and `` to the basic character set?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2558R2">https://wg21.link/P2558R2</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto $dollar_sign = 42;
auto @commerical_at = 42;
auto `grave_accent = 42;
</code></pre>

</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you write code snippets where added characters can be used with added value?</strong></li>
</ul>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">// math
auto a  = 42;
auto a` = a*2;

// macros
$macro(...) ```

// twitter
auto id = @kris;
</code></pre>

</details></p>
</div>]]></description>
        </item>
<item>
            <title>338 - Did you know about C++20 `std::next_permutation` algorithm?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/338.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/338.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++20 <code>std::next_permutation</code> algorithm?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/alg.permutation.generators#lib:next_permutation">https://eel.is/c++draft/alg.permutation.generators#lib:next_permutation</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto factorial(const auto n) {
    if (n == 0 or n == 1) {
        return 1;
    }
    auto result = 1;
    for (auto i = 2; i &lt;= n; ++i) {
        result *= i;
    }
    return result;
}
static_assert(1 == factorial(0));
static_assert(1 == factorial(1));
static_assert(1 * 2 == factorial(2));
static_assert(1 * 2 * 3 == factorial(3));
static_assert(1 * 2 * 3 * 4 == factorial(4));
static_assert(1 * 2 * 3 * 4 * 5 == factorial(5));
static_assert(1 * 2 * 3 * 4 * 5 * 6 == factorial(6));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/14r8EdevM">https://godbolt.org/z/14r8EdevM</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>permute invoke</code> which will try to call using all possible permutations?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO invoke

template &lt;auto&gt;
struct Foo {};

constexpr auto foo() { return 1; }
constexpr auto bar(Foo&lt;0&gt;) { return 2; } constexpr auto baz(Foo&lt;0&gt;, Foo&lt;1&gt;) { return 3; }

static_assert(1 == invoke&lt;int&gt;(foo));
static_assert(2 == invoke&lt;int&gt;(bar, Foo&lt;0&gt;{}));
static_assert(3 == invoke&lt;int&gt;(baz, Foo&lt;0&gt;{}, Foo&lt;1&gt;{}));
static_assert(3 == invoke&lt;int&gt;(baz, Foo&lt;1&gt;{}, Foo&lt;0&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xeaxP46qW">https://godbolt.org/z/xeaxP46qW</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto N&gt;
[[nodiscard]] constexpr auto permute(std::array&lt;T, N&gt; nums) {
    std::array&lt;std::array&lt;T, N&gt;, factorial(N)&gt; result{};
    auto i = 0;
    do {
        result[i++] = nums;
    } while (std::next_permutation(nums.begin(), nums.end()));
    return result;
}

namespace detail {
template&lt;class&gt; constexpr auto invoke(auto fn, auto... ts) -&gt; std::pair&lt;bool, decltype(fn(ts...))&gt; { return {true, fn(ts...)}; }
template&lt;class R&gt; constexpr auto invoke(...) -&gt; std::pair&lt;bool, R&gt; { return {false, {}}; }

template&lt;auto N&gt; constexpr auto nth(auto... args) {
  return [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](decltype((void*)Ns)..., auto* nth, auto*...) {
      return *nth;
    }(&amp;args...);
  }
  (std::make_index_sequence&lt;N&gt;{});
}
} // namespace detail

template&lt;class R&gt;
constexpr auto invoke(auto fn, auto... ts) -&gt; R {
    constexpr auto ids = []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) { return std::array&lt;std::size_t, sizeof...(Ns)&gt;{Ns...}; }(std::make_index_sequence&lt;sizeof...(ts)&gt;{});
    constexpr auto permutations = permute(ids);

    R result;
    bool called{};
    [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        ([&amp;]&lt;auto N, auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
            std::tie(called, result) = detail::invoke&lt;R&gt;(fn, detail::nth&lt;permutations[N][Is]&gt;(ts...)...);
            return called;
        }.template operator()&lt;Ns&gt;(std::make_index_sequence&lt;permutations[Ns].size()&gt;{}) or ...);
    }(std::make_index_sequence&lt;permutations.size()&gt;{});
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vKbofePes">https://godbolt.org/z/vKbofePes</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto N&gt;
[[nodiscard]] constexpr auto permute(std::array&lt;T, N&gt; nums) {
    std::array&lt;std::array&lt;T, N&gt;, factorial(N)&gt; result{};
    auto i = 0;
    do {
        result[i++] = nums;
    } while (std::next_permutation(nums.begin(), nums.end()));
    return result;
}

namespace detail {
template&lt;class, auto N&gt; constexpr auto invoke(auto fn, auto... ts) -&gt; std::pair&lt;std::integral_constant&lt;int, N&gt;, decltype(fn(ts...))&gt; { return {{}, fn(ts...)}; }
template&lt;class R, auto&gt; constexpr auto invoke(...) -&gt; std::pair&lt;std::integral_constant&lt;int, 0&gt;, R&gt; { return {}; }

template&lt;auto N&gt; constexpr auto nth(auto... args) {
  return [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](decltype((void*)Ns)..., auto* nth, auto*...) {
      return *nth;
    }(&amp;args...);
  }
  (std::make_index_sequence&lt;N&gt;{});
}

template&lt;class R, auto I, auto Size, auto Permutations, auto Split&gt;
constexpr auto invoke_impl(auto fn, auto... ts) -&gt; R {
    if constexpr (I &gt;= Size) {
        return {};
    } else {
        constexpr auto N = [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
            return ([&amp;]&lt;auto N, auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
                return decltype(detail::invoke&lt;R, N+1&gt;(fn, detail::nth&lt;Permutations[N][Is]&gt;(ts...)...)){}.first.value;
            }.template operator()&lt;I+Ns&gt;(std::make_index_sequence&lt;Permutations[I+Ns].size()&gt;{}) + ...);
        }(std::make_index_sequence&lt;Split&gt;{});

        if constexpr (N &gt; 0) {
            constexpr auto N_ = N - 1;
            return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
                return detail::invoke&lt;R, N_&gt;(fn, detail::nth&lt;Permutations[N_][Is]&gt;(ts...)...).second;
            }(std::make_index_sequence&lt;Permutations[N_].size()&gt;{});
        } else {
            constexpr auto chunks = Size / Split;
            return invoke_impl&lt;R, I+chunks, chunks, Permutations&gt;(fn, ts...);
        }
    }
}
} // namespace detail

template&lt;class R&gt;
constexpr auto invoke(auto fn, auto... ts) -&gt; R {
    constexpr auto ids = []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) { return std::array&lt;std::size_t, sizeof...(Ns)&gt;{Ns...}; }(std::make_index_sequence&lt;sizeof...(ts)&gt;{});
    constexpr auto permutations = permute(ids);
    constexpr auto max_params_without_chunking = 7;
    constexpr auto split = 10;

    if constexpr (sizeof...(ts) &lt; max_params_without_chunking) {
        constexpr auto N = [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
            return ([&amp;]&lt;auto N, auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
                return decltype(detail::invoke&lt;R, N+1&gt;(fn, detail::nth&lt;permutations[N][Is]&gt;(ts...)...)){}.first.value;
            }.template operator()&lt;Ns&gt;(std::make_index_sequence&lt;permutations[Ns].size()&gt;{}) + ...);
        }(std::make_index_sequence&lt;permutations.size()&gt;{});

        if constexpr (N &gt; 0) {
            constexpr auto N_ = N - 1;
            return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
                return detail::invoke&lt;R, N_&gt;(fn, detail::nth&lt;permutations[N_][Is]&gt;(ts...)...).second;
            }(std::make_index_sequence&lt;permutations[N_].size()&gt;{});
        } else {
            return {};
        }
    } else {
      return detail::invoke_impl&lt;R, 0, permutations.size(), permutations, split&gt;(fn, ts...);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/97ejzW4Px">https://godbolt.org/z/97ejzW4Px</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>337 - Did you know that run-time dispatching over type-list can be implemented many different ways?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/337.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/337.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li><strong>Did you know that run-time dispatching over type-list can be implemented many different ways?</strong></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;template &lt;class...&gt; class TList, class TEvent, class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(TList&lt;TEvent, TEvents...&gt;, const int id, const T&amp; data,
                        const TExpr&amp; expr) -&gt; decltype(expr(TEvent{data})) {
    switch (id) {
        case TEvent::id:
            return expr(TEvent{data});

        default:
            if constexpr (sizeof...(TEvents) &gt; 0) {
                return dispatch(TList&lt;TEvents...&gt;{}, id, data, expr);
            }
    }
    return {};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YzrTKsahd">https://godbolt.org/z/YzrTKsahd</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p>Can you implement <code>dispatch</code> with the follwing methods?</p>
<ul>
<li>if else</li>
<li>jump table</li>
<li>fold expressions</li>
<li>...</li>
</ul>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;template&lt;class...&gt; class TList, class TEvent, class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(TList&lt;TEvent, TEvents...&gt;, const int id, const T&amp; data, const TExpr&amp; expr) {
  // TODO if else
  return 0;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xcoEe89nf">https://godbolt.org/z/xcoEe89nf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(const int id, const T&amp; data, const TExpr&amp; expr) {
  // TODO jump table
  return 0;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W4c49Mx34">https://godbolt.org/z/W4c49Mx34</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(const int id, const T&amp; data, const TExpr&amp; expr) {
  // TODO fold expressions
  return 0;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9GzW4sYon">https://godbolt.org/z/9GzW4sYon</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;template &lt;class...&gt; class TList, class TEvent, class... TEvents,
          class T, class TExpr&gt;
constexpr auto dispatch(TList&lt;TEvent, TEvents...&gt;, const int id, const T&amp; data,
                        const TExpr&amp; expr) -&gt; decltype(expr(TEvent{data})) {
    // if else
    if (id == TEvent::id) {
        return expr(TEvent{data});
    } else if constexpr (sizeof...(TEvents) &gt; 0) {
        return dispatch(TList&lt;TEvents...&gt;{}, id, data, expr);
    }
    return 0;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/68Kq8sd4K">https://godbolt.org/z/68Kq8sd4K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(const int id, const T&amp; data, const TExpr&amp; expr) {
    // jump table
    const auto jump_table = [expr](TEvents... events) {
        return std::array{(expr(events))...};
    }(TEvents{data}...);
    return jump_table[id];
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7fec111dG">https://godbolt.org/z/7fec111dG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TEvents, class T, class TExpr&gt;
constexpr auto dispatch(const int id, const T&amp; data, const TExpr&amp; expr) {
    // fold expressions
    return ([&amp;](auto&amp;&amp; event) {
        if (id == event.id) {
            return expr(event);
        }
        return 0;
    }(TEvents{data}) +
            ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GzfPerde5">https://godbolt.org/z/GzfPerde5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>336 - Did you know about `gnu::vector_size` extension?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/336.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/336.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>gnu::vector_size</code> extension?</strong></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  using v4si = int [[gnu::vector_size(4 * sizeof(int))]];

  v4si a = {1, 2, 3, 4};
  v4si b = {4, 3, 2, 1};
  v4si c;

  c = a + b;
  std::cout &lt;&lt; c[0] &lt;&lt; c[1] &lt;&lt; c[2] &lt;&lt; c[3]; // prints 5555
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fTMsK8Moh">https://godbolt.org/z/fTMsK8Moh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement <code>matmul</code> - vectorized matrix multiplication with <code>gnu::vector_size</code>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">using v16qi = std::int8_t [[gnu::vector_size(16 * sizeof(std::int8_t))]];

template&lt;auto N&gt;
constexpr auto matmul(v16qi (&amp;A)[N], v16qi (&amp;B)[N], std::int32_t (&amp;C)[N][N]) {
    // TODO
}

int main() {
    using namespace boost::ut;

    &quot;matmul&quot;_test = [] {
        v16qi A[4] = {{1, 2, 3, 4},
                  {5, 6, 7, 8},
                  {9, 10, 11, 12},
                  {13, 14, 15, 16}};
        v16qi B[4] = {{16, 15, 14, 13},
                  {12, 11, 10, 9},
                  {8, 7, 6, 5},
                  {4, 3, 2, 1}};
        std::int32_t C[4][4] = {0};

        matmul(A, B, C);

        expect(C[0][0] = 80 and C[0][3] == 50 and C[3][0] == 560 and C[3][3] == 386);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eGj3eddKM">https://godbolt.org/z/eGj3eddKM</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto matmul(v16qi (&amp;A)[N], v16qi (&amp;B)[N], std::int32_t (&amp;C)[N][N]) {
    static_assert(N &lt;= 16, &quot;Matrices larger than 16x16 are not supported&quot;);
    auto sum = [](const auto &amp;vec) {
        auto ret = [&amp;vec]&lt;std::size_t... Idxs&gt;(std::index_sequence&lt;Idxs...&gt;) {
            return (vec[Idxs] + ...);
        }(std::make_index_sequence&lt;N&gt;{});
        return ret;
    };
    using v64si = std::int32_t [[gnu::vector_size(16 * sizeof(std::int32_t))]];
    auto get_col = [&amp;B](const auto col_idx) {
        auto col =
            [&amp;B, col_idx]&lt;std::size_t... Idxs&gt;(std::index_sequence&lt;Idxs...&gt;) {
                return v16qi{B[Idxs][col_idx]...};
            }(std::make_index_sequence&lt;N&gt;{});
        return __builtin_convertvector(col, v64si);
    };
    for (auto i = 0; i &lt; N; ++i) {
        for (auto j = 0; j &lt; N; ++j) {
            C[i][j] = sum(__builtin_convertvector(A[i], v64si) * get_col(j));
        }
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/earr7KxK4">https://godbolt.org/z/earr7KxK4</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>335 - Did you know that you can simplify `boost.mp11` API with DSL*?*</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/335.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/335.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that you can simplify <code>boost.mp11</code> API with DSL<em>?</em></strong></p>
</li>
<li>
<p><a href="https://github.com/boostorg/mp11">https://github.com/boostorg/mp11</a></p>
</li>
<li>DSL - Domain Specific Language</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T1, class T2&gt;
[[nodiscard]] constexpr auto operator==(const T1&amp;, const T2&amp;) { return std::is_same_v&lt;T1, T2&gt;; }

template &lt;class... Ts&gt;
constexpr auto list = mp11::mp_list&lt;Ts...&gt;{};

static_assert(list&lt;&gt; == list&lt;&gt;);
static_assert(list&lt;int&gt; == list&lt;int&gt;);
static_assert(list&lt;int, double&gt; == list&lt;int, double&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fTMsK8Moh">https://godbolt.org/z/fTMsK8Moh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement DSL for boost.mp11</li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct event {};
class foo1 : event {};
class foo2 : event { int i; };
class bar1 {};
class bar2 { int i; };

template&lt;class... Ts&gt;
constexpr auto unique_event_ptrs =
    list&lt;Ts...&gt;
  | unique
  | filter&lt;is_base_of&lt;event&gt;&gt;
  | transform&lt;add_pointer&gt;
  ;

static_assert(unique_event_ptrs&lt;&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;foo1&gt; == list&lt;foo1*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo1&gt; == list&lt;foo1*&gt;);
static_assert(unique_event_ptrs&lt;bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;bar1, bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;bar2, bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;foo2, foo1&gt; == list&lt;foo2*, foo1*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo1, foo2, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo1, bar1, bar2&gt; == list&lt;foo1*&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rjh6hhK6j">https://godbolt.org/z/rjh6hhK6j</a></p>
</blockquote>
</details></p>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
constexpr auto list = mp11::mp_list&lt;Ts...&gt;{};

struct unique {
} unique;
template &lt;template &lt;typename...&gt; class List, typename... Ts&gt;
constexpr auto operator|(const List&lt;Ts...&gt; &amp;, struct unique)
    -&gt; mp11::mp_unique&lt;List&lt;Ts...&gt;&gt; {
    return {};
};

template &lt;typename F&gt;
struct filter_t {};
template &lt;typename F&gt;
constexpr auto filter = filter_t&lt;F&gt;{};

template &lt;class B&gt;
struct is_base_of {
    template &lt;class D&gt;
    using fn = std::is_base_of&lt;B, D&gt;;
};

template &lt;typename F, template &lt;typename...&gt; class List, typename... Ts&gt;
constexpr auto operator|(const List&lt;Ts...&gt; &amp;, const filter_t&lt;F&gt; &amp;)
    -&gt; mp11::mp_filter_q&lt;F, List&lt;Ts...&gt;&gt; {
    return {};
};

template &lt;typename F&gt;
struct transform_t {};
template &lt;typename F&gt;
constexpr auto transform = transform_t&lt;F&gt;{};

struct add_pointer {
    template &lt;class T&gt;
    using fn = T *;
};

template &lt;typename F, template &lt;typename...&gt; class List, typename... Ts&gt;
constexpr auto operator|(const List&lt;Ts...&gt; &amp;, const transform_t&lt;F&gt; &amp;)
    -&gt; mp11::mp_transform_q&lt;F, List&lt;Ts...&gt;&gt; {
    return {};
};

template &lt;class T1, class T2&gt;
constexpr auto operator==(const T1 &amp;, const T2 &amp;) {
    return std::is_same_v&lt;T1, T2&gt;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rKc6rdfee">https://godbolt.org/z/rKc6rdfee</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#include &lt;boost/mp11.hpp&gt;

using namespace boost::mp11;

template&lt;class T1, class T2&gt;
[[nodiscard]] constexpr auto operator==(const T1 &amp;, const T2 &amp;) { return std::is_same_v&lt;T1, T2&gt;; }

template&lt;class T, class Q&gt;
[[nodiscard]] constexpr auto operator|(const T &amp;, const Q &amp;) { return mp_invoke_q&lt;Q, T&gt;{}; }

template&lt;class... Ts&gt;
constexpr auto list = mp_list&lt;Ts...&gt;{};

constexpr mp_quote&lt;mp_unique&gt; unique;

template &lt;class T&gt;
using is_base_of = mp_bind_front&lt;std::is_base_of, T&gt;;

using add_pointer = mp_quote_trait&lt;std::add_pointer&gt;;

template&lt;class Q&gt;
constexpr mp_bind_front&lt;mp_filter_q, Q&gt; filter;

template&lt;class Q&gt;
constexpr mp_bind_front&lt;mp_transform_q, Q&gt; transform;


struct event {
};

class foo1 : event {
};

class foo2 : event {
    int i;
};

class bar1 {
};

class bar2 {
    int i;
};

template&lt;class... Ts&gt;
constexpr auto unique_event_ptrs =
        list&lt;Ts...&gt; | unique | filter&lt;is_base_of&lt;event&gt;&gt; | transform&lt;add_pointer&gt;;

static_assert(unique_event_ptrs&lt;&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;foo1&gt; == list&lt;foo1*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo1&gt; == list&lt;foo1*&gt;);
static_assert(unique_event_ptrs&lt;bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;bar1, bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;bar2, bar1&gt; == list&lt;&gt;);
static_assert(unique_event_ptrs&lt;foo2, foo1&gt; == list&lt;foo2*, foo1*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo1, foo2, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, foo2, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo2&gt; == list&lt;foo1*, foo2*&gt;);
static_assert(unique_event_ptrs&lt;foo1, bar1, foo1, foo1, bar1, bar2&gt; ==
              list&lt;foo1*&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1bf3noEhG">https://godbolt.org/z/1bf3noEhG</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>334 - Did you know that C++23 added std::invoke_r?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/334.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/334.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added std::invoke_r?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2136">https://wg21.link/P2136</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;functional&gt;

constexpr auto sum(auto... ts) { return (ts + ...); }
static_assert(typeid(int) == typeid(std::invoke_r&lt;int&gt;(&amp;sum&lt;short, short&gt;, 3, 4)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1Wd6Ms3Wa">https://godbolt.org/z/1Wd6Ms3Wa</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement fn <code>call</code> which invokes fn <code>sum</code> with given parameters <code>ts...</code> via <code>invoke_r</code> and returns a <code>common_type</code> of <code>ts...</code> sum?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum(auto... ts) { return (ts + ...); }

[[nodiscard]] constexpr auto call(auto... ts); // TODO

static_assert(6 == call(1, 2, 3));
static_assert(typeid(int) == typeid(call(1, 2, 3)));

static_assert(6u == call(1u, 2u, 3u));
static_assert(typeid(unsigned) == typeid(call(1u, 2u, 3u)));

static_assert(6u == call(1, 2u, 3l));
static_assert(typeid(long) == typeid(call(1, 2u, 3l)));

static_assert(6u == call(1ll, 2ull, 3l));
static_assert(typeid(unsigned long long) == typeid(call(1ll, 2ull, 3l)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3WP5YG8dv">https://godbolt.org/z/3WP5YG8dv</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto call(auto... ts) {
    using Ret = std::common_type_t&lt;decltype(ts)...&gt;;
    return std::invoke_r&lt;Ret&gt;(sum&lt;decltype(ts)...&gt;, ts...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1baMcc331">https://godbolt.org/z/1baMcc331</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto call(auto... ts){
    using T = typename std::common_type_t&lt;decltype(ts)...&gt;;
    return std::invoke_r&lt;T&gt;(&amp;sum&lt;decltype(ts)...&gt;, ts...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xcn9qnrcY">https://godbolt.org/z/xcn9qnrcY</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>333 - Did you know that C++20 added std::span?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/333.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/333.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++20 added std::span?</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/views.span#span.elem">https://eel.is/c++draft/views.span#span.elem</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;span&gt;

constexpr std::array a = {1, 2, 3, 4, 5};
constexpr std::span s{a};

static_assert(s[0]==a[0]);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T76csW9MM">https://godbolt.org/z/T76csW9MM</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement sum using std algorithms which takes the span?</strong></p>
<ul>
<li>Double points for finding multiple algorithms to achieve it</li>
</ul>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr std::array a = {1, 2, 3, 4, 5};
constexpr std::span s{a};

//TODO sum

static_assert(15 == sum(s));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4hYExTxdq">https://godbolt.org/z/4hYExTxdq</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr std::array a = {1, 2, 3, 4, 5};
constexpr std::span s{a};

constexpr auto sum = []([[maybe_unused]] auto s) {
    return std::reduce(s.begin(), s.end(), 0);
};

static_assert(15 == sum(s));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zff6qPcT5">https://godbolt.org/z/zff6qPcT5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr std::array a = {1, 2, 3, 4, 5};
constexpr std::span s{a};

constexpr auto sum = []([[maybe_unused]] auto s) {
    return std::accumulate(std::cbegin(s), std::cend(s), 0);
};

static_assert(15 == sum(s));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1dx51dWeq">https://godbolt.org/z/1dx51dWeq</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>332 - Did you know that in C++ you can generate jump tables at compile-time?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/332.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/332.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that in C++ you can generate jump tables at compile-time?</strong></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Branch_table">https://en.wikipedia.org/wiki/Branch_table</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; constexpr auto foo() { return N; }

constexpr std::array jump_table{
    foo&lt;0&gt;,
    foo&lt;1&gt;,
    foo&lt;2&gt;,
};

static_assert(0 == jump_table[0]());
static_assert(1 == jump_table[1]());
static_assert(2 == jump_table[2]());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x3xa9erGE">https://godbolt.org/z/x3xa9erGE</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implemnt dispatch fn which generates jump table for given N?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; constexpr auto foo() { return N; }

template&lt;auto N = 42&gt;
constexpr auto dispatch(auto n); // TODO

static_assert(1 == dispatch(1));
static_assert(7 == dispatch(7));
static_assert(23 == dispatch(23));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4M9x1vjcG">https://godbolt.org/z/4M9x1vjcG</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N = 42&gt;
constexpr auto dispatch(auto n) -&gt; int {
    using foo_return_type = std::invoke_result&lt;decltype(&amp;foo&lt;0&gt;)&gt;::type;
    const auto jump_table = []&lt;auto... I&gt;(std::index_sequence&lt;I...&gt;) {
        return std::array&lt;foo_return_type, sizeof...(I)&gt;{(foo&lt;I&gt;())...};
    }(std::make_index_sequence&lt;N&gt;{});
    return jump_table[n];
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PW3qvrnf6">https://godbolt.org/z/PW3qvrnf6</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>331 - Did you about C++17 std::index_sequence, std::make_index_sequence?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/331.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/331.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you about C++17 std::index_sequence, std::make_index_sequence?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/utility.syn#lib:index_sequence">https://eel.is/c++draft/utility.syn#lib:index_sequence</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class...&gt; struct whats_my_type;
int main() { whats_my_type&lt;std::make_index_sequence&lt;7&gt;&gt;{}; } // error: implicit instantiation of undefined template whats_my_type&lt;std::integer_sequence&lt;unsigned long, 0, 1, 2, 3, 4, 5, 6&gt;&lt;source&gt;:8:3: error: implicit instantiation of undefined template whats_my_type&lt;std::integer_sequence&lt;unsigned long, 0, 1, 2, 3, 4, 5, 6&gt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bj88jMWfW">https://godbolt.org/z/bj88jMWfW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you generate - at compile time - a matrix (3x3) with values { true: if T.bar(id<X, Y>) is available, false: otherwise }</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto...&gt; struct id {};

struct Foo {
    constexpr auto bar(id&lt;0, 0&gt;) {}
    constexpr auto bar(id&lt;1, 1&gt;) {}
    constexpr auto bar(id&lt;2, 2&gt;) {}
};

template &lt;class T, auto N = 3&gt;
constexpr const auto matrix;  // TODO
    // matrix&lt;int, 3&gt;:
    //   .long 1 # 0x1 // because Foo has bar(id&lt;0, 0&gt;)
    //   .long 0 # 0x0
    //   .long 0 # 0x0
    //   .long 0 # 0x0
    //   .long 1 # 0x1 // because Foo has bar(id&lt;1, 1&gt;)
    //   .long 0 # 0x0
    //   .long 0 # 0x0
    //   .long 0 # 0x0
    //   .long 1 # 0x1 // because Foo has bar(id&lt;2, 2&gt;)

static_assert(matrix&lt;Foo&gt;[0][0]);
static_assert(not matrix&lt;Foo&gt;[0][1]);
static_assert(not matrix&lt;Foo&gt;[0][2]);
static_assert(not matrix&lt;Foo&gt;[0][1]);
static_assert(matrix&lt;Foo&gt;[1][1]);
static_assert(not matrix&lt;Foo&gt;[2][1]);
static_assert(not matrix&lt;Foo&gt;[0][2]);
static_assert(not matrix&lt;Foo&gt;[1][2]);
static_assert(matrix&lt;Foo&gt;[2][2]);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3YvfqezPa">https://godbolt.org/z/3YvfqezPa</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N = 3, class = std::make_index_sequence&lt;N&gt;&gt;
constexpr const std::array&lt;std::array&lt;int, N&gt;, N&gt; matrix{};

template &lt;class T, auto N, auto... Is&gt;
constexpr const std::array matrix&lt;T, N, std::index_sequence&lt;Is...&gt;&gt;{
    []&lt;auto I&gt; -&gt; std::array&lt;int, 3&gt; {
        return {[]&lt;auto J&gt; -&gt; int {
            return requires(T v, id&lt;I, J&gt; p) { v.bar(p); };
        }.template operator()&lt;Is&gt;()...};
    }.template operator()&lt;Is&gt;()...};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yq9xdYo3a">https://godbolt.org/z/Yq9xdYo3a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto... ns&gt;
constexpr auto has = []() { return requires(T t) { t.bar(id&lt;ns...&gt;{}); }; };

template &lt;class T, auto R, auto N&gt;
constexpr auto row = []() {
    constexpr auto make_row =
        []&lt;auto... I&gt;(std::index_sequence&lt;I...&gt;) -&gt; std::array&lt;bool, N&gt; {
        return {has&lt;T, R, I&gt;()...};
    };

    return make_row(std::make_index_sequence&lt;N&gt;{});
};

template &lt;class T, auto N&gt;
constexpr auto rows = []() {
    constexpr auto make_rows = []&lt;auto... R&gt;(std::index_sequence&lt;R...&gt;)
        -&gt; std::array&lt;std::array&lt;bool, N&gt;, N&gt; { return {row&lt;T, R, N&gt;()...}; };

    return make_rows(std::make_index_sequence&lt;N&gt;{});
};

template &lt;class T, auto N = 3&gt;
constexpr const auto matrix = rows&lt;T, N&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gcx4sd5E3">https://godbolt.org/z/Gcx4sd5E3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, auto N, auto X, auto C = X % N, auto R = (X - C) / N&gt;
concept hasBar = requires(T t) {
    { t.bar(std::declval&lt;id&lt;R, C&gt;&gt;()) };
};

template &lt;auto N, typename... Args&gt;
constexpr std::array&lt;std::array&lt;long, N&gt;, N&gt; make_symmetric_matrix(
    Args&amp;&amp;... args) {
    return {std::forward&lt;Args&gt;(args)...};
}

template &lt;class T, auto N = 3&gt;
constexpr const auto matrix =
    []&lt;auto... Indices&gt;(std::index_sequence&lt;Indices...&gt;)
    -&gt; std::array&lt;std::array&lt;long, N&gt;, N&gt; {
    return make_symmetric_matrix&lt;N&gt;(hasBar&lt;T, N, static_cast&lt;int&gt;(Indices)&gt;...);
}(std::make_index_sequence&lt;N * N&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bdjEadn5f">https://godbolt.org/z/bdjEadn5f</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>330 - Did you know that C++17 added std::pmr::polymorphic_allocator?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/330.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/330.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 added std::pmr::polymorphic_allocator?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/mem.res.syn#header:%3cmemory_resource">https://eel.is/c++draft/mem.res.syn#header:%3cmemory_resource</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;memory_resource&gt;
#include &lt;cassert&gt;

int main() {
    // Create a memory resource
    std::pmr::monotonic_buffer_resource resource(1024);

    // Create a polymorphic allocator using the memory resource
    std::pmr::polymorphic_allocator&lt;int&gt; allocator(&amp;resource);

    // Allocate memory for an array of 10 integers using the polymorphic allocator
    int* ptr = allocator.allocate(10);

    // Test that the allocation was successful
    assert(ptr);

    // Deallocate the memory
    allocator.deallocate(ptr, 10);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1h7voEGo6">https://godbolt.org/z/1h7voEGo6</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you create pmr::vector which will use pmr::monotonic_buffer_resource/pmr::polymorphic_allocator?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;memory_resource&gt;
#include &lt;vector&gt;

int main() {
    using namespace boost::ut;
    std::array&lt;char, 1024&gt; buffer{};

    &quot;pmr&quot;_test = [&amp;buffer] {
        std::pmr::vector&lt;char&gt; vec{};  // TODO

        vec.push_back('a');
        vec.push_back('b');
        vec.push_back('c');

        expect(vec[0] == 'a' and vec[1] == 'b' and vec[2] == 'c');
        expect(std::string_view(buffer.data(), buffer.size()).contains(&quot;abc&quot;));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o1hx1fdEn">https://godbolt.org/z/o1hx1fdEn</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    std::array&lt;char, 1024&gt; buffer{};

    &quot;pmr&quot;_test = [&amp;buffer] {
        std::pmr::monotonic_buffer_resource buf{buffer.data(), buffer.size()};
        std::pmr::polymorphic_allocator&lt;int&gt; alloc{&amp;buf};
        std::pmr::vector&lt;char&gt; vec{alloc};

        vec.push_back('a');
        vec.push_back('b');
        vec.push_back('c');

        expect(vec[0] == 'a' and vec[1] == 'b' and vec[2] == 'c');
        expect(std::string_view(buffer.data(), buffer.size()).contains(&quot;abc&quot;));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9xP7odnc6">https://godbolt.org/z/9xP7odnc6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;

    std::array&lt;char, 1024&gt; buffer{};

    &quot;pmr&quot;_test = [&amp;buffer] {
        std::pmr::monotonic_buffer_resource resource{std::data(buffer),
                                                     std::size(buffer)};
        std::pmr::polymorphic_allocator&lt;char&gt; allocator{&amp;resource};

        std::pmr::vector&lt;char&gt; vec{allocator};

        vec.push_back('a');
        vec.push_back('b');
        vec.push_back('c');

        expect(vec[0] == 'a' and vec[1] == 'b' and vec[2] == 'c');
        expect(std::string_view(buffer.data(), buffer.size()).contains(&quot;abc&quot;));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dK9M6M1fx">https://godbolt.org/z/dK9M6M1fx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    std::array&lt;char, 1024&gt; buffer{};
    std::pmr::monotonic_buffer_resource resource{buffer.data(), buffer.size()};

    &quot;pmr&quot;_test = [&amp;] {
        std::pmr::vector&lt;char&gt; vec(&amp;resource);

        vec.push_back('a');
        vec.push_back('b');
        vec.push_back('c');

        expect(vec[0] == 'a' and vec[1] == 'b' and vec[2] == 'c');
        expect(std::string_view(buffer.data(), buffer.size()).contains(&quot;abc&quot;));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/obM6vv8Yc">https://godbolt.org/z/obM6vv8Yc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
    using namespace boost::ut;
    std::array&lt;char, 1024&gt; buffer{};

    &quot;pmr&quot;_test = [&amp;buffer] {
        // Create a memory resource
        std::pmr::monotonic_buffer_resource resource{buffer.data(),
                                                     buffer.size()};

        // Create a polymorphic allocator using the memory resource
        std::pmr::polymorphic_allocator&lt;char&gt; allocator(&amp;resource);

        // std::vector&lt;char, decltype(allocator)&gt; vec{allocator};
        std::pmr::vector&lt;char&gt; vec{allocator};

        vec.push_back('a');
        vec.push_back('b');
        vec.push_back('c');

        expect(vec[0] == 'a' and vec[1] == 'b' and vec[2] == 'c');
        expect(std::string_view(buffer.data(), buffer.size()).contains(&quot;abc&quot;));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f6boajrG4">https://godbolt.org/z/f6boajrG4</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>329 - Did you know about C++ allows to pass Pointer To Member Function via template parameter?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/329.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/329.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++ allows to pass Pointer To Member Function via template parameter?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/expr.mptr.oper#:operator,pointer_to_member">https://eel.is/c++draft/expr.mptr.oper#:operator,pointer_to_member</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct header { int type{}; };

int main() {
    std::cout &lt;&lt; []&lt;auto Ptr&gt;(const auto&amp; msg) {
        return msg.*Ptr;
    }.operator()&lt;&amp;header::type&gt;(header{42});  // prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cabhaoec1">https://godbolt.org/z/cabhaoec1</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a <code>dispatch</code> lambda expression which calls <code>::dispatch</code> function based on <code>header::type</code> and <code>msg::id</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct [[gnu::packed]] header {
    int type{};
};

struct [[gnu::packed]] msg1 : header {
    static constexpr auto id = 1;
    int i{};
};

struct [[gnu::packed]] msg2 : header {
    static constexpr auto id = 2;
    float f{};
};

auto dispatch(std::ostream&amp; out, const msg1&amp; msg) { out &lt;&lt; &quot;msg1: &quot; &lt;&lt; msg.i; }
auto dispatch(std::ostream&amp; out, const msg2&amp; msg) { out &lt;&lt; &quot;msg2: &quot; &lt;&lt; msg.f; }

#include &lt;[https://raw.githubusercontent.com/boost-ext/ut/v1.1.9/include/boost/ut.hpp](https://raw.githubusercontent.com/boost-ext/ut/v1.1.9/include/boost/ut.hpp)&gt;

int main() {
    using namespace boost::ut;

    constexpr auto dispatch = /* TODO */;

    &quot;pointer to member dispatch not found&quot;_test = [dispatch] {
        const auto msg = msg1{};
        const void* buffer = &amp;msg;
        std::stringstream out{};

        dispatch.operator()&lt;&amp;header::type, msg1, msg2&gt;(out, buffer);

        expect(std::empty(out.str()));
    };

    &quot;pointer to member dispatch found msg1&quot;_test = [dispatch] {
        const auto msg = msg1{msg1::id, 42};
        const void* buffer = &amp;msg;
        std::stringstream out{};

        dispatch.operator()&lt;&amp;header::type, msg1, msg2&gt;(out, buffer);

        expect(out.str() == std::string_view{&quot;msg1: 42&quot;});
    };

    &quot;pointer to member dispatch found msg2&quot;_test = [dispatch] {
        const auto msg = msg2{msg2::id, 4.2};
        const void* buffer = &amp;msg;
        std::stringstream out{};

        dispatch.operator()&lt;&amp;header::type, msg1, msg2&gt;(out, buffer);

        expect(out.str() == std::string_view{&quot;msg2: 4.2&quot;});
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q7n71h97z">https://godbolt.org/z/q7n71h97z</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto dispatch = []&lt;auto Type, typename... Msgs&gt;(
                              auto&amp; out, const auto&amp; buffer) {
    const auto type = static_cast&lt;const header*&gt;(buffer)-&gt;*Type;
    (
        [&amp;]() {
            switch (type) {
                case Msgs::id:
                    const auto&amp; msg = *static_cast&lt;const Msgs*&gt;(buffer);
                    ::dispatch(out, msg);
                    break;
            }
        }(),
        ...);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7PMv1GE98">https://godbolt.org/z/7PMv1GE98</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto dispatch = []&lt;auto pm, class... Ts&gt;(std::ostream&amp; out,
                                                   const void* buffer) {
    const auto type = static_cast&lt;const header*&gt;(buffer)-&gt;*pm;

    std::variant&lt;std::monostate, Ts...&gt; v;
    (
        [&amp;]() {
            if (type == Ts::id) {
                v = *static_cast&lt;const Ts*&gt;(buffer);
            }
        }(),
        ...);

    return std::visit(overload{[&amp;](auto&amp;&amp; msg) { ::dispatch(out, msg); },
                               [](std::monostate) {}},
                      v);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4Pz33K4Pq">https://godbolt.org/z/4Pz33K4Pq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto dispatch = []&lt;auto Ptr, class... MessageTypes&gt;(
                              auto&amp; out, auto buffer) -&gt; void {
    const auto helper = [&amp;]&lt;class M&gt;(const M* m) {
        if (m-&gt;*Ptr == M::id) {
            ::dispatch(out, (M)(*reinterpret_cast&lt;const M*&gt;(buffer)));
        }
    };
    (helper(reinterpret_cast&lt;const MessageTypes*&gt;(buffer)), ...);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sYGdEjq5q">https://godbolt.org/z/sYGdEjq5q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto dispatch = [&amp;]&lt;auto Ptr, class... Ts&gt;(std::stringstream&amp; out,
                                                     const void* buffer) {
    ((reinterpret_cast&lt;const header*&gt;(buffer)-&gt;*Ptr == Ts::id &amp;&amp;
      (::dispatch(out, *reinterpret_cast&lt;const Ts*&gt;(buffer)), true)) ||
     ...);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/acvzx1re7">https://godbolt.org/z/acvzx1re7</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>328 - Did you know that C++23 extended floating-point types?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/328.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/328.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 extended floating-point types?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1467R9">https://wg21.link/P1467R9</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;stdfloat&gt;

int main() {
    std::float16_t   f16 = .42f16;
    std::bfloat16_t bf16 = .42bf16;
    std::float32_t   f32 = .42f32;
    std::float64_t   f64 = .42f64;
    std::float128_t f128 = .42f128;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qrE4v1eno">https://godbolt.org/z/qrE4v1eno</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>min_max</code> which returns a tuple with min and max element based on given predicate?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
    static_assert(
        std::tuple{sizeof(.1f16), sizeof(.1f64)} == min_max&lt;[]&lt;class T&gt; { return sizeof(T); }&gt;(
            std::tuple{.1f16, .1f64})
    );

    static_assert(
        std::tuple{sizeof(.1f16), sizeof(.1f128)} == min_max&lt;[]&lt;class T&gt; { return sizeof(T); }&gt;(
            std::tuple{.1f16, .1f32, .1f64, .1f128})
    );

    static_assert(
        std::tuple{sizeof(.1f32), sizeof(.1f128)} == min_max&lt;[]&lt;class T&gt; { return sizeof(T); }&gt;(
            std::tuple{.1f128, .1f32, .1f32, .1f64})
    );
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/59z431vWc">https://godbolt.org/z/59z431vWc</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
template <auto Func, typename... Ts><br />
constexpr auto min_max(std::tuple<Ts...>&amp;&amp; tuple)<br />
    -&gt; std::tuple<size_t, size_t> {<br />
    using tuple_t = typename std::remove_cvref_t<decltype(tuple)>;<br />
    std::array<size_t, std::tuple_size_v\<tuple_t>> buffer = {};<br />
    []<size_t... Is>(auto&amp;&amp; tuple, auto&amp; out,<br />
                     std::index_sequence<Is...> indicies) {<br />
        (static_cast<void>(<br />
             out[Is] =<br />
                 Func.template operator()<std::tuple_element_t\<Is, tuple_t>>()),<br />
         ...);<br />
    }(std::forward<decltype(tuple)>(tuple), buffer,<br />
      std::make_index_sequence<std::tuple_size_v\<tuple_t>>{});<br />
    const auto [min, max] = std::ranges::minmax(buffer);<br />
    return {min, max};<br />
}</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/E36Eh4fqz](https://godbolt.org/z/E36Eh4fqz)

```cpp
template &lt;auto F, class... Ts&gt;
constexpr auto min_max(std::tuple&lt;Ts...&gt; &amp;&amp;)
    -&gt; std::tuple&lt;std::size_t, std::size_t&gt; {
    return {
        std::min({F.template operator()&lt;Ts&gt;()...}),
        std::max({F.template operator()&lt;Ts&gt;()...}),
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jb163dP48">https://godbolt.org/z/jb163dP48</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Pred, class... Ts&gt;
constexpr auto min_max(std::tuple&lt;Ts...&gt;&amp;&amp;) -&gt; std::tuple&lt;size_t, size_t&gt; {
    auto [mi, mx] = std::minmax({Pred.template operator()&lt;Ts&gt;()...});

    return std::make_tuple(mi, mx);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ph8vx3xq1">https://godbolt.org/z/Ph8vx3xq1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Fn, class... Ts&gt;
constexpr auto min_max(std::tuple&lt;Ts...&gt;&amp;&amp;) {
    return std::tuple{std::minmax({Fn.template operator()&lt;Ts&gt;()...})};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4baj4jeTT">https://godbolt.org/z/4baj4jeTT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto predicate, typename... Ts&gt;
constexpr std::tuple&lt;std::size_t, std::size_t&gt; min_max(
    std::tuple&lt;Ts...&gt;&amp;&amp; tuple) {
    return std::minmax({predicate.template operator()&lt;Ts&gt;()...});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aand176rb">https://godbolt.org/z/aand176rb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto pred, class... Ts&gt;
constexpr std::tuple&lt;size_t, size_t&gt; min_max(const std::tuple&lt;Ts...&gt;&amp;) {
    return std::minmax({pred.template operator()&lt;Ts&gt;()...});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zxYj97dn7">https://godbolt.org/z/zxYj97dn7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto P&gt;
auto min_max = [](auto t) {
    const auto values = std::apply(
        [&amp;]&lt;class... F&gt;(F&amp;... floats) {
            return std::make_tuple(P.template operator()&lt;F&gt;()...);
        },
        t);
    const auto min = std::apply(
        [](auto&amp;&amp;... args) { return (std::min({args...})); }, values);
    const auto max = std::apply(
        [](auto&amp;&amp;... args) { return (std::max({args...})); }, values);
    return std::tuple(min, max);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6zq8hT4YE">https://godbolt.org/z/6zq8hT4YE</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>327 - Did you know that C++17 added `std::forward_as_tuple` and `std::make_from_tuple` and whats the difference between them?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/327.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/327.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 added <code>std::forward_as_tuple</code> and <code>std::make_from_tuple</code> and whats the difference between them?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/tuple.creation">http://eel.is/c++draft/tuple.creation</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  struct foo {
    int i;
    bool b;
  };

  const int i = 42;
  const auto f = std::make_from_tuple&lt;foo&gt;(std::forward_as_tuple(i, true));
  std::cout &lt;&lt; f.i &lt;&lt; ' ' &lt;&lt; f.b &lt;&lt; '\n'; // prints 42 1
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1i66M6">https://godbolt.org/z/1i66M6</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement simplified version of <code>std::forward_as_tuple</code> and <code>std::make_from_tuple</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">namespace tip_std {
// TODO: make_from_tuple
// TODO: forward_as_tuple
}

struct foo {
    int i;
    bool b;
    constexpr bool operator&lt;=&gt;(const foo &amp;) const = default;
};

int main() {
    using namespace boost::ut;

    &quot;make_from_tuple&quot;_test = [] {
        expect(foo{42, true} ==
               tip_std::make_from_tuple&lt;foo&gt;(std::tuple{42, true}));
        expect(foo{42, false} !=
               tip_std::make_from_tuple&lt;foo&gt;(std::tuple{42, true}));
        expect(foo{{}, {}} !=
               tip_std::make_from_tuple&lt;foo&gt;(std::tuple{42, true}));
    };

    &quot;forward_as_tuple&quot;_test = [] {
        expect(std::tuple{42, true} == tip_std::forward_as_tuple(42, true));
        expect(type&lt;std::tuple&lt;int &amp;&amp;, bool &amp;&amp;&gt;&gt; ==
               type&lt;decltype(tip_std::forward_as_tuple(42, true))&gt;);

        const int i = 42;
        expect(std::tuple{i, true} == tip_std::forward_as_tuple(i, true));
        expect(type&lt;std::tuple&lt;const int &amp;, bool &amp;&amp;&gt;&gt; ==
               type&lt;decltype(tip_std::forward_as_tuple(i, true))&gt;);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mf4Grez85">https://godbolt.org/z/Mf4Grez85</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace tip_std {
    namespace impl {
        template &lt;class T, size_t... I&gt;
        constexpr auto make_from_tuple(auto &amp;&amp;tuple, std::index_sequence&lt;I...&gt;) {
            return T{std::move(std::get&lt;I&gt;(tuple))...};
        }
    }  // namespace impl
    template &lt;class T&gt;
    constexpr auto make_from_tuple(auto &amp;&amp;tuple) -&gt; T {
        using tuple_base_t = typename std::remove_cvref_t&lt;decltype(tuple)&gt;;
        return impl::make_from_tuple&lt;T&gt;(
            std::forward&lt;decltype(tuple)&gt;(tuple),
            std::make_index_sequence&lt;std::tuple_size_v&lt;tuple_base_t&gt;&gt;{});
    }
    auto forward_as_tuple(auto &amp;&amp;...args) {
        return std::tuple&lt;decltype(args)...&gt;{std::forward&lt;decltype(args)&gt;(args)...};
    }
}  // namespace tip_std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3qrcjd1Yd">https://godbolt.org/z/3qrcjd1Yd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">  namespace tip_std {
       template&lt;typename T, typename... Ts&gt;
       constexpr auto make_from_tuple(std::tuple&lt;Ts...&gt;&amp;&amp; tup) -&gt; T
       {
              return [=]&lt;std::size_t... indexes&gt;(std::index_sequence&lt;indexes...&gt;)
              {
                     return T{std::move(std::get&lt;indexes&gt;(tup))...};
              }(std::make_index_sequence&lt;sizeof...(Ts)&gt;{});
       }

       constexpr auto forward_as_tuple(auto&amp;&amp;... to_tuple)
       {
           return std::tuple&lt;decltype(to_tuple)...&gt;{std::forward&lt;decltype(to_tuple)&gt;(to_tuple)...};
       }
} // namespace tip_std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zfqMs44so">https://godbolt.org/z/zfqMs44so</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace tip_std {
template &lt;class T&gt;
auto make_from_tuple = [](auto t) -&gt; T {
    constexpr static size_t size = std::tuple_size&lt;decltype(t)&gt;::value;
    return [&amp;]&lt;std::size_t... Indices&gt;(std::index_sequence&lt;Indices...&gt;) {
        return T{std::get&lt;Indices&gt;(t)...};
    }(std::make_index_sequence&lt;size&gt;());
};

auto forward_as_tuple = [](auto &amp;&amp;...t) {
    return std::tuple&lt;decltype(t) &amp;&amp;...&gt;(std::forward&lt;decltype(t)&gt;(t)...);
};
}  // namespace tip_std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/95vcns6eq">https://godbolt.org/z/95vcns6eq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace tip_std {

template &lt;typename T, typename Tuple, auto... Is&gt;
T make_from_tuple(Tuple &amp;&amp;tuple, std::index_sequence&lt;Is...&gt;) {
    return T{std::get&lt;Is&gt;(std::forward&lt;Tuple &amp;&amp;&gt;(tuple))...};
}

template &lt;typename T, typename Tuple&gt;
constexpr T make_from_tuple(Tuple &amp;&amp;tuple) {
    return make_from_tuple&lt;T&gt;(
        std::forward&lt;Tuple &amp;&amp;&gt;(tuple),
        std::make_index_sequence&lt;std::tuple_size&lt;Tuple&gt;::value&gt;{});
}

template &lt;typename... Ts&gt;
constexpr std::tuple&lt;Ts &amp;&amp;...&gt; forward_as_tuple(Ts &amp;&amp;...ts) {
    return std::tuple{ts...};
}
}  // namespace tip_std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a5b4s8EWe">https://godbolt.org/z/a5b4s8EWe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace tip_std {
template &lt;class T&gt;
constexpr T make_from_tuple(auto &amp;&amp;t) {
    return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
        return T(get&lt;Is&gt;(t)...);
    }(std::make_index_sequence&lt;
               std::tuple_size_v&lt;std::remove_cvref_t&lt;decltype(t)&gt;&gt;&gt;{});
}

template &lt;class... Ts&gt;
constexpr auto forward_as_tuple(Ts &amp;&amp;...vs) {
    return std::tuple&lt;std::add_rvalue_reference_t&lt;Ts&gt;...&gt;{
        std::forward&lt;Ts&gt;(vs)...};
}
}  // namespace tip_std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zab6MY67v">https://godbolt.org/z/zab6MY67v</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>326 - Did you know that C++23 deprecated std::aligned_storage and std::aligned_union?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/326.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/326.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 deprecated std::aligned_storage and std::aligned_union?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1413">https://wg21.link/P1413</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct container {
    //std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; t_buff; // deprecated
    alignas(T) std::byte t_buff[sizeof(T)]; // okay
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zMjq8s7En">https://godbolt.org/z/zMjq8s7En</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement cointainer which will store aligned union?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">union Union {
    int i;
    double d;
    char c;
};

template &lt;class... Ts&gt;
class container;  // TODO

int main() {
    using namespace boost::ut;

    container&lt;int, double, char&gt; container{};

    &quot;container&quot;_test = [=] {
        mut(container).construct&lt;Union&gt;(Union{.i = 42});
        expect(42_i == container.unsafe_get&lt;int&gt;());
        mut(container).destroy&lt;Union&gt;();
    };

    &quot;container&quot;_test = [=] {
        mut(container).construct&lt;Union&gt;(Union{.d = 77.});
        expect(77._d == container.unsafe_get&lt;double&gt;());
        mut(container).destroy&lt;Union&gt;();
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/doh1o8GrW">https://godbolt.org/z/doh1o8GrW</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
class container {
   public:
    template &lt;class U&gt;
        requires std::is_union_v&lt;U&gt;
    void construct(U&amp;&amp; u) {
        new (buf) U(std::forward&lt;U&gt;(u));
    }

    template &lt;class U&gt;
        requires std::is_union_v&lt;U&gt;
    void destroy() {
        // No-op since C unions can only be used with
        // trivially destructable types that don't need explicit destruction

        // To be safe, we can use the below to zero out the memory
        std::fill(std::begin(buf), std::end(buf), std::byte{});
    }

    template &lt;class T&gt;
    T unsafe_get() const {
        return *reinterpret_cast&lt;const T*&gt;(buf);
    }

   private:
    static constexpr auto largest_elem_size = std::max({sizeof(Ts)...});

   private:
    alignas(Ts...) std::byte buf[largest_elem_size];
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aMd1xWvzP">https://godbolt.org/z/aMd1xWvzP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
union container {};

template &lt;class T, class... Ts&gt;
union container&lt;T, Ts...&gt; {
    T _first;
    container&lt;Ts...&gt; _rest;

    template &lt;class U&gt;
    auto construct(const U &amp;value) {
        *this = std::bit_cast&lt;container&gt;(value);
    }

    template &lt;class U&gt;
    auto unsafe_get() const {
        if constexpr (std::same_as&lt;T, U&gt;) {
            return _first;
        } else {
            return _rest.template unsafe_get&lt;U&gt;();
        }
    }

    template &lt;class U&gt;
    auto destroy() {
        // :P
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MKPznjnTn">https://godbolt.org/z/MKPznjnTn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, std::size_t Align, std::size_t Size&gt;
concept Fits = alignof(T) &lt;= Align and sizeof(T) &lt;= Size;

template &lt;class... Ts&gt;
class container {
    static constexpr auto storage_size = sizeof(std::variant&lt;Ts...&gt;);
    static constexpr auto storage_alignment = alignof(std::variant&lt;Ts...&gt;);
    alignas(storage_alignment) std::byte storage[storage_size];
    std::size_t hash_value{};
    std::function&lt;void(void)&gt; destructor;

   public:
    template &lt;Fits&lt;storage_alignment, storage_size&gt; A, typename... Bs&gt;
    void construct(Bs&amp;&amp;... args) {
        if (hash_value) {
            destructor();
        }
        new (&amp;storage) A{std::forward&lt;Bs&gt;(args)...};
        hash_value = typeid(A).hash_code();
        destructor = [this] {
            reinterpret_cast&lt;A*&gt;(storage)-&gt;~A();
            hash_value = 0;
        };
    }

    template &lt;typename T&gt;
    T const&amp; unsafe_get() const {
        if (hash_value) {
            return reinterpret_cast&lt;T const&amp;&gt;(storage);
        } else {
            throw std::runtime_error(
                &quot;Oh no! You want data but there isn't any available.&quot;);
        }
    }

    template &lt;Fits&lt;storage_alignment, storage_size&gt; A&gt;
    void destroy() {
        if (hash_value == typeid(A).hash_code()) {
            destructor();
            hash_value = 0;
        } else {
            throw std::runtime_error(
                &quot;Yikes!!! You tried to destroy the wrong type!&quot;);
        }
    }

    ~container() {
        if (hash_value) {
            destructor();
        }
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WbfMrKh86">https://godbolt.org/z/WbfMrKh86</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
class container {
    static constexpr auto size = std::max({sizeof(Ts)...});
    alignas(Ts...) std::array&lt;std::byte, size&gt; buffer;

   public:
    template &lt;class T&gt;
    void construct(T&amp;&amp; value) {
        new (buffer.data()) T(std::forward&lt;T&gt;(value));
    }

    template &lt;class T&gt;
    const T unsafe_get() const {
        return *reinterpret_cast&lt;const T*&gt;(buffer.data());
    }

    template &lt;class T&gt;
    void destroy() {
        buffer.fill(std::byte{});
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sr6crEqhn">https://godbolt.org/z/sr6crEqhn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto alignment, auto size&gt;
struct data {
    alignas(alignment) std::byte bytes[size];
};

template &lt;class... Ts&gt;
class container {
    static constexpr std::size_t alignment = std::max({alignof(Ts)...});
    static constexpr std::size_t size = std::max({sizeof(Ts)...});
    data&lt;alignment, size&gt; *d;

   public:
    template &lt;class U&gt;
    void construct(U u) {
        static_assert(sizeof...(Ts) &gt; 0);
        static_assert(std::is_union_v&lt;U&gt;);
        static_assert(std::max({sizeof(Ts)...}) == sizeof(U));
        d = new data&lt;alignment, size&gt;();
        const std::byte *source = reinterpret_cast&lt;std::byte *&gt;(&amp;u);
        std::memcpy(d-&gt;bytes, &amp;u, sizeof(u));
    }

    template &lt;class T&gt;
    T unsafe_get() const {
        static_assert((std::is_same_v&lt;T, Ts&gt; || ...), &quot;The type is not valid.&quot;);
        return *reinterpret_cast&lt;const T *&gt;(&amp;d-&gt;bytes);
    };

    template &lt;class U&gt;
    void destroy() const {
        delete d;
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5G1PocMrv">https://godbolt.org/z/5G1PocMrv</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>325 - Did you know about `typename erasure` technique (via Strong/Opaque Typedefs) in C++?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/325.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/325.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>typename erasure</code> technique (via Strong/Opaque Typedefs) in C++?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/N3515">https://wg21.link/N3515</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class...&gt; struct foo {};
struct strong_typedef : foo&lt;int, double&gt; {};

template &lt;fixed_string Str&gt; struct named_strong_typedef;
template&lt;fixed_string Str, class T&gt; [[nodiscard]] constexpr auto typename_cast(const T&amp; t);

int main() {
  strong_typedef s1{}; // strong typededf

  foo&lt;int, double&gt; f{};
  auto s2 = typename_cast&lt;&quot;foo&quot;&gt;(f); // named strong typedef
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K4s6zhPKW">https://godbolt.org/z/K4s6zhPKW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a generic version of typename cast?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Str&gt;
struct te;  // TODO

template &lt;auto N, class T&gt;
[[nodiscard]] constexpr auto typename_cast(T&amp;&amp;);  // TODO

template &lt;class...&gt;
struct foo {};

template &lt;class... Ts&gt;
constexpr auto fn() {
    foo&lt;Ts...&gt; f{};
    return typename_cast&lt;/*TODO*/ 0&gt;(f);
}

template &lt;class&gt;
constexpr auto is_te_v = false;
template &lt;auto N&gt;
constexpr auto is_te_v&lt;te&lt;N&gt;&gt; = true;

static_assert(std::is_base_of_v&lt;foo&lt;&gt;, decltype(fn())&gt;);
static_assert(is_te_v&lt;decltype(fn())&gt;);
static_assert(not std::is_base_of_v&lt;foo&lt;&gt;, decltype(fn&lt;int&gt;())&gt;);

static_assert(std::is_base_of_v&lt;foo&lt;int&gt;, decltype(fn&lt;int&gt;())&gt;);
static_assert(is_te_v&lt;decltype(fn&lt;int&gt;())&gt;);
static_assert(not std::is_base_of_v&lt;foo&lt;double&gt;, decltype(fn&lt;int&gt;())&gt;);

static_assert(typeid(fn&lt;int&gt;()) == typeid(fn&lt;int&gt;()));
static_assert(typeid(fn&lt;int&gt;()) != typeid(fn&lt;double&gt;()));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fxvKvo9dY">https://godbolt.org/z/fxvKvo9dY</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;int N&gt;
struct types {
    friend auto get(types&lt;N&gt;);
};

template &lt;int N, class T&gt;
struct set_type {
    friend auto get(types&lt;N&gt;) { return T{}; }
    static constexpr auto value = true;
};

template &lt;int N&gt;
struct te : decltype(get(types&lt;N&gt;{})) {};

template &lt;int N, class T&gt;
[[nodiscard]] constexpr auto typename_cast(const T &amp;v) {
    static_assert(set_type&lt;N, T&gt;::value);
    return static_cast&lt;te&lt;N&gt;&gt;(v);
}

template &lt;class...&gt;
struct foo {};

template &lt;class... Ts&gt;
constexpr auto fn() {
    foo&lt;Ts...&gt; f{};
    constexpr std::string_view str = __PRETTY_FUNCTION__;
    constexpr auto hash =
        std::accumulate(str.begin(), str.end(), 0,
                        [](auto acc, auto c) { return (acc &lt;&lt; CHAR_BIT) ^ c; });
    return typename_cast&lt;hash&gt;(f);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/arz7ehjde">https://godbolt.org/z/arz7ehjde</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Key&gt;
struct Type_name {
    friend auto lookup(Type_name);

    template &lt;typename T&gt;
    struct Store {
        friend auto lookup(Type_name) { return T{}; }
    };
};

template &lt;auto Key&gt;
struct Erased : decltype(lookup(Type_name&lt;Key&gt;())) {};

template &lt;auto Key, class T&gt;
[[nodiscard]] constexpr auto typename_cast(T&amp;&amp; x) {
    void(typename Type_name&lt;Key&gt;::template Store&lt;std::remove_cvref_t&lt;T&gt;&gt;{});
    return static_cast&lt;Erased&lt;Key&gt;&gt;(x);
}

template &lt;class...&gt;
struct foo {};

template &lt;typename... Ts&gt;
constexpr std::size_t key() {
    std::size_t result{};
    for (auto c : __PRETTY_FUNCTION__) (result ^= c) &lt;&lt;= 1;
    return result;
}

static_assert(key&lt;int&gt;() != key&lt;double&gt;());

template &lt;class... Ts&gt;
constexpr auto fn() {
    foo&lt;Ts...&gt; f{};
    return typename_cast&lt;key&lt;Ts...&gt;()&gt;(f);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M5qsvqsxn">https://godbolt.org/z/M5qsvqsxn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Str&gt;
struct types final {
    friend auto get(types);
    template &lt;class T&gt;
    struct set {
        friend auto get(types) { return T{}; }
    };
};

template &lt;auto Str&gt;
struct te : decltype(get(types&lt;Str&gt;{})) {};

template &lt;class T, auto N&gt;
[[nodiscard]] constexpr auto typename_cast(T&amp;&amp; t) {
    void(typename types&lt;N&gt;::template set&lt;T&gt;{});
    return static_cast&lt;te&lt;N&gt;&gt;(std::forward&lt;T&gt;(t));
}

template &lt;class...&gt;
struct foo {};

template &lt;class... Ts&gt;
constexpr auto fn() {
    foo&lt;Ts...&gt; f{};
    return typename_cast&lt;decltype(f), (sizeof(Ts) + ... + 0)&gt;(std::move(f));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bnforGcf1">https://godbolt.org/z/bnforGcf1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
constexpr size_t comptime_typeid() {
    constexpr std::string_view func_name = __PRETTY_FUNCTION__;
    // djb2 string hashing
    size_t hash = 5381;
    for (char c : func_name) {
        hash = ((hash &lt;&lt; 5) + hash) + c;
    }
    return hash;
}

template &lt;size_t N&gt;
struct types final {
    friend auto get(types&lt;N&gt;);

    template &lt;class T&gt;
    struct set {
        friend auto get(types&lt;N&gt;) { return T{}; }
    };
};

template &lt;size_t N&gt;
struct te : decltype(get(types&lt;N&gt;{})) {};

template &lt;size_t N, class T&gt;
[[nodiscard]] constexpr auto typename_cast(T&amp;&amp; t) {
    void(typename types&lt;N&gt;::template set&lt;T&gt;{});
    return static_cast&lt;te&lt;N&gt;&gt;(t);
}

template &lt;class...&gt;
struct foo {};

template &lt;class... Ts&gt;
constexpr auto fn() {
    foo&lt;Ts...&gt; f{};
    constexpr auto id = comptime_typeid&lt;decltype(f)&gt;();
    return typename_cast&lt;id&gt;(std::move(f));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PsW8GKoT5">https://godbolt.org/z/PsW8GKoT5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>324 - Did you know about `virtual` inheritance in C++?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/324.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/324.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>virtual</code> inheritance in C++?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/class.mi#def:base_class,virtual">https://eel.is/c++draft/class.mi#def:base_class,virtual</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct A {
    int a{};
};
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {};

int main() {
    D d{};
    d.a = {};  // without virtual -&gt; request for member 'a' is ambiguous
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qG46qW7TG">https://godbolt.org/z/qG46qW7TG</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct interface;  // TODO

template &lt;auto... Vs&gt;
struct implementation final;  // TODO

#include &lt;[https://raw.githubusercontent.com/boost-ext/ut/v1.1.9/include/boost/ut.hpp](https://raw.githubusercontent.com/boost-ext/ut/v1.1.9/include/boost/ut.hpp)&gt;

int main() {
    using namespace boost::ut;

    &quot;virtual type_list interface empty&quot;_test = [] {
        auto impl = implementation&lt;&gt;{};
        const interface&lt;&gt;&amp; i = impl;
    };

    &quot;virtual type_list interface single&quot;_test = [] {
        auto impl = implementation&lt;int{42}&gt;{};
        const interface&lt;int&gt;&amp; i = impl;
        expect(42 == i.on(int{}));
    };

    &quot;virtual type_list interface multi&quot;_test = [] {
        auto impl = implementation&lt;int{4}, double{2.}, float{42.f}&gt;{};
        const interface&lt;int, double, float&gt;&amp; i = impl;
        expect(4 == i.on(int{}));
        expect(2. == i.on(double{}));
        expect(42.f == i.on(float{}));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qs4K917ac">https://godbolt.org/z/qs4K917ac</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct interface {
   public:
    template &lt;class T&gt;
    const T&amp; on(T) const {
        return std::get&lt;T&gt;(vs);
    }

   protected:
    constexpr explicit interface(auto&amp;&amp;... args) : vs(args...) {}

   private:
    std::tuple&lt;Ts...&gt; vs;
};

template &lt;auto... Vs&gt;
struct implementation final : interface&lt;decltype(Vs)...&gt; {
    constexpr explicit implementation() : interface&lt;decltype(Vs)...&gt;(Vs...) {}
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/csrTfEcnP">https://godbolt.org/z/csrTfEcnP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct interface : virtual interface&lt;Ts&gt;... {
    using interface&lt;Ts&gt;::on...;
};

template &lt;class T&gt;
struct interface&lt;T&gt; {
    virtual T on(T) const = 0;
    virtual ~interface() noexcept = default;
};

template &lt;auto... Vs&gt;
struct implementation : interface&lt;decltype(Vs)...&gt;, implementation&lt;Vs&gt;... {};

template &lt;auto V&gt;
struct implementation&lt;V&gt; : virtual interface&lt;decltype(V)&gt; {
    using T = decltype(V);
    T on(T) const { return V; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vo18fjTja">https://godbolt.org/z/vo18fjTja</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct interface : virtual interface&lt;Ts&gt;... {
    using interface&lt;Ts&gt;::on...;
};

template &lt;class T&gt;
struct interface&lt;T&gt; {
    virtual T on(T) const = 0;
};

template &lt;auto... Vs&gt;
struct implementation final : implementation&lt;Vs&gt;...,
                              interface&lt;decltype(Vs)...&gt; {};

template &lt;auto V&gt;
struct implementation&lt;V&gt; : virtual interface&lt;decltype(V)&gt; {
    using T = decltype(V);
    T on(T) const override { return V; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bfxPc3KE8">https://godbolt.org/z/bfxPc3KE8</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>323 - Did you know that constexpr is strict about undefined behaviour (UB), object lifetime, etc?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/323.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/323.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that constexpr is strict about undefined behaviour (UB), object lifetime, etc?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/expr.const#4">https://eel.is/c++draft/expr.const#4</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto make() { return new bool; }
static_assert(*make());  // static assertion expression is not an integral
                         // constant expression
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Eah48orzK">https://godbolt.org/z/Eah48orzK</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you fix the following snippets?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto new_1() { return new int; }
static_assert(*new_1());

constexpr auto new_2() { return new int{}; }
static_assert(*new_2());

constexpr auto l_1() {
    auto capture = 0;
    return [&amp;] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto&amp; { return b; };
static_assert(ll(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto&amp; { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3};
    return v[i];
}
static_assert(v_1(3));

constexpr auto o_1 = [](auto x) { return x + 1; };
static_assert(o_2(std::numeric_limits&lt;int&gt;::max()));

constexpr auto m_1() {
    std::string str{};
    std::vector&lt;std::string&gt; messages;
    messages.emplace_back(std::move(str));
    return str;
}
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E3jcPMr7T">https://godbolt.org/z/E3jcPMr7T</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto new_1() {
    static constexpr auto one = 1;
    return &amp;one;
}
static_assert(*new_1());

constexpr auto new_2() {
    static constexpr auto two = 2;
    return &amp;two;
}
static_assert(*new_2());

constexpr auto l_1() {
    auto capture = 0;
    return [=] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto { return b; };
static_assert(l_2(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3, 4};
    return v[i];
}
static_assert(v_1(3));

constexpr auto o_1 = [](auto x) { return -x - 1; };
static_assert(o_1(std::numeric_limits&lt;int&gt;::max()));

constexpr auto m_1() { return std::string{}; }
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f3GjWeYjj">https://godbolt.org/z/f3GjWeYjj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto new_1() {
    static constexpr int p = 1;
    return &amp;p;
}
static_assert(*new_1());

constexpr auto new_2() {
    static constexpr int p = 2;
    return &amp;p;
}
static_assert(*new_2());

constexpr auto l_1() {
    auto capture = 0;
    return [=] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto { return b; };
static_assert(l_2(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3, 4};
    return v[i];
}
static_assert(v_1(3));

constexpr auto o_1 = [](auto x) { return -x + 1; };
static_assert(o_1(std::numeric_limits&lt;int&gt;::max()));

constexpr auto m_1() {
    std::vector&lt;std::string&gt; messages{&quot;&quot;};
    return messages[0];
}
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xM6crdM4b">https://godbolt.org/z/xM6crdM4b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct constexpr_new {
    constexpr constexpr_new(T value) { this-&gt;value = new T{value}; };
    constexpr ~constexpr_new() { delete this-&gt;value; }
    constexpr T operator*() { return *(this-&gt;value); }

   private:
    T* value;
};

constexpr auto new_1() { return constexpr_new&lt;int&gt;{1}; }
static_assert(*new_1());

constexpr auto new_2() { return constexpr_new&lt;int&gt;{2}; }
static_assert(*new_2());

constexpr auto l_1() {
    auto capture = 0;
    return [capture] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto { return b; };
static_assert(l_2(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3};
    if (i &lt; v.size()) {
        return v[i];
    }
    return -1;
}
static_assert(v_1(3));

constexpr auto o_1 = [](auto x) {
    return x == std::numeric_limits&lt;int&gt;::max() ? -1 : x + 1;
};
static_assert(o_1(std::numeric_limits&lt;int&gt;::max()));

constexpr auto m_1() {
    std::string str{};
    std::vector&lt;std::string&gt; messages{str};
    return std::string{messages.back()};
}
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ab16xPsvs">https://godbolt.org/z/ab16xPsvs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto new_1() {
    static constexpr int x{};
    return &amp;x;
}
static_assert(*new_1() == 0);

constexpr auto new_2() {
    static constexpr int x{1};
    return &amp;x;
}
static_assert(*new_2() == 1);

constexpr auto l_1() {
    constexpr auto capture = 0;
    return [&amp;] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto { return b; };
static_assert(l_2(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3};
    return v[i];
}
static_assert(v_1(2));

constexpr auto o_1 = [](auto x) { return x + 1; };
static_assert(o_1(std::numeric_limits&lt;int&gt;::max() - 1));

constexpr auto m_1() {
    std::string_view s{&quot;&quot;};
    std::vector&lt;std::string_view&gt; messages{s};
    messages.emplace_back(std::move(s));
    return s;
}
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/711MEP8oz">https://godbolt.org/z/711MEP8oz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto new_1() {
    static constexpr int x{1};
    return &amp;x;
}
static_assert(*new_1());

constexpr auto new_2() {
    static constexpr int x{2};
    return &amp;x;
}
static_assert(*new_2());

constexpr auto l_1() {
    auto capture = 0;
    return [=] { return capture == 0; };
};
static_assert(l_1()());

constexpr auto l_2 = [](auto b) -&gt; auto { return b; };
static_assert(l_2(true));

constexpr auto l_3 = [](auto&amp;&amp; b) -&gt; auto { return b; };
static_assert(l_3(true));

constexpr auto v_1(auto i) {
    std::vector v{1, 2, 3};
    return (i &lt; v.size()) ? v[i] : -1;
}
static_assert(v_1(3));

constexpr auto o_1 = [](auto x) {
    decltype(x) result;
    if (__builtin_add_overflow(x, 1, &amp;result)) {
        return x;
    } else {
        return result;
    }
};
static_assert(o_1(std::numeric_limits&lt;int&gt;::max()));

constexpr auto m_1() {
    std::string_view sv{};
    std::vector&lt;std::string_view&gt; messages{std::move(sv)};
    return sv;
}
static_assert(m_1() == &quot;&quot;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/67v9eMYGd">https://godbolt.org/z/67v9eMYGd</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>322 - Did you know that C++23 added Monadic operations for std::expected?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/322.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/322.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added Monadic operations for std::expected?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2505">https://wg21.link/P2505</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">enum class error { runtime_error };

[[nodiscard]] auto foo() -&gt; std::expected&lt;int, error&gt; {
    return std::unexpected(error::runtime_error);
}

int main() {
    const auto e = foo();
    e.and_then([](const auto&amp; e) -&gt; std::expected&lt;int, error&gt; {
         std::cout &lt;&lt; int(e);  // not printed
         return {};
     }).or_else([](const auto&amp; e) -&gt; std::expected&lt;int, error&gt; {
        std::cout &lt;&lt; int(e);  // prints 0
        return {};
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MeoP5r3xP">https://godbolt.org/z/MeoP5r3xP</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you refactor execute routine with Monadic std::expected operations?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">enum class error {
    trade,
    model,
    order_id,
};

struct market_data {};
struct trade {};
struct order {};
struct order_with_id {};

std::expected&lt;order_with_id, error&gt; execute(auto&amp; ts, const market_data&amp; md) {
    auto trade = ts.parse(md);
    if (not trade) {
        return std::unexpected(error::trade);
    }

    auto order = ts.model(*trade);
    if (not order) {
        return std::unexpected(error::model);
    }

    if (auto order_with_id = ts.map(*order); order_with_id) {
        return *order_with_id;
    } else {
        return std::unexpected(error::order_id);
    }
}

int main() {
    using namespace boost::ut;

    should(&quot;error on empty trade&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; {
                return {};
            }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; {
                return {{}};
            }
        } fake_ts;

        const auto e = execute(fake_ts, {});
        expect(not e and error::trade == e.error());
    };

    should(&quot;error on empty model&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; {
                return {{}};
            }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; {
                return {{}};
            }
        } fake_ts;

        const auto e = execute(fake_ts, {});
        expect(not e and error::model == e.error());
    };

    should(&quot;error on order_id&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; {
                return {{}};
            }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; {
                return {};
            }
        } fake_ts;

        const auto e = execute(fake_ts, {});
        expect(not e and error::order_id == e.error());
    };

    should(&quot;produce an order&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; {
                return {{}};
            }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; {
                return {{}};
            }
        } fake_ts;

        expect(execute(fake_ts, {}).has_value());
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1esfP8KjE">https://godbolt.org/z/1esfP8KjE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">std::expected&lt;order_with_id, error&gt; execute(auto &amp;ts, const market_data &amp;md) {
    constexpr auto expected_or = []&lt;class T&gt;(const std::optional&lt;T&gt; &amp;e,
                                             error u) {
        return e ? std::expected&lt;T, error&gt;(*e) : std::unexpected(u);
    };
    return expected_or(ts.parse(md), error::trade)
        .and_then([&amp;](const auto &amp;trade) {
            return expected_or(ts.model(trade), error::model);
        })
        .and_then([&amp;](const auto &amp;order) {
            return expected_or(ts.map(order), error::order_id);
        });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qh8W3oa4v">https://godbolt.org/z/qh8W3oa4v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">std::expected&lt;order_with_id, error&gt; execute(auto&amp; ts, const market_data&amp; md) {
    auto as_expected = []&lt;typename T&gt;(const std::optional&lt;T&gt;&amp; o,
                                      error e) -&gt; std::expected&lt;T, error&gt; {
        return o ? std::expected&lt;T, error&gt;(*o) : std::unexpected(e);
    };

    return as_expected(ts.parse(md), error::trade)
        .and_then([&amp;](const auto&amp; trade) {
            return as_expected(ts.model(trade), error::model);
        })
        .and_then([&amp;](const auto&amp; order) {
            return as_expected(ts.map(order), error::order_id);
        });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eM3sdr9Ef">https://godbolt.org/z/eM3sdr9Ef</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
constexpr std::expected&lt;T, error&gt; to_expected(std::optional&lt;T&gt; t, error e) {
    if (t) {
        return *t;
    } else {
        return std::unexpected(e);
    }
};

std::expected&lt;order_with_id, error&gt; execute(auto&amp; ts, const market_data&amp; md) {
    return to_expected(ts.parse(md), error::trade)
        .and_then([&amp;](const auto&amp; trade) {
            return to_expected(ts.model(trade), error::model);
        })
        .and_then([&amp;](const auto&amp; order) {
            return to_expected(ts.map(order), error::order_id);
        });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d4MTsrbP1">https://godbolt.org/z/d4MTsrbP1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">std::expected&lt;order_with_id, error&gt; execute(auto&amp; ts, const market_data&amp; md) {
    auto to_expected = []&lt;typename T&gt;(std::optional&lt;T&gt; o,
                                      error e) -&gt; std::expected&lt;T, error&gt; {
        return o.has_value() ? std::expected&lt;T, error&gt;{*o} : std::unexpected{e};
    };
    return to_expected(ts.parse(md), error::trade)
        .and_then(
            [&amp;](auto v) { return to_expected(ts.model(v), error::model); })
        .and_then(
            [&amp;](auto v) { return to_expected(ts.map(v), error::order_id); });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EMfx36G4K">https://godbolt.org/z/EMfx36G4K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
constexpr std::expected&lt;T, error&gt; optional_to_expected(
    const std::optional&lt;T&gt;&amp;&amp; o, const error e) {
    return o.has_value() ? std::expected&lt;T, error&gt;(o.value())
                         : std::unexpected(e);
}

std::expected&lt;order_with_id, error&gt; execute(auto&amp; ts, const market_data&amp; md) {
    return optional_to_expected(ts.parse(md), error::trade)
        .and_then([&amp;](const auto&amp; trade) {
            return optional_to_expected(ts.model(trade), error::model);
        })
        .and_then([&amp;](const auto&amp; order) {
            return optional_to_expected(ts.map(order), error::order_id);
        });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YMM4qeW78">https://godbolt.org/z/YMM4qeW78</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>321 - Did you know that C++23 added support for formatting ranges?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/321.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/321.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added support for formatting ranges?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2286">https://wg21.link/P2286</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::cout &lt;&lt; std::format(&quot;{}&quot;,   std::vector{1, 2, 3}); // [1, 2, 3]
  std::cout &lt;&lt; std::format(&quot;{:n}&quot;, std::vector{1, 2, 3}); // 1, 2, 3
  std::cout &lt;&lt; std::format(&quot;{}&quot;,   std::tuple{'1', 2., 3}); // ('1', 2, 3)
  std::cout &lt;&lt; std::format(&quot;{}&quot;,   std::vector{std::pair{'a',1}, std::pair{'b',2}}); // [(a, 1), (b, 2)]
  std::cout &lt;&lt; std::format(&quot;{:m}&quot;, std::vector{std::pair{'a',1}, std::pair{'b',2}}); // {(a, 1), (b, 2)}
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4P4ev9r6Y">https://godbolt.org/z/4P4ev9r6Y</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you add required format strings to satisfy the formatted output?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
  using namespace boost::ut;
  using namespace std::literals::string_literals;

  expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;TODO&quot;, std::tuple{&quot;hello&quot;, 42}));
  expect(&quot;[0x1, 0x2, 0x3]&quot;s  == std::format(&quot;TODO&quot;, std::vector{1, 2, 3}));
  expect(&quot;[*1*, *2*, *3*]&quot;s  == std::format(&quot;TODO&quot;, std::vector{1, 2, 3}));
  expect(&quot;Q L&quot;s              == std::format(&quot;TODO&quot;, std::string{'Q', ' ', 'L'}));
  expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s   == std::format(&quot;TODO&quot;, std::vector{std::vector{'a'}, std::vector{'b','c'}}));
  expect(&quot;[[97], [98, 99]]&quot;s == std::format(&quot;TODO&quot;, std::vector{std::vector{'a'}, std::vector{'b','c'}}));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/66c7Mecx3">https://godbolt.org/z/66c7Mecx3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;{}&quot;, std::tuple{&quot;hello&quot;, 42}));
expect(&quot;[0x1, 0x2, 0x3]&quot;s == std::format(&quot;{::#x}&quot;, std::vector{1, 2, 3}));
expect(&quot;[*1*, *2*, *3*]&quot;s == std::format(&quot;{::*^3}&quot;, std::vector{1, 2, 3}));
expect(&quot;Q L&quot;s == std::format(&quot;{}&quot;, std::string{'Q', ' ', 'L'}));
expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s == std::format(&quot;{::?s}&quot;, std::vector{std::vector{'a'}, std::vector{'b','c'}}));
expect(&quot;[[97], [98, 99]]&quot;s == std::format(&quot;{:::d}&quot;, std::vector{std::vector{'a'}, std::vector{'b','c'}}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cKcq39qWc">https://godbolt.org/z/cKcq39qWc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;{}&quot;, std::tuple{&quot;hello&quot;, 42}));
expect(&quot;[0x1, 0x2, 0x3]&quot;s == std::format(&quot;{::#x}&quot;, std::vector{1, 2, 3}));
expect(&quot;[*1*, *2*, *3*]&quot;s == std::format(&quot;{::*^3}&quot;, std::vector{1, 2, 3}));
expect(&quot;Q L&quot;s == std::format(&quot;{:s}&quot;, std::string{'Q', ' ', 'L'}));
expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s ==
       std::format(&quot;{::?s}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
expect(&quot;[[97], [98, 99]]&quot;s ==
       std::format(&quot;{:::d}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sbGvrTxMa">https://godbolt.org/z/sbGvrTxMa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;{}&quot;, std::tuple{&quot;hello&quot;, 42}));
expect(&quot;[0x1, 0x2, 0x3]&quot;s == std::format(&quot;{::#x}&quot;, std::vector{1, 2, 3}));
expect(&quot;[*1*, *2*, *3*]&quot;s == std::format(&quot;{::*^3}&quot;, std::vector{1, 2, 3}));
expect(&quot;Q L&quot;s == std::format(&quot;{}&quot;, std::string{'Q', ' ', 'L'}));
expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s ==
       std::format(&quot;{::?s}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
expect(&quot;[[97], [98, 99]]&quot;s ==
       std::format(&quot;{:::d}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4Mhs1KzMs">https://godbolt.org/z/4Mhs1KzMs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;{}&quot;, std::tuple{&quot;hello&quot;, 42}));
expect(&quot;[0x1, 0x2, 0x3]&quot;s == std::format(&quot;{::#x}&quot;, std::vector{1, 2, 3}));
expect(&quot;[*1*, *2*, *3*]&quot;s == std::format(&quot;{::*^3}&quot;, std::vector{1, 2, 3}));
expect(&quot;Q L&quot;s == std::format(&quot;{:'^3}&quot;, std::string{'Q', ' ', 'L'}));
expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s ==
       std::format(&quot;{::?s}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
expect(&quot;[[97], [98, 99]]&quot;s ==
       std::format(&quot;{:::d}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v9GqWM5s5">https://godbolt.org/z/v9GqWM5s5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">expect(R&quot;((&quot;hello&quot;, 42))&quot;s == std::format(&quot;{}&quot;, std::tuple{&quot;hello&quot;, 42}));
expect(&quot;[0x1, 0x2, 0x3]&quot;s == std::format(&quot;{::#x}&quot;, std::vector{1, 2, 3}));
expect(&quot;[*1*, *2*, *3*]&quot;s == std::format(&quot;{::*^3}&quot;, std::vector{1, 2, 3}));
expect(&quot;Q L&quot;s == std::format(&quot;{}&quot;, std::string{'Q', ' ', 'L'}));
expect(R&quot;([&quot;a&quot;, &quot;bc&quot;])&quot;s ==
       std::format(&quot;{::?s}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
expect(&quot;[[97], [98, 99]]&quot;s ==
       std::format(&quot;{:::d}&quot;,
                   std::vector{std::vector{'a'}, std::vector{'b', 'c'}}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6jbqTMG15">https://godbolt.org/z/6jbqTMG15</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>320 - Did you know about intrisincts to support SIMD (Single Instruction, Multiple Data) instructions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/320.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/320.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about intrisincts to support SIMD (Single Instruction, Multiple Data) instructions?</strong></p>
</li>
<li>
<p><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;immintrin.h&gt;

int main() {
    const std::vector a = {1, 2, 3, 4};
    const std::vector b = {5, 6, 7, 8};

    const auto va = _mm_loadu_si128((__m128i*)a.data());
    const auto vb = _mm_loadu_si128((__m128i*)b.data());
    const auto result = _mm_add_epi32(va, vb);

    std::vector&lt;int&gt; v(a.size());
    _mm_storeu_si128((__m128i*)v.data(), result);

    assert((std::vector{1 + 5, 2 + 6, 3 + 7, 4 + 8} == v));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nz1hx76j7">https://godbolt.org/z/nz1hx76j7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implement a function which computes the dot product of the two arrays using SIMD instructions?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto dot_product(const auto&amp; lhs, const auto&amp; rhs); // TODO

int main() {
    using namespace boost::ut;

    &quot;simd.dot_product empty&quot;_test = [] {
        const std::vector&lt;float&gt; a{};
        const std::vector&lt;float&gt; b{};

        expect(0_i == dot_product(a, b));
    };

    &quot;simd.dot_product one&quot;_test = [] {
        const std::vector a = {1.f};
        const std::vector b = {3.f};

        expect(_i(1*3) == dot_product(a, b));
    };

    &quot;simd.dot_product many&quot;_test = [] {
        const std::vector a = {1.f, 2.f, 3.f, 4.f};
        const std::vector b = {5.f, 6.f, 7.f, 8.f};

        expect(_i(1*5+2*6+3*7+4*8) == dot_product(a, b));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GnrEh1YM9">https://godbolt.org/z/GnrEh1YM9</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace impl{
    template&lt;typename T&gt;
    struct simd{
        static constexpr auto dot_product(const T&amp; lhs, const T&amp; rhs) -&gt; void
        {
            static_assert(false);
        }
    };
    template&lt;&gt;
    struct simd&lt;std::vector&lt;float&gt;&gt;{
        [[nodiscard]] static constexpr auto dot_product(const std::vector&lt;float&gt;&amp; lhs, const std::vector&lt;float&gt;&amp; rhs) -&gt; float
        {
            std::array&lt;float, 4&gt; out = {0.0f, 0.0f, 0.0f, 0.0f};\
            auto vc = _mm_loadu_ps(out.data());
            for (auto i = 0uz; i &lt; std::size(lhs); i += 4)
            {
                const auto va = _mm_loadu_ps(lhs.data() + i);
                const auto vb = _mm_loadu_ps(rhs.data() + i);
                vc = _mm_fmadd_ps(va, vb, vc);
            }
            _mm_store_ps(out.data(), vc);
            return out.at(0) + out.at(1) + out.at(2) + out.at(3);
        }
    };
}

[[nodiscard]] constexpr auto dot_product(const auto&amp; lhs, const auto&amp; rhs)
{
    return impl::simd&lt;std::remove_cvref_t&lt;decltype(lhs)&gt;&gt;::dot_product(lhs, rhs);
}
</code></pre>

<pre class="codehilite"><code class="language-cpp">static inline float _mm_reduce_add_ps(__m128 x128) {
    const __m128 x64 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
    const __m128 x32 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
    return _mm_cvtss_f32(x32);
}

[[nodiscard]] constexpr auto dot_product(const auto&amp; lhs, const auto&amp; rhs) {
    auto lhs_vector = _mm_load_ps(lhs.data());
    auto rhs_vector = _mm_load_ps(rhs.data());
    auto output = _mm_fmadd_ps(lhs_vector, rhs_vector, _mm_setzero_ps());
    return _mm_reduce_add_ps(output);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G8Gjjqhbb">https://godbolt.org/z/G8Gjjqhbb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto dot_product(const auto&amp; lhs, const auto&amp; rhs) {
    const __m128 vlhs = _mm_load_ps(lhs.data());
    const __m128 vrhs = _mm_load_ps(rhs.data());
    const __m128 mul = _mm_mul_ps( vlhs, vrhs );
    const __m128 r2 = _mm_add_ps( mul, _mm_movehl_ps( mul, mul ) );
    const __m128 r1 = _mm_add_ss( r2, _mm_movehdup_ps( r2 ) );
    return _mm_cvtss_f32( r1 );
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1EPv1bdfe">https://godbolt.org/z/1EPv1bdfe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto dot_product(const auto&amp; lhs, const auto&amp; rhs){
    const auto va = _mm256_load_ps(lhs.data());
    const auto vb = _mm256_load_ps(rhs.data());
    const auto result = _mm256_dp_ps(va,vb,0xFF);
    return (float)result[0];
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hhYeP4n5P">https://godbolt.org/z/hhYeP4n5P</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>319 - Did you know that C++11 allows calling functions with reference-to-array parameters from an initializer list?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/319.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/319.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++11 allows calling functions with reference-to-array parameters from an initializer list?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/dcl.init.aggr">https://eel.is/c++draft/dcl.init.aggr</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">consteval auto foo(const auto (&amp;value)[1]) { return value[0]; }
static_assert(42 == foo({42}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hnPM17fK7">https://godbolt.org/z/hnPM17fK7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implement sum_n which sums given list of parameters?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// TODO sum_n

static_assert(1==sum_n({1}));
static_assert(1+2==sum_n({1}, {2}));
static_assert(1+2+3+4==sum_n({1, 2}, {3, 4}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YPfExbzjz">https://godbolt.org/z/YPfExbzjz</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">consteval auto sum_n(const auto ...x)
{
    return (x + ...);
}

consteval auto sum_n(const auto (&amp;... x)[1])
{
    return sum_n(x[0]...);
}

consteval auto sum_n(const auto (&amp;... x)[2])
{
    return sum_n(x[1]...) + sum_n(x[0]...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1fxxz6KEv">https://godbolt.org/z/1fxxz6KEv</a></p>
</blockquote>
<pre class="codehilite"><code>template &lt;typename... Ts, int... Ns&gt;
consteval auto sum_n(const Ts (&amp;...x)[Ns]) {
    return (... + std::ranges::fold_left(x, Ts{}, std::plus{}));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bKdz3EEr1">https://godbolt.org/z/bKdz3EEr1</a></p>
</blockquote>
<pre class="codehilite"><code>template &lt;auto... Ns&gt;
constexpr auto sum_n(auto (&amp;&amp;...values)[Ns]) {
  auto sum = 0;
  return ([&amp;] {
    for (auto value : values) {
      sum += value;
    }
  }(), ..., sum);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x7jn47Geb">https://godbolt.org/z/x7jn47Geb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
consteval auto sum_n(const auto  (&amp;...array)[N]) {
    auto result = (std::accumulate(array, array + N, 0) + ...);
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rGG7KM7qa">https://godbolt.org/z/rGG7KM7qa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Lists, int ...N&gt;
consteval auto sum_n(const Lists (&amp;...v)[N]) {
    return (std::accumulate(v, v+N, 0) + ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9hYTe14ds">https://godbolt.org/z/9hYTe14ds</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>318 - Did you know that `std::unique_ptr` can be constexpr in C++23?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/318.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/318.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>std::unique_ptr</code> can be constexpr in C++23?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2273">https://wg21.link/P2273</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct interface {
    constexpr virtual ~interface() = default;
    constexpr virtual auto get() const -&gt; int = 0;
};

struct implementation final : interface {
    constexpr explicit(true) implementation(int value) : value{value} {}
    constexpr auto get() const -&gt; int { return value; }

private:
    int value{};
};

constexpr auto foo(auto value) {
    std::unique_ptr&lt;interface&gt; i = std::make_unique&lt;implementation&gt;(value);
    return i-&gt;get();
}

static_assert(42 == foo(42));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vW9n4EzM8">https://godbolt.org/z/vW9n4EzM8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implement constexpr <code>std::function</code>?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// TODO: function

consteval auto test_empty() {
  function f = [] { return 42; };
  return f();
}

consteval auto test_arg() {
  function f = [](int i) { return i; };
  return f(42);
}

consteval auto test_capture() {
  int i = 42;
  function f = [&amp;] { return i; };
  return f();
}

static_assert(42 == test_empty());
static_assert(42 == test_arg());
static_assert(42 == test_capture());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e8h1rv3Ee">https://godbolt.org/z/e8h1rv3Ee</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
template<typename F><br />
struct function {<br />
    consteval function(F&amp;&amp; f) : f_{std::forward<F>(f)} {}<br />
    template<typename ...Args><br />
    consteval auto operator()(Args&amp;&amp;... args) requires std::invocable<F, Args...><br />
    {<br />
        return f_(std::forward<Args>(args)...);<br />
    }</p>
<pre class="codehilite"><code>F f_;
</code></pre>

<p>};</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/4hjx5aYfP](https://godbolt.org/z/4hjx5aYfP)
</code></pre>

<p>template <class><br />
class function;</p>
<p>template <class R, class... TArgs><br />
class function<R(TArgs...)> {<br />
  struct interface {<br />
    constexpr virtual auto operator()(TArgs...) -&gt; R = 0;<br />
    constexpr virtual ~interface() = default;<br />
  };</p>
<p>template <class Fn><br />
  struct implementation final : interface {<br />
    constexpr explicit(true) implementation(Fn fn) : fn{fn} {}<br />
    constexpr auto operator()(TArgs... args) -&gt; R { return fn(args...); }</p>
<p>private:<br />
    Fn fn{};<br />
  };</p>
<p>public:<br />
  template <class Fn><br />
  constexpr function(Fn fn) : fn{std::make_unique<implementation\<Fn>>(fn)} {}</p>
<p>constexpr auto operator()(TArgs... args) const -&gt; R {<br />
    return (*fn)(args...);<br />
  }</p>
<p>private:<br />
  std::unique_ptr<interface> fn{};<br />
};</p>
<p>template <class> struct function_traits {};</p>
<p>template <class R, class B, class... TArgs><br />
struct function_traits<R (B::*)(TArgs...) const> {<br />
  using type = R(TArgs...);<br />
};</p>
<p>template <class F><br />
function(F) -&gt; function<typename function_traits\<decltype(&F::operator())>::type>;</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/s3bPhha7h](https://godbolt.org/z/s3bPhha7h)

```cpp
template &lt;class&gt;
class function;

template &lt;class R, class... Args&gt;
struct function&lt;R(Args...)&gt; {
  template &lt;class F&gt;
  constexpr function(F f) : ptr{std::make_unique&lt;implementation&lt;F&gt;&gt;(f)} {}

  constexpr auto operator()(Args... args) const -&gt; R {
    return ptr-&gt;get(args...);
  }

 private:
  struct interface {
    constexpr virtual auto get(Args...) -&gt; R = 0;
    constexpr virtual ~interface() = default;
  };

  template &lt;class F&gt;
  struct implementation final : interface {
    constexpr explicit(true) implementation(F f) : f{f} {}
    constexpr auto get(Args... args) -&gt; R { return f(args...); }

   private:
    F f;
  };

  std::unique_ptr&lt;interface&gt; ptr;
};

// [https://en.cppreference.com/w/cpp/utility/functional/function/deduction_guides](https://en.cppreference.com/w/cpp/utility/functional/function/deduction_guides)

template &lt;class&gt;
struct function_traits {};

template &lt;class R, class G, class... A&gt;
struct function_traits&lt;R (G::*)(A...) const&gt; {
  using function_type = R(A...);
};

template &lt;class F&gt;
using function_type_t = typename function_traits&lt;F&gt;::function_type;

// This overload participates in overload resolution only if &amp;F::operator() is
// well-formed when treated as an unevaluated operand and
// decltype(&amp;F::operator()) is of the form R(G::*)(A...) (optionally
// cv-qualified, optionally noexcept, optionally lvalue reference qualified).
// The deduced type is std::function&lt;R(A...)&gt;.
template &lt;class F&gt;
function(F) -&gt; function&lt;function_type_t&lt;decltype(&amp;F::operator())&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4KhzajrKE">https://godbolt.org/z/4KhzajrKE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>317 - Did you know that with C++20 you can pass concepts?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/317.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/317.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that with C++20 you can pass concepts?</strong></p>
</li>
<li>
<p>Although <code>template&lt;template&lt;class...&gt; concept C&gt;</code> is not valid</p>
</li>
<li><a href="https://eel.is/c++draft/#concepts">https://eel.is/c++draft/#concepts</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
concept foo_like = requires(T t) { t.foo; };

template&lt;auto Concept&gt;
struct foo {
  auto fn(auto f) {
    static_assert(requires { Concept(f); });
  }
};

int main() {
  foo&lt;[](foo_like auto){}&gt; f{};

  struct { int foo{}; } foo;
  struct { } bar;

  f.fn(foo); // ok
  f.fn(bar); // error: contrain not satisfied
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dE9nWdETs">https://godbolt.org/z/dE9nWdETs</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implement simple dependency injection framework based on concepts?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto create(auto&amp;&amp; injector); // TODO

template&lt;class T&gt; concept foo_like = requires(T t) { t.f; };
template&lt;class T&gt; concept bar_like = requires(T t) { t.b; };

auto foo_like_v = [](foo_like auto){};
auto bar_like_v = [](bar_like auto){};

struct foo { int f{}; };
struct bar { int b{}; };

struct app {
  static constexpr auto ctor_traits = injector{foo_like_v, bar_like_v}; // reflection
  app(foo_like auto f, bar_like auto b) { }
};

int main() {
  auto i = injector{
    bind&lt;bar_like_v, bar&gt;{},
    bind&lt;foo_like_v, foo&gt;{},
  };

  auto a = create&lt;app&gt;(i);
  static_assert(sizeof(a));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8T9P174M5">https://godbolt.org/z/8T9P174M5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
template <typename Base, typename Tuple, std::size_t I = 0><br />
struct tuple_ref_index;</p>
<p>template <typename Base, typename Head, typename... Tail, std::size_t I><br />
struct tuple_ref_index<Base, std::tuple\<Head, Tail...>, I><br />
    : std::conditional<std::is_base_of\<Base, Head>::value
                     , std::integral_constant\<std::size_t, I>
                     , tuple_ref_index\<Base, std::tuple\<Tail...>, I+1>
                     >::type<br />
{<br />
};</p>
<p>template <typename Base, typename Tuple><br />
auto tuple_ref_by_inheritance(Tuple&amp;&amp; tuple)<br />
    -&gt; decltype(std::get<tuple_ref_index\<Base, typename std::decay\<Tuple>::type>::value>(std::forward<Tuple>(tuple)))<br />
{<br />
    return std::get<tuple_ref_index\<Base, typename std::decay\<Tuple>::type>::value>(std::forward<Tuple>(tuple));<br />
}</p>
<p>template<typename Bind><br />
auto get_bind_type(Bind)<br />
{<br />
    return typename Bind::type{};<br />
}</p>
<p>template<typename...BindTypes, typename...CtorTraits><br />
auto get_bind_types(std::tuple<BindTypes...> bts, std::tuple<CtorTraits...>)<br />
{<br />
    return std::tuple{get_bind_type(tuple_ref_by_inheritance<CtorTraits>(bts))...};<br />
}</p>
<p>template<typename...Ts><br />
auto get_types_as_tuple(injector<Ts...>)<br />
{<br />
    return std::tuple<Ts...>{};<br />
}</p>
<p>template<class T><br />
constexpr auto create(auto&amp;&amp; injector)<br />
{<br />
    auto bind_types = get_types_as_tuple(injector);<br />
    auto ctor_traits_types = get_types_as_tuple(T::ctor_traits);</p>
<pre class="codehilite"><code>return std::make_from_tuple&lt;T&gt;(get_bind_types(bind_types, ctor_traits_types));
</code></pre>

<p>}<br />
 ```</p>
<blockquote>
<p><a href="https://godbolt.org/z/zoYjGs3xE">https://godbolt.org/z/zoYjGs3xE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
constexpr auto create(auto injector) {
  if constexpr (requires { T::ctor_traits; }) {
    return [=]&lt;class... Ts&gt;(::injector&lt;Ts...&gt;) {
      return T{[=]&lt;auto C, class U&gt;(bind&lt;C, U&gt;) {
        return create&lt;U&gt;(injector);
      }.template operator()&lt;Ts{}&gt;(injector)...};
    }(T::ctor_traits);
  } else {
    return T{};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/beTnhh31r">https://godbolt.org/z/beTnhh31r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto create(auto&amp;&amp; injector) {
    return [&amp;]&lt;class... Ts&gt;(::injector&lt;Ts...&gt;) {
        return T{ (Ts{}, []&lt;class _&gt;(bind&lt;Ts{}, _&gt;) { return _{}; }(injector))... };
    }(T::ctor_traits);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yq7odx86e">https://godbolt.org/z/Yq7odx86e</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>316 - Did you know about `std::rank/std::rank_v` type_trait to get the rank of the array?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/316.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/316.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know about <code>std::rank/std::rank_v</code> type_trait to get the rank of the array?</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/meta.unary.prop.query#lib:rank">https://eel.is/c++draft/meta.unary.prop.query#lib:rank</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(0 == std::rank_v&lt;void&gt;);
static_assert(0 == std::rank_v&lt;int&gt;);
static_assert(1 == std::rank_v&lt;int[]&gt;);
static_assert(0 == std::rank_v&lt;int[0]&gt;);
static_assert(1 == std::rank_v&lt;int[1]&gt;);
static_assert(1 == std::rank_v&lt;int[42]&gt;);
static_assert(2 == std::rank_v&lt;int[][2]&gt;);
static_assert(2 == std::rank_v&lt;int[1][2]&gt;);
static_assert(3 == std::rank_v&lt;int[1][2][3]&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e657s3">https://godbolt.org/z/e657s3</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p>Can you implement standard compliant version of <code>std::rank_v</code>?</p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(0 == rank_v&lt;void&gt;);
static_assert(0 == rank_v&lt;int&gt;);
static_assert(1 == rank_v&lt;int[]&gt;);
static_assert(0 == rank_v&lt;int[0]&gt;);
static_assert(1 == rank_v&lt;int[1]&gt;);
static_assert(1 == rank_v&lt;int[42]&gt;);
static_assert(2 == rank_v&lt;int[][2]&gt;);
static_assert(2 == rank_v&lt;int[1][2]&gt;);
static_assert(3 == rank_v&lt;int[1][2][3]&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7Ms3W4TdP">https://godbolt.org/z/7Ms3W4TdP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;type_traits&gt;

template&lt;class T&gt;
struct prev;

template&lt;class T, int N&gt;
struct prev&lt;T[N]&gt; : std::type_identity&lt;T&gt; {};

template&lt;class T&gt;
struct prev&lt;T[]&gt; : std::type_identity&lt;T&gt; {};

template&lt;class T&gt;
constexpr auto return_rank()
{
    if constexpr (::std::is_array_v&lt;T&gt;) {
        return return_rank&lt;typename prev&lt;T&gt;::type&gt;() + 1;
    }
    return 0;
}

template&lt;class T&gt;
constexpr auto rank_v = return_rank&lt;T&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qdx7bxde7">https://godbolt.org/z/qdx7bxde7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename T&gt;
constexpr auto rank(){
    if constexpr (std::is_array_v&lt;T&gt;) {
        return 1 + rank&lt;std::remove_extent_t&lt;T&gt;&gt;();
    } else {
        return 0;
    }
}
};

template &lt;typename T&gt;
constexpr auto rank_v = detail::rank&lt;T&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c88aheerd">https://godbolt.org/z/c88aheerd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct rank : public std::integral_constant&lt;std::size_t, 0&gt; {};

template&lt;class T&gt;
struct rank&lt;T[]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};

template&lt;class T, std::size_t N&gt;
struct rank&lt;T[N]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};

template&lt; class T &gt;
inline constexpr std::size_t rank_v = rank&lt;T&gt;::value;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YYdTesPKx">https://godbolt.org/z/YYdTesPKx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class&gt;
constexpr auto rank_v = 0uz;

template &lt;class T&gt;
constexpr auto rank_v&lt;T[]&gt; = rank_v&lt;T&gt; + 1uz;

template &lt;class T, auto N&gt;
constexpr auto rank_v&lt;T[N]&gt; = rank_v&lt;T[]&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G75xEEGfz">https://godbolt.org/z/G75xEEGfz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
constexpr auto rank_v = []{
  constexpr auto recur = []&lt;typename U&gt;(auto recur, std::type_identity&lt;U&gt;, auto accum){
    if constexpr (std::is_array_v&lt;U&gt;){
      return recur(recur, std::type_identity&lt;std::remove_extent_t&lt;U&gt;&gt;{}, accum+1);
    } else {
      return accum;
    }
  };
  return recur(recur, std::type_identity&lt;T&gt;{}, 0);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5eE1MWbj9">https://godbolt.org/z/5eE1MWbj9</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>315 - Did you know about C++20 `is_layout_compatible_v` type_trait?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/315.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/315.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++20 <code>is_layout_compatible_v</code> type_trait?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/meta.type.synop">https://eel.is/c++draft/meta.type.synop</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
    int a{};
    int b{};
};

struct bar {
    const int x{};
    int y{};
};

struct baz : bar { };

struct other {
    int a{};
    char b[4]{};
};

static_assert(not std::is_layout_compatible_v&lt;void, int&gt;);
static_assert(not std::is_layout_compatible_v&lt;const int*, const int&amp;&gt;);

static_assert(std::is_layout_compatible_v&lt;const int, int const volatile&gt;);
static_assert(std::is_layout_compatible_v&lt;foo, bar&gt;);
static_assert(std::is_layout_compatible_v&lt;foo, baz&gt;);
static_assert(std::is_layout_compatible_v&lt;bar, baz&gt;);
static_assert(not std::is_layout_compatible_v&lt;bar, other&gt;);
static_assert(not std::is_layout_compatible_v&lt;bar, void&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v9KM34qMW">https://godbolt.org/z/v9KM34qMW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implemtn <code>count_compatible</code> which returns the number of compatible types to the given one?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... Ts&gt;
constexpr auto count_compatible = 0; // TODO

static_assert(0 == count_compatible&lt;int, const int*, const int&amp;, volatile int*, int()&gt;);
static_assert(0 == count_compatible&lt;void*, volatile void*, const volatile void*, volatile const void* const&gt;);
static_assert(0 == count_compatible&lt;void, int&gt;);

static_assert(1 == count_compatible&lt;int, int&gt;);
static_assert(1 == count_compatible&lt;int, float, int&gt;);
static_assert(2 == count_compatible&lt;int, short, signed int, unsigned int, int const&gt;);
static_assert(4 == count_compatible&lt;int, int, const int, int const, unsigned const, signed const int&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7cjqdxGxE">https://godbolt.org/z/7cjqdxGxE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
template<class T, class... Ts><br />
constexpr auto count_compatible = (std::is_layout_compatible_v<T, Ts> + ... + std::size_t{});</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/8v741635E](https://godbolt.org/z/8v741635E)

```cpp
template&lt;class T, class... Ts&gt;
constexpr auto count_compatible = []{
    return (std::is_layout_compatible_v&lt;T, Ts&gt; + ...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GEcr44h49">https://godbolt.org/z/GEcr44h49</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... Ts&gt;
constexpr auto count_compatible = (... + std::is_layout_compatible_v&lt;T, Ts&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fxqYeben5">https://godbolt.org/z/fxqYeben5</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>314 - Did you know that with gnu:C++26 a more parts of static reflection can be emulated?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/314.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/314.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that with gnu:C++26 a more parts of static reflection can be emulated?</p>
</li>
<li>
<p><a href="https://wg21.link/P1240">https://wg21.link/P1240</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo { int a{}; int b{}; };
struct bar { int a{}; };

constexpr auto structs = meta_find&lt;&quot;struct&quot;&gt;;
static_assert(2uz == structs.size());
static_assert(&quot;foo&quot; == structs[0]);
static_assert(&quot;bar&quot; == structs[1]);

static_assert(reflexpr&lt;foo&gt;);

constexpr auto f = typeof&lt;[] { return structs[0]; }&gt;{.a = 1, .b = 2};
static_assert(1 == f.a and 2 == f.b);

constexpr auto t = to_tuple(f);
static_assert(&quot;a&quot; == std::get&lt;0&gt;(t).name and 1 == std::get&lt;0&gt;(t).value);
static_assert(&quot;b&quot; == std::get&lt;1&gt;(t).name and 2 == std::get&lt;1&gt;(t).value);

int main() {
  reflexpr auto b = bar{};
  // ...
  constexpr auto name = std::find(structs.cbegin(), structs.cend(), type_name&lt;decltype(b)&gt;());
  static_assert(name != structs.cend());
  static_assert(42 == typeof&lt;[] { return *name; }&gt;{42}.a);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PPsn4KM7Y">https://godbolt.org/z/PPsn4KM7Y</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Given reflection primitives can you implemnt all_structs_field_names which returns combined list of all field names from all structs in the file?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct foo {
    int a{};
    int b{};
};
static_assert(reflexpr&lt;foo&gt;);

struct bar {
    int c{};
};
static_assert(reflexpr&lt;bar&gt;);

struct baz {
    int d{};
    int e{};
    int f{};
};
static_assert(reflexpr&lt;baz&gt;);

[[nodiscard]] constexpr auto all_structs_field_names(); // TODO

constexpr auto ns = all_structs_field_names();
static_assert(6uz == ns.size());
static_assert(&quot;a&quot; == ns[0]);
static_assert(&quot;b&quot; == ns[1]);
static_assert(&quot;c&quot; == ns[2]);
static_assert(&quot;d&quot; == ns[3]);
static_assert(&quot;e&quot; == ns[4]);
static_assert(&quot;f&quot; == ns[5]);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M1KdE8xET">https://godbolt.org/z/M1KdE8xET</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto all_structs_field_names() {
  return []&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
    return std::apply(
        [](auto... elements) {
          static_vector&lt;std::string_view, sizeof...(elements)&gt; v{};
          (..., v.push_back(elements.name));
          return v;
        },
        std::tuple_cat(
            to_tuple(typeof&lt;[] { return meta_find&lt;&quot;struct&quot;&gt;[Is]; }&gt;{})...));
  }(std::make_index_sequence&lt;meta_find&lt;&quot;struct&quot;&gt;.size()&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hnKTfs8bx">https://godbolt.org/z/hnKTfs8bx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto members_to_names(auto&amp; out, auto struct_members) {
    constexpr auto num_members = std::tuple_size_v&lt;decltype(struct_members)&gt;;
    [&amp;out, &amp;struct_members]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        (
            out.push_back(std::get&lt;Ns&gt;(struct_members).name)
            , ...
        );
    }(std::make_index_sequence&lt;num_members&gt;{});
}

template
&lt;std::size_t index&gt;
[[nodiscard]] constexpr auto struct_instance() {
    return typeof&lt;[] { return structs[index]; }&gt;{};
};

template
&lt;std::size_t MaxSize = 8&gt;
[[nodiscard]] constexpr auto all_structs_field_names() {
    static_vector&lt;std::string_view, MaxSize&gt; names{};
    [&amp;names]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt; ns) {
        (
            members_to_names(names, to_tuple(struct_instance&lt;Ns&gt;()))
            , ...
        );
    }(std::make_index_sequence&lt;structs.size()&gt;{});
    return names;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z56h5xahv">https://godbolt.org/z/z56h5xahv</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>313 - Did you know that C++26 added #embed?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/313.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/313.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++26 added #embed?</p>
</li>
<li>
<p><a href="https://wg21.link/P1967">https://wg21.link/P1967</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;string_view&gt;

static constexpr char self[] = {
  #embed __FILE__
};

static_assert(std::string_view{std::cbegin(self), std::cend(self)}.front() == '#');
static_assert(std::string_view{std::cbegin(self), std::cend(self)}.back()  == ';');
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/czTaz578j">https://godbolt.org/z/czTaz578j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p>Can you implement <code>meta_contains</code> which returns true if given string is contined in the current file and false otherwise?</p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;fixed_string Name&gt;
constexpr auto meta_contains = false; // TODO

struct foo {};
struct bar {};

auto fn() -&gt; void;

static_assert(not meta_contains&lt;&quot;struct x&quot;&gt;);
static_assert(not meta_contains&lt;&quot;STD::string_view&quot;&gt;);
static_assert(meta_contains&lt;&quot;std::string_view&quot;&gt;);
static_assert(meta_contains&lt;&quot;struct foo&quot;&gt;);
static_assert(meta_contains&lt;&quot;struct bar&quot;&gt;);
static_assert(meta_contains&lt;&quot;auto fn()&quot;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6cvn4n8j5">https://godbolt.org/z/6cvn4n8j5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;string_view&gt;
#include &lt;algorithm&gt;
template&lt;unsigned N&gt;
struct FixedString {
    char buf[N + 1]{};
    constexpr FixedString(char const* s) {
        for (unsigned i = 0; i != N; ++i) buf[i] = s[i];
    }
    constexpr char const* data() const { return buf; }
    constexpr auto size() const { return N; }
};
template&lt;unsigned N&gt; FixedString(char const (&amp;)[N]) -&gt; FixedString&lt;N - 1&gt;;

using cstringtype = char const [];

constexpr static cstringtype metadata  {
    #embed __FILE__
};

std::string_view meta {metadata};

struct foo {};
struct bar {};

auto fn() -&gt; void;

template&lt;FixedString Name&gt;
constexpr auto meta_contains = std::search(
    metadata, metadata + std::size(metadata),
    Name.data(), Name.data() + Name.size()
) &lt;= std::find(metadata, metadata + std::size(metadata), '/'); //an ENDTAG before static asserts

//
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xfWh649E6">https://godbolt.org/z/xfWh649E6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;fixed_string Name&gt;
constexpr auto meta_contains = [] {
  static constexpr char meta[] = {
    #embed __FILE__
  };
  const auto code = std::string_view(std::data(meta), std::size(meta));
  const auto find = code.find(Name);
  return find != std::string_view::npos and code[find-1] != '\&quot;';
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Kq5eWfGaK">https://godbolt.org/z/Kq5eWfGaK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr fixed_string self = {
    #embed __FILE__
};

template&lt;fixed_string Name&gt;
constexpr auto meta_contains = std::string_view{self}.substr(0,1600).contains(Name);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YjsreKvPd">https://godbolt.org/z/YjsreKvPd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static constexpr char self[] = {
    #embed __FILE__
};

template&lt;fixed_string Name&gt;
constexpr auto meta_contains = []&lt;std::size_t N&gt;(const char (&amp;f)[N]) constexpr{
    std::string_view code (f,N);
    auto found = code.find(Name);
    return found &gt;=0 &amp;&amp; (found ==0||code[found-1] != '&quot;') ;
}(self);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dq1nPWes1">https://godbolt.org/z/dq1nPWes1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto marker = fixed_string{{'s','t','a','t','i','c','_','a','s','s','e','r','t'}};
constexpr auto marker_location = std::string_view{std::begin(self), std::end(self)}.find(std::string_view{marker.begin(), marker.end()-1});

template&lt;fixed_string Name&gt;
constexpr auto meta_contains =
    std::string_view{std::begin(self), std::end(self)}
        .find(std::string_view{Name.begin(), Name.end()-1}) &lt;
        marker_location;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q3q5Gcxax">https://godbolt.org/z/q3q5Gcxax</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>312 - Did you know that C++20 added support for Unevaluated asm-declaration in constexpr functions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/312.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/312.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++20 added support for Unevaluated asm-declaration in constexpr functions?</p>
</li>
<li>
<p><a href="https://wg21.link/P1668">https://wg21.link/P1668</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto get = [](auto value) {
  if consteval {
    return value;
  } else {
    auto result = 0;
    asm(&quot;movl $42, %%eax\n&quot; : &quot;=r&quot; (result) );
    return result;
  }
};

static_assert(0 == get(0));
static_assert(4 == get(4));
static_assert(2 == get(2));

consteval auto fn() {
    return get(0);
}

int main(int argc, char**) {
  assert(42 == get(0));
  assert(42 == get(argc));
  return fn();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z5jYdsa9P">https://godbolt.org/z/z5jYdsa9P</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p>Can you implement <code>const_sub_or_asm_add</code> which subtract given numbers using C++ operators if values can be constant evaluated and adds them using inline assembly otherwise?</p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
  return 0; /*TODO*/
};

static_assert(1 == const_sub_or_asm_add(2, 1));
static_assert(-1 == const_sub_or_asm_add(3, 4));

int main(int argc, char**) {
  {
    constexpr auto c = const_sub_or_asm_add(1, 2);
    assert(-1 == c);
  }

  {
    auto c = const_sub_or_asm_add(1, 2);
    assert(3 == c);
  }

  {
    assert(3 == const_sub_or_asm_add(1, 2));
    assert(1 == const_sub_or_asm_add(argc, 0));
    assert(2 == const_sub_or_asm_add(argc, argc));
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/897a3fn8M">https://godbolt.org/z/897a3fn8M</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
    if consteval {
        return lhs - rhs;
    } else {
        auto result = 0;
        asm (&quot;addl  %%ebx,%%eax&quot;
            :&quot;=a&quot;(result)
            :&quot;a&quot;(lhs), &quot;b&quot;(rhs)
            );
        return result;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TdjMzKdaT">https://godbolt.org/z/TdjMzKdaT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
  if consteval {
    return lhs - rhs;
  } else {
    decltype(lhs + rhs) result;
    asm(&quot;leal (%1, %2), %0\n&quot; : &quot;=r&quot;(result) : &quot;r&quot;(lhs), &quot;r&quot;(rhs));
    return result;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vrf35veev">https://godbolt.org/z/vrf35veev</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
  if consteval {
    return lhs - rhs;
  } else {
    auto result = 0;
    asm(&quot;add %%edx, %%eax\n&quot; : &quot;=r&quot; (result) : &quot;edx&quot; (lhs), &quot;eax&quot; (rhs) );
    return result;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f34bsrj4o">https://godbolt.org/z/f34bsrj4o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
    if consteval {
        return lhs - rhs;
    } else {
        auto result = 0;
        asm(&quot;movl %2, %0;&quot;
            &quot;addl %1, %0;&quot;
            : &quot;=&amp;r&quot;(result)
            : &quot;r&quot;(lhs), &quot;r&quot;(rhs));
        return result;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bz4z5Exdd">https://godbolt.org/z/bz4z5Exdd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
    if (std::is_constant_evaluated())
        return lhs - rhs;
    asm(&quot;addl %%ebx, %%eax;&quot; : &quot;=a&quot; (lhs) : &quot;a&quot; (lhs) , &quot;b&quot; (rhs) );
    return lhs;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/af3vonrnW">https://godbolt.org/z/af3vonrnW</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto const_sub_or_asm_add = [](auto lhs, auto rhs) {
  if consteval {
    return lhs - rhs;
  } else {
    auto add{0};
    asm(&quot;addl %%ebx, %%eax\n&quot;
        : &quot;=a&quot; (add)
        : &quot;a&quot; (lhs), &quot;b&quot; (rhs) );
    return lhs + rhs;
  }
  return 0; /*TODO*/
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7zadcr6qx">https://godbolt.org/z/7zadcr6qx</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>311 - Did you know DRY (Dont Repeat Yourself) comparisons pattern?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/311.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/311.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know DRY (Dont Repeat Yourself) comparisons pattern?</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/alg.nonmodifying">https://eel.is/c++draft/alg.nonmodifying</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto none_of(auto pred, auto... ts) {
    const auto a = std::array{ts...};
    return std::none_of(std::cbegin(a), std::cend(a), pred);
}

auto before(int a, int b, int c) {
    if (a != 2 and b != 2 and c != 2) {
      return 42;
    }
    return 0;
}

auto after(int a, int b, int c) {
    if (none_of([](auto x) { return x == 2; }, a, b, c)) {
      return 42;
    }
    return 0;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xsc5TM7P9">https://godbolt.org/z/xsc5TM7P9</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p>Can you implement DRY version of <code>any_of</code> with user-friendly interface?</p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/* TODO any_of */

int main() {
  using namespace boost::ut;

  should(&quot;return true if any of given values is equal the expected value&quot;) = [] {
    expect(any_of(1) == 1);
    expect(any_of(1, 2, 3) == 2);
    expect(any_of(1, 2, 3) == 3);
  };

  should(&quot;return false if all of given values do not equal the expected value&quot;) = [] {
    expect(not (any_of()  == 0));
    expect(not (any_of(1) == 42));
    expect(not (any_of(2) == 42));
    expect(not (any_of(1, 2, 3) == 42));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eErfEfvoj">https://godbolt.org/z/eErfEfvoj</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;utility&gt;
#include &lt;tuple&gt;
#include &lt;concepts&gt;

template&lt;class ... Args&gt;
struct Comp {
    template&lt;class T&gt;
    auto operator==(T &amp;&amp; other) {
        return std::apply(
            [&amp;other](auto &amp;&amp;... data) {
                return (((std::equality_comparable_with&lt;decltype(data), T&gt;) &amp;&amp; data == other) || ...);
            },
            this -&gt; data
        );
    }
    std::tuple&lt;Args...&gt; data {};
};

template&lt;class ...Args&gt;
auto any_of(Args &amp;&amp; ... args)  {
    return Comp&lt;Args...&gt; {
        std::make_tuple(std::forward&lt;Args&gt;(args)...)
    };

}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vj8d8jeo9">https://godbolt.org/z/vj8d8jeo9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct any_of {
  any_of(Ts... args) : args{args...} {}

  auto operator==(auto rhs) const {
    return std::apply([&amp;](auto... lhs) { return (... or (lhs == rhs)); }, args);
  }

 private:
  std::tuple&lt;Ts...&gt; args;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/efjx5c68M">https://godbolt.org/z/efjx5c68M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename ... Ts&gt;
struct any_of{
    any_of(Ts const &amp; ... args):t(args...){}
    bool operator==(auto const &amp; i) {
        return std::apply( [&amp;i](auto const &amp; ...args){
                               return ((args==i)||...);
                           }
                         , t
                         );
    }
    std::tuple&lt;Ts...&gt; t;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KTTcrMTj5">https://godbolt.org/z/KTTcrMTj5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T=int, typename ... Vs&gt;
class any_of {
    std::array&lt;T, sizeof ... (Vs)&gt; values;

  public:
    any_of (Vs ... vs) {
        if constexpr (sizeof ... (Vs)) {
            this-&gt;values = std::array{vs...};
        }
    }

    constexpr bool operator==(const T&amp; other) {
        return std::any_of(
            std::cbegin(this-&gt;values),
            std::cend(this-&gt;values),
            [&amp;other](auto x) { return x == other; } );
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/37cccv9fv">https://godbolt.org/z/37cccv9fv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename... Ts&gt;
struct any_of {
    any_of(Ts... ts):values{ts...}{}

    auto operator == (auto t){
        return std::any_of(std::begin(values), std::end(values), [=](auto x){ return t == x;});
    }

    private:
    std::array&lt;int, sizeof...(Ts)&gt; values;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TKWsroz55">https://godbolt.org/z/TKWsroz55</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct any_of {
    any_of(Ts... values) : values_{values...} {}

    bool operator==(auto to) const {
        return std::apply([&amp;](auto&amp;&amp;... value) { return ((value == to) || ...); }, values_);
    }

   private:
    std::tuple&lt;Ts...&gt; values_;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TYv3vYrKE">https://godbolt.org/z/TYv3vYrKE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>310 - Did you know that C+23 permitts static constexpr variables in constexpr functions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/310.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/310.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C+23 permitts static constexpr variables in constexpr functions?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2647">https://wg21.link/P2647</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto foo() {
  static constexpr auto value = 42; // error in C++20, okay in C++23
  return value;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6zK6vj91z">https://godbolt.org/z/6zK6vj91z</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you implement <code>to_string_view</code> which converts in-place given characters to string_view?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt;
[[nodiscard]] constexpr auto to_string_view(); // TODO

static_assert(std::string_view{&quot;&quot;} == to_string_view&lt;&gt;());
static_assert(std::string_view{&quot;42&quot;} == to_string_view&lt;'4', '2'&gt;());
static_assert(std::string_view{&quot;foo&quot;} == to_string_view&lt;'f', 'o', 'o'&gt;());
static_assert(std::string_view{&quot;bar&quot;} == to_string_view&lt;'b', 'a', 'r'&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4fbYGGxco">https://godbolt.org/z/4fbYGGxco</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt;
[[nodiscard]] constexpr auto to_string_view(){
    static constexpr char p[sizeof...(Cs)] = {Cs...};
    return std::string_view(p, sizeof...(Cs));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r31M7hhno">https://godbolt.org/z/r31M7hhno</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt;

[[nodiscard]] constexpr auto to_string_view(){
    static constexpr std::array&lt;char, sizeof...(Cs)&gt; chars{Cs...};
    return std::string_view{chars};
}

template&lt;&gt;
[[nodiscard]] constexpr auto to_string_view&lt;&gt;(){
    return std::string_view{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eTWasjTTr">https://godbolt.org/z/eTWasjTTr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto to_string_view()
{
    constexpr static std::size_t N = sizeof...(Cs);
    if constexpr (N &gt;0)
    {
        constexpr static std::array&lt;char,N&gt; chars{Cs...};
        return std::string_view(chars.data(),N);
    } else
        return std::string_view(&quot;&quot;);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9MMKv98dE">https://godbolt.org/z/9MMKv98dE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt;
[[nodiscard]] constexpr auto to_string_view() {
  static constexpr char cs[]{Cs..., 0};
  return std::string_view{cs};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PPdxETv76">https://godbolt.org/z/PPdxETv76</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>309 - Did you know that C++20 added support for constexpr std::vector?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/309.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/309.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added support for constexpr std::vector?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1004">https://wg21.link/P1004</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Ns&gt; consteval auto fn() {
  std::vector v{Ns...};
  return std::size(v);
}

static_assert(3uz == fn&lt;1, 2, 3&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vx6cPaY8s">https://godbolt.org/z/vx6cPaY8s</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<blockquote>
<p><strong>Can you simplify <code>filter</code> example by applying best C++ practicies?</strong></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;array&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

constexpr auto filter(auto t, auto fn) {
    // get the size of filtered elements
    constexpr auto size = [=] {
        std::vector&lt;std::size_t&gt; v{};
        std::apply([&amp;, i = 0](auto... ts) mutable {
            ([&amp;] {
                if (fn(ts)) {
                    v.push_back(i);
                }
                i++;
            }(), ...);
        }, t());
        return v.size();
    }();

    // get the array of indecies of filtered elements
    constexpr auto values = [=] {
        std::array&lt;std::size_t, size&gt; values{};
        std::apply([&amp;, x = 0, i = 0](auto... ts) mutable {
            ([&amp;] {
                if (fn(ts)) {
                    values[x++] = i;
                }
                i++;
            }(), ...);
        }, t());
        return values;
    }();

    // convert array indicies to tuple elements
    return [=]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return std::tuple{std::get&lt;values[Ns]&gt;(t())...};
    }(std::make_index_sequence&lt;size&gt;{});
};

static_assert(std::tuple{1, 2, 3} == filter([] { return std::tuple{1, 2, 3}; }, [](auto) { return true; }));
static_assert(std::tuple{} == filter([] { return std::tuple{1, 2, 3}; }, [](auto) { return false; }));
static_assert(std::tuple{1, 3} == filter([] { return std::tuple{1, 2, 3}; }, [](auto v) { return v != 2; }));
static_assert(std::tuple{2} == filter([] { return std::tuple{1, 2, 3}; }, [](auto v) { return v == 2; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E7rTGdn7b">https://godbolt.org/z/E7rTGdn7b</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto filter(auto t, auto fn) {
  // get the vector of filtered elements
  constexpr auto r = [=] {
    return std::apply(
        [=](auto... ts) {
          return [=] {
            auto v = std::vector{ts...};
            std::erase_if(v, std::not_fn(fn));
            return v;
          };
        },
        t());
  }();

  // convert the vector to a tuple
  return [=]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    const auto v = r();
    return std::tuple{v[Ns]...};
  }(std::make_index_sequence&lt;r().size()&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WTMEPs93o">https://godbolt.org/z/WTMEPs93o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto filter(auto t, auto fn) {
  constexpr auto v = std::apply(
      [=](auto... ts) {
        auto const ints = {ts...};
        return [=] () { return ints | std::views::filter(fn) | std::ranges::to&lt;std::vector&gt;(); };
      }, t());

  return [=]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return std::tuple{v()[Ns]...};
  }(std::make_index_sequence&lt;v().size()&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3z3s4s6h6">https://godbolt.org/z/3z3s4s6h6</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>308 - Did you know that the layout of struct fields will affect its size/alignment?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/308.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/308.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that the layout of struct fields will affect its size/alignment?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/basic.types.general#:class,standard-layout">https://eel.is/c++draft/basic.types.general#:class,standard-layout</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct unpacked {
  char a;  // size: 1b =&gt; size: 4b
  int  b;  // size: 4b =&gt; size: 4b
  char c;  // size: 1b =&gt; size: 4b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b =&gt; size: 4b
  char b;  // size: 1b =&gt; size: 4b
  int  c;  // size: 4b =&gt; size: 8b
           //             --------
           //             size: 8b
};

static_assert(12 == sizeof(unpacked));
static_assert(8 == sizeof(packed));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q794afz8E">https://godbolt.org/z/q794afz8E</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>is_packed_layout</code> trait which for given type T will return<br />
  { true: if the sizeof...(T.fields) == sizeof(T) or alignments of T.fields are sorted, false : otherwise }?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; constexpr auto is_packed_layout_v;

struct unpacked {
  char a;  // size: 1b =&gt; size: 4b
  int  b;  // size: 4b =&gt; size: 4b
  char c;  // size: 1b =&gt; size: 4b
           //             ---------
           //             size: 12b
};

struct unpacked1 {
  int  b;  // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  int c;   // size: 4b =&gt; size: 12b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b =&gt; size: 4b
  char b;  // size: 1b =&gt; size: 4b
  int  c;  // size: 4b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed1 {
  int a;   // size: 4b =&gt; size: 4b
           //             --------
           //             size: 4b
};

struct packed2 {
  int  c;  // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  char b;  // size: 1b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed3 {
  int x;   // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  char b;  // size: 1b =&gt; size: 8b
  char c;  // size: 1b =&gt; size: 8b
  char d;  // size: 1b =&gt; size: 8b
  int y;   // size: 4b =&gt; size: 12b
           //             ---------
           //             size: 12b
};

struct packed4 {
  using a3_t = std::array&lt;char, 3&gt;;
  short x; // size: 2b =&gt; size: 2b
  short y; // size: 2b =&gt; size: 4b
  a3_t z;  // size: 3b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed5 {
  short x; // size: 2b =&gt; size: 2b
  short y; // size: 2b =&gt; size: 4b
  short z; // size: 2b =&gt; size: 6b
           //             --------
           //             size: 6b
};

struct empty {
           // size: 1b =&gt; size: 1b
           //             --------
           //             size: 1b
};

static_assert(12 == sizeof(unpacked));
static_assert(not is_packed_layout_v&lt;unpacked&gt;);

static_assert(12 == sizeof(unpacked1));
static_assert(not is_packed_layout_v&lt;unpacked1&gt;);

static_assert(8 == sizeof(packed));
static_assert(is_packed_layout_v&lt;packed&gt;);

static_assert(4 == sizeof(packed1));
static_assert(is_packed_layout_v&lt;packed1&gt;);

static_assert(8 == sizeof(packed2));
static_assert(is_packed_layout_v&lt;packed2&gt;);

static_assert(12 == sizeof(packed3));
static_assert(is_packed_layout_v&lt;packed3&gt;);

static_assert(8 == sizeof(packed4));
static_assert(is_packed_layout_v&lt;packed4&gt;);

static_assert(6 == sizeof(packed5));
static_assert(is_packed_layout_v&lt;packed5&gt;);

static_assert(1 == sizeof(empty));
static_assert(is_packed_layout_v&lt;empty&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x17PMbEWe">https://godbolt.org/z/x17PMbEWe</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;type_traits&gt;

template &lt;class T, class... TArgs&gt; decltype(void(T{std::declval&lt;TArgs&gt;()...}), std::true_type{}) test_is_braces_constructible(int);
template &lt;class, class...&gt; std::false_type test_is_braces_constructible(...);
template &lt;class T, class... TArgs&gt; using is_braces_constructible = decltype(test_is_braces_constructible&lt;T, TArgs...&gt;(0));

struct any_type {
  template&lt;class T&gt; constexpr operator T();
};

template&lt;class T&gt; constexpr bool size_of_fields_equals_size_of_struct() noexcept {
  constexpr T object{};
  if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3, m4, m5] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3) + sizeof(m4) + sizeof(m5);
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3, m4] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3) + sizeof(m4);
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3);
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2);
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1);
  } else if constexpr(is_braces_constructible&lt;T, any_type&gt;{}) {
      auto&amp;&amp; [m0] = object;
      return sizeof(T) == sizeof(m0);
  } else {
      return true;
  }
}

template&lt;class T&gt; constexpr bool alignments_sorted() noexcept {
  constexpr T object{};
  if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3, m4, m5] = object;
      std::array&lt;int, 6&gt; sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3), sizeof(m4), sizeof(m5)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3, m4] = object;
      std::array&lt;int, 5&gt; sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3), sizeof(m4)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2, m3] = object;
      std::array&lt;int, 4&gt; sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type, any_type&gt;{}) {
      auto&amp;&amp; [m0, m1, m2] = object;
      std::array&lt;int, 3&gt; sizes{sizeof(m0), sizeof(m1), sizeof(m2)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible&lt;T, any_type, any_type&gt;{}) {
      return true;
  } else if constexpr(is_braces_constructible&lt;T, any_type&gt;{}) {
      return true;
  } else {
      return true;
  }
}

template&lt;class T&gt; constexpr auto is_packed_layout_v = size_of_fields_equals_size_of_struct&lt;T&gt;() || alignments_sorted&lt;T&gt;();

struct unpacked {
  char a;  // size: 1b =&gt; size: 4b
  int  b;  // size: 4b =&gt; size: 4b
  char c;  // size: 1b =&gt; size: 4b
           //             ---------
           //             size: 12b
};

struct unpacked1 {
  int  b;  // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  int c;   // size: 4b =&gt; size: 12b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b =&gt; size: 4b
  char b;  // size: 1b =&gt; size: 4b
  int  c;  // size: 4b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed1 {
  int a;   // size: 4b =&gt; size: 4b
           //             --------
           //             size: 4b
};

struct packed2 {
  int  c;  // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  char b;  // size: 1b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed3 {
  int x;   // size: 4b =&gt; size: 4b
  char a;  // size: 1b =&gt; size: 8b
  char b;  // size: 1b =&gt; size: 8b
  char c;  // size: 1b =&gt; size: 8b
  char d;  // size: 1b =&gt; size: 8b
  int y;   // size: 4b =&gt; size: 12b
           //             ---------
           //             size: 12b
};

struct packed4 {
  using a3_t = std::array&lt;char, 3&gt;;
  short x; // size: 2b =&gt; size: 2b
  short y; // size: 2b =&gt; size: 4b
  a3_t z;  // size: 3b =&gt; size: 8b
           //             --------
           //             size: 8b
};

struct packed5 {
  short x; // size: 2b =&gt; size: 2b
  short y; // size: 2b =&gt; size: 4b
  short z; // size: 2b =&gt; size: 6b
           //             --------
           //             size: 6b
};

struct empty {
           // size: 1b =&gt; size: 1b
           //             --------
           //             size: 1b
};

static_assert(12 == sizeof(unpacked));
static_assert(not is_packed_layout_v&lt;unpacked&gt;);

static_assert(12 == sizeof(unpacked1));
static_assert(not is_packed_layout_v&lt;unpacked1&gt;);

static_assert(8 == sizeof(packed));
static_assert(is_packed_layout_v&lt;packed&gt;);

static_assert(4 == sizeof(packed1));
static_assert(is_packed_layout_v&lt;packed1&gt;);

static_assert(8 == sizeof(packed2));
static_assert(is_packed_layout_v&lt;packed2&gt;);

static_assert(12 == sizeof(packed3));
static_assert(is_packed_layout_v&lt;packed3&gt;);

static_assert(8 == sizeof(packed4));
static_assert(is_packed_layout_v&lt;packed4&gt;);

static_assert(6 == sizeof(packed5));
static_assert(is_packed_layout_v&lt;packed5&gt;);

static_assert(1 == sizeof(empty));
static_assert(is_packed_layout_v&lt;empty&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/46orYesoW">https://godbolt.org/z/46orYesoW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Id&gt;
struct alignment {
  std::size_t *alignments, *sizeofs{};
  template&lt;class T&gt; constexpr operator T() const {
    alignments[Id] = alignof(T);
    sizeofs[Id] = sizeof(T);
    return {};
  }
};

template&lt;class T, auto... Ns&gt;
constexpr auto is_packed_layout(std::index_sequence&lt;Ns...&gt;) {
  if constexpr(sizeof...(Ns) &lt;= 1) {
    return true;
  } else if constexpr(requires { T{alignment&lt;Ns&gt;{}...}; }) {
    std::size_t alignments[sizeof...(Ns)]{}, sizeofs[sizeof...(Ns)]{};
    void(T{alignment&lt;Ns&gt;{alignments, sizeofs}...});
    return sizeof(T) == (sizeofs[Ns] + ...) or
           std::is_sorted(std::cbegin(alignments), std::cend(alignments), [](const auto lhs, const auto rhs) { return lhs &gt; rhs; }) or
           std::is_sorted(std::cbegin(alignments), std::cend(alignments), [](const auto lhs, const auto rhs) { return lhs &lt; rhs; });
  } else {
    return is_packed_layout&lt;T&gt;(std::make_index_sequence&lt;sizeof...(Ns) - 1&gt;{});
  }
}

template&lt;class T&gt; requires std::is_aggregate_v&lt;T&gt;
constexpr std::bool_constant&lt;is_packed_layout&lt;T&gt;(
  std::make_index_sequence&lt;sizeof(T)&gt;{})&gt; is_packed_layout_v{};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/69bqr6r6W">https://godbolt.org/z/69bqr6r6W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
[[nodiscard]] constexpr auto to_tuple(T&amp;&amp; obj) {
    // clang-format off
  if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5, p6, p7, p8, p8, p10);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8, p9] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8, p9] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5, p6, p7, p8, p9);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7, p8] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5, p6, p7, p8);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5, p6, p7] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5, p6, p7);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5, p6] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5, p6] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5, p6);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4, p5] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4, p5] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4, p5);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3, p4] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3, p4] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3, p4);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2, p3] = obj; }; }) {
    auto&amp;&amp; [p1, p2, p3] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2, p3);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1, p2] = obj; }; }) {
    auto&amp;&amp; [p1, p2] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1, p2);
  } else if constexpr (requires { [&amp;obj] { auto&amp;&amp; [p1] = obj; }; }) {
    auto&amp;&amp; [p1] = std::forward&lt;T&gt;(obj);
    return std::make_tuple(p1);
  } else {
    return std::make_tuple();
  }
    // clang-format on
}

template &lt;class T&gt;
consteval bool is_packed_layout() {
    auto t = to_tuple(T{});
    if constexpr (std::tuple_size_v&lt;decltype(t)&gt; == 0) {
        return true;
    } else {
        std::size_t sum = 0;
        std::size_t current_size = sizeof(std::get&lt;0&gt;(t));
        bool ascending = true;
        bool descending = true;
        std::apply(
            [&amp;](auto&amp;&amp;... t) {
                ((sum += sizeof(t),
                ascending = ascending and sizeof(t) &gt;= current_size,
                descending = descending and sizeof(t) &lt;= current_size,
                current_size = sizeof(t)), ...);
            },
            t);
        return (sum == sizeof(T)) or ascending or descending;
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v1vbToYbx">https://godbolt.org/z/v1vbToYbx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Ns&gt;
struct AnyType {
    std::size_t &amp;size, &amp;align;
    template&lt;class T&gt; constexpr operator T() const {
        size = sizeof(T);
        align = alignof(T);
        return T{};
    }
};

template&lt;class T, auto...Ns&gt;
constexpr auto is_packed_layout(std::index_sequence&lt;Ns...&gt;) {
    if constexpr(sizeof...(Ns) &lt;=1) {
        return true;
    } else if constexpr(std::is_constructible_v&lt;T, AnyType&lt;Ns&gt;...&gt;) {
        std::array&lt;std::size_t, sizeof...(Ns)&gt; sizeofs, alignofs;
        void(T{AnyType&lt;Ns&gt;{sizeofs[Ns], alignofs[Ns]}...});
        return sizeof(T) == (sizeofs[Ns] + ...) or
            std::is_sorted(std::crbegin(alignofs), std::crend(alignofs)) or
            std::is_sorted(std::cbegin(alignofs), std::cend(alignofs));
    } else {
        return is_packed_layout&lt;T&gt;(std::make_index_sequence&lt;sizeof...(Ns)-1&gt;{});
    }
}

template&lt;class T&gt; constexpr auto is_packed_layout_v =
is_packed_layout&lt;T&gt;(std::make_index_sequence&lt;sizeof(T)&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rbxo1nd1P">https://godbolt.org/z/rbxo1nd1P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;class T&gt;
auto is_packed(T v) {
  const auto &amp;[... vs] = v;
  constexpr auto packed = (sizeof(T) - ... - sizeof(vs)) &lt; alignof(T);
  return std::bool_constant&lt;packed&gt;{};
}

}  // namespace detail

template &lt;class T&gt;
constexpr auto is_packed_layout_v =
    std::is_empty_v&lt;T&gt; or decltype(detail::is_packed(std::declval&lt;T&gt;()))::value;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e9WKjdE9G">https://godbolt.org/z/e9WKjdE9G</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
auto is_packed(auto v) {
  auto&amp;&amp; [... vs] = v;
  constexpr auto sizes = std::array&lt;std::size_t, sizeof...(vs)&gt;{sizeof(vs)...};
  constexpr auto packed =
      std::reduce(sizes.begin(), sizes.end()) == sizeof(v) or
      std::is_sorted(sizes.begin(), sizes.end(), std::less{}) or
      std::is_sorted(sizes.begin(), sizes.end(), std::greater{});
  return std::bool_constant&lt;packed&gt;{};
}
}  // namespace detail

template &lt;class T&gt;
inline constexpr bool is_packed_layout_v =
    decltype(detail::is_packed(std::declval&lt;T&gt;()))::value
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WPTbbfaqW">https://godbolt.org/z/WPTbbfaqW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace mp = boost::mp;
template &lt;auto Fn&gt;
constexpr auto sort = [](std::ranges::range auto types) {
  std::sort(std::begin(types), std::end(types), Fn);
  return types;
};
using mp::operator|;
auto by_size = [](auto lhs, auto rhs) { return lhs.size &lt; rhs.size; };
constexpr auto pack = [](auto t) {
  return mp::reflection::to_tuple(t) | sort&lt;by_size&gt;;
};

template &lt;class T&gt; constexpr auto is_packed_layout_v =
    sizeof(pack(std::declval&lt;T&gt;())) == sizeof(T);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6MsvK6onv">https://godbolt.org/z/6MsvK6onv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;int N&gt;
struct Foo{
    template&lt;class T&gt; requires (sizeof(T) &gt;=N)
    constexpr operator T() const {
        return {};
    }
    auto constexpr next()
    {
        return Foo&lt;N+1&gt;{};
    }
    auto constexpr size()
    {
        return N;
    }
};
template&lt;typename T&gt;
constexpr bool reverse_constructable( auto const &amp; ... args )
{
    auto constexpr N = sizeof ...(args);
    return [&amp;args...]&lt;auto ... Is&gt;(std::index_sequence&lt;Is...&gt;)
    {
        auto t = std::tie(args...);
        return requires{ T{std::get&lt;N-1-Is&gt;(t)...};};
    }( std::make_index_sequence&lt;sizeof...(args)&gt;());
}

template&lt;class T&gt; constexpr auto is_packed_layout(auto first, auto ... args)
{
    if constexpr ( reverse_constructable&lt;T&gt;(first.next(),args...) )
    {
        return is_packed_layout&lt;T&gt;( first.next(), args...);
    } else if constexpr ( reverse_constructable&lt;T&gt;(Foo&lt;1&gt;{}, first, args...) )
        return is_packed_layout&lt;T&gt;(Foo&lt;1&gt;{}, first, args...);
    else
    {
        auto sum = (first.size()+ ... + args.size() );
        int c0, c1 = first.size();
        auto is_sorted1 = ((c0 = c1, c0 &gt;= (c1 = args.size())) &amp;&amp; ...);
        c1 = first.size();
        auto is_sorted2 = ((c0 = c1, c0 &lt;= (c1 = args.size())) &amp;&amp; ...);
        return sum == sizeof(T) || is_sorted1 ||is_sorted2;
    }
}

template&lt;class T&gt; constexpr auto is_packed_layout_v= sizeof(T) &lt;=1 || is_packed_layout&lt;T&gt;(Foo&lt;1&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6fWW3easG">https://godbolt.org/z/6fWW3easG</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>307 - Did you know that C++23 added static operator[]?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/307.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/307.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added static operator[]?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2589">https://wg21.link/P2589</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct s {
  static constexpr auto operator[]() { return 42; }
};

static_assert(42 == s{}[]);
static_assert(42 == s::operator[]());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GzTc3MxPE">https://godbolt.org/z/GzTc3MxPE</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you provide an example which shows that <code>static operator[]</code> requies less assembly instructions than <code>non-static</code> version?</li>
</ul>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
    static auto operator[]() -&gt; int;
};

struct bar {
    auto operator[]() const -&gt; int;
};

auto get(const int, const foo &amp;o) { return o[]; }
auto get(const int, const bar &amp;o) { return o[]; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ThP4jnoa7">https://godbolt.org/z/ThP4jnoa7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct X { static void operator[](); };
struct Y { void operator[]() const; };

auto fn1() { X{}[]; }
auto fn2() { Y{}[]; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e4xcG9aKv">https://godbolt.org/z/e4xcG9aKv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct s {
  static constexpr auto operator[]() { return 42; }
};

static_assert(42 == s{}[]);
static_assert(42 == s::operator[]());

struct ns {
    constexpr auto operator[](){ return 42; }
};

static_assert(42 == ns{}[]);

int main() {
    s{}[];
    ns{}[];

};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cEq6ET3W5">https://godbolt.org/z/cEq6ET3W5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct foo {
    static auto operator[]() -&gt; int;
};

struct bar {
    auto operator[]() const -&gt; int;
};

template&lt;typename ...Ts&gt;
struct getter
{
   int operator()() const
   {
       return std::apply([](Ts const &amp;... args ){ return (args[] +...);},t);
   }
   std::tuple&lt;Ts...&gt; t;
};

int get(getter&lt;foo,foo,foo,foo,foo&gt; const &amp; g){ return g();}
int get(getter&lt;bar,bar,bar,bar,bar&gt; const &amp; g){ return g();}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/obxWar47n">https://godbolt.org/z/obxWar47n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// static version
struct s {
    static constexpr auto operator[](int i) { return 42; }
};
int main(){
    return s::operator[](0);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bjKccWG7M">https://godbolt.org/z/bjKccWG7M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// static version
struct s {
    static void operator[]();
};
auto fn(){
    s::operator[]();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4zxYP5WaG">https://godbolt.org/z/4zxYP5WaG</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>306 - Did you know about if/else hell anti-pattern?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/306.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/306.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about if/else hell anti-pattern?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/stmt.if#:else">https://eel.is/c++draft/stmt.if#:else</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto if_hell(bool c1, bool c2) {
    if (c1) {
        if (c2) {
            return true;
        } else {
            throw;
        }
    }

    // ...

    return false;
}

static_assert(not if_hell(false, false));
static_assert(not if_hell(false, true));
assert(throws([]{ if_hell(true, false)); }));
static_assert(if_hell(true, true));

[[nodiscard]] constexpr auto if_heaven(bool c1, bool c2) {
    if (not c1) {
        return false;
    }

    if (not c2) {
        throw;
    }

    // ...

    return true;
}

static_assert(not if_heaven(false, false));
static_assert(not if_heaven(false, true));
assert(throws([]{ if_heaven(true, false)); }));
static_assert(if_heaven(true, true));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jEqbM6ozW">https://godbolt.org/z/jEqbM6ozW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you refactor function <code>foo</code> to avoid if/else hell anti-pattern?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;optional&gt;
#include &lt;stdexcept&gt;

// TODO refactor foo to avoid if/else hell anti-pattern
[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
  if (is_buy) {
      if (price &gt; 0) {
          if (quantity &gt; 0) {
            const auto filled = trigger(price, quantity);
            if (filled &gt; 0) {
              return filled;
            } else {
              return std::nullopt;
            }
          } else {
              return std::nullopt;
          }
      } else {
          return std::nullopt;
      }
  } else {
      throw std::runtime_error{&quot;not is_buy!&quot;};
  }

  return std::nullopt;
}

#include &lt;[https://raw.githubusercontent.com/boost-experimental/ut/master/include/boost/ut.hpp](https://raw.githubusercontent.com/boost-experimental/ut/master/include/boost/ut.hpp)&gt;
#include &lt;tuple&gt;

int main() {
  using namespace boost::ut;

  &quot;foo&quot;_test = [] {
    expect(throws([]{std::ignore = foo([](auto...) { return 0; }, false, 0, 0);}));
    expect(not foo([](auto...) { return 0; }, true, 0, 0));
    expect(not foo([](auto...) { return 0; }, true, 10, 0));
    expect(not foo([](auto...) { return 0; }, true, 10, 10));
    expect(not foo([](auto...) { return 0; }, true, 10, 10));
    expect(1 == foo([](auto...) { return 1; }, true, 10, 10));
    expect(42 == foo([](auto...) { return 42; }, true, 100, 1000));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fY676KcEs">https://godbolt.org/z/fY676KcEs</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
    if (not is_buy) {
        throw std::runtime_error{&quot;not is_buy!&quot;};
    }

    if (price &lt;= 0 or quantity &lt;= 0) {
        return std::nullopt;
    }

    const auto filled = trigger(price, quantity);
    if (filled &gt; 0) {
        return filled;
    } else {
        return std::nullopt;
    }
}
 ```

&gt; [https://godbolt.org/z/Pqe3a7xnG](https://godbolt.org/z/Pqe3a7xnG)
```cpp
[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt;
{
    if (not is_buy)
    {
        throw std::runtime_error{&quot;not is_buy!&quot;};
    }
    if ((price &gt; 0) &amp;&amp; (quantity &gt; 0))
    {
        const auto filled = trigger(price, quantity);
        if (filled &gt; 0)
        {
            return filled;
        }
    }

    return std::nullopt;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/31Pf9P83e">https://godbolt.org/z/31Pf9P83e</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
  if (not is_buy) {
    throw std::runtime_error{&quot;not is_buy!&quot;};
  }

  if (price &lt;= 0 || quantity &lt;= 0)
  {
      return std::nullopt;
  }

  const auto filled = trigger(price, quantity);
  if (filled &lt;= 0) {
    return std::nullopt;
  }
  return filled;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WoeYxMcn6">https://godbolt.org/z/WoeYxMcn6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
  if (not is_buy) {
    throw std::runtime_error{&quot;not is_buy!&quot;};
  }

  if (price &lt;= 0 or quantity &lt;= 0) {
    return std::nullopt;
  }

  if (const auto filled = trigger(price, quantity); filled) {
    return filled;
  }

  return std::nullopt;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4vdeTv7qr">https://godbolt.org/z/4vdeTv7qr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
  if (not is_buy)
    throw std::runtime_error{&quot;not is_buy!&quot;};
  if (price &lt;= 0 or quantity &lt;=0)
    return std::nullopt;
  const auto filled = trigger(price,quantity);
  if( trigger(price,quantity)&gt;0)
    return filled;
  return std::nullopt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xeM47eTE9">https://godbolt.org/z/xeM47eTE9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {
  if (not is_buy) {
    throw std::runtime_error{&quot;not is_buy!&quot;};
  }

  if (price &lt;= 0 or quantity &lt;= 0) {
    return std::nullopt;
  }

  const auto filled = trigger(price, quantity);
  return filled &gt; 0 ? std::optional{filled} : std::nullopt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5j81GTe79">https://godbolt.org/z/5j81GTe79</a></p>
</blockquote>
<pre class="codehilite"><code>[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price,
                                 int quantity) -&gt; std::optional&lt;int&gt; {
    if (!is_buy) {
        throw std::runtime_error{&quot;not is_buy!&quot;};
    }
    if (int filled;
        price &gt; 0 &amp;&amp; quantity &gt; 0 &amp;&amp; (filled = trigger(price, quantity)) &gt; 0) {
        return filled;
    }
    return std::nullopt;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E61ovEveo">https://godbolt.org/z/E61ovEveo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto foo(auto trigger, bool is_buy, int price, int quantity) -&gt; std::optional&lt;int&gt; {

  if (!is_buy){
      throw std::runtime_error{&quot;not is_buy!&quot;};
  }

  decltype(trigger(std::declval&lt;int&gt;(), std::declval&lt;int&gt;())) filled;
  if (price &gt; 0 &amp;&amp; quantity &gt; 0 &amp;&amp; (filled = trigger(price, quantity)) &gt; 0) {
    return filled;
  }

  return std::nullopt;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h8ej4KTzo">https://godbolt.org/z/h8ej4KTzo</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>305 - Did you know about (rejected) proposal for homogeneous variadic function parameters?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/305.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/305.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about (rejected) proposal for homogeneous variadic function parameters?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1219">https://wg21.link/P1219</a> (https://github.com/cplusplus/papers/issues/297)</p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

// auto fn(int...) -&gt; void;   // error
auto fn(int, ...) -&gt; void ;   // ok
auto fn(std::same_as&lt;int&gt; auto...) -&gt; void; // ok
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cfq78aWj5">https://godbolt.org/z/cfq78aWj5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement <code>safe_call</code> which will call given function with variadic type-safe input parameters from propagted from ...?</strong></p>
</li>
<li>
<p>Max number of parameters is 3</p>
</li>
<li>fn is expected to be called with types coresponding to input parameters (not just strings, for example)</li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto safe_call(auto fn, auto fmt, ...);  // TODO

int main() {
    {
    std::stringstream str{};
    safe_call([&amp;](auto... args) { ((str &lt;&lt; args), ...); }, &quot;&quot;);
    assert(std::string{&quot;&quot;} == str.str());
    }

    {
    std::stringstream str{};
    safe_call([&amp;](auto... args) { ((str &lt;&lt; args), ...); }, &quot;id&quot;, 4, 2.);
    assert(std::string{&quot;42&quot;} == str.str());
    }

    {
    std::stringstream str{};
    safe_call([&amp;](auto... args) { ((str &lt;&lt; args), ...); }, &quot;di&quot;, 3.2, 1);
    assert(std::string{&quot;3.21&quot;} == str.str());
    }

    {
    std::stringstream str{};
    safe_call([&amp;](auto... args) { ((str &lt;&lt; args), ...); }, &quot;idi&quot;, 1, 2.3, 4);
    assert(std::string{&quot;12.34&quot;} == str.str());
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eT7vnM13E">https://godbolt.org/z/eT7vnM13E</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">void assert_fmt(char fmt, char required_fmt) {
    if (fmt != required_fmt) {
        throw std::runtime_error(std::string(&quot;fmt must be '&quot;) + required_fmt + &quot;'&quot;);
    }
}

template&lt;class T&gt;
requires std::same_as&lt;T, int&gt;
void assert_fmt(char fmt) {
    assert_fmt(fmt, 'i');
}

template&lt;class T&gt;
requires std::same_as&lt;T, double&gt;
void assert_fmt(char fmt) {
    assert_fmt(fmt, 'd');
}

template&lt;class T&gt;
auto safe_call_helper(auto fn, auto fmt, std::same_as&lt;T&gt; auto arg) {
    assert_fmt&lt;T&gt;(*fmt);
    fn(arg);
}

template&lt;class T, class U&gt;
auto safe_call_helper(auto fn, auto fmt, T arg_0, U arg_1, auto ... args) {
    assert_fmt&lt;T&gt;(*fmt);
    fn(arg_0);
    safe_call_helper&lt;U&gt;(fn, fmt + 1, arg_1, args...);
}

template&lt;class ... Ts&gt;
using FirstType = std::tuple_element_t&lt;0, std::tuple&lt;Ts...&gt;&gt;;

template&lt;class ... Ts&gt;
auto safe_call(auto fn, auto fmt, Ts ... args)  {
    if constexpr (sizeof...(Ts)) {
        safe_call_helper&lt;FirstType&lt;Ts...&gt;&gt;(fn, fmt, args...);
    }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bhPxaf7Ga">https://godbolt.org/z/bhPxaf7Ga</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
auto safe_call_impl(auto fn, auto fmt, va_list args, auto... ts) {
    if constexpr (N == 0) {
        fn(ts...);
    } else {
        if (*fmt) {
            switch (*fmt) {
                case 'i':
                    return safe_call_impl&lt;N - 1&gt;(fn, fmt + 1, args, ts...,
                                                 va_arg(args, int));
                case 'd':
                    return safe_call_impl&lt;N - 1&gt;(fn, fmt + 1, args, ts...,
                                                 va_arg(args, double));
            }
        } else {
            fn(ts...);
        }
    }
}

auto safe_call(auto fn, auto fmt, ...) {
    std::va_list args{};
    va_start(args, fmt);
    safe_call_impl&lt;3&gt;(fn, fmt, args);
    va_end(args);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8bs8qe4MG">https://godbolt.org/z/8bs8qe4MG</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto safe_call(auto fn, std::string_view fmt, ...) -&gt; decltype(auto) {
  std::va_list args;
  va_start(args, fmt);

  using namespace boost::mp11;

  return mp_with_index&lt;4&gt;(
      std::size(fmt), [&amp;]&lt;auto N&gt;(mp_size_t&lt;N&gt;) -&gt; decltype(auto) {
        mp_repeat_c&lt;std::tuple&lt;std::variant&lt;int, double&gt;&gt;, N&gt; t;

        mp_for_each&lt;mp_iota_c&lt;N&gt;&gt;([&amp;]&lt;auto I&gt;(mp_size_t&lt;I&gt;) {
          switch (fmt[I]) {
            case 'i':
              std::get&lt;I&gt;(t) = va_arg(args, int);
              break;
            case 'd':
              std::get&lt;I&gt;(t) = va_arg(args, double);
              break;
          }
        });

        va_end(args);

        return std::apply(
            [&amp;](const auto &amp;...vars) -&gt; decltype(auto) {
              return std::visit(fn, vars...);
            },
            t);
      });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bvWq9vEna">https://godbolt.org/z/bvWq9vEna</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto safe_call(auto fn, auto fmt, ...) {
    std::va_list args;
    va_start(args, fmt);
    std::stringstream sout;
    while(*fmt != '\0') {
        if (*fmt=='d')
            fn(va_arg(args, double));
        if (*fmt =='i')
            fn(va_arg(args, int));
        fmt++;
    }
    va_end(args);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TbYrEcPfG">https://godbolt.org/z/TbYrEcPfG</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto safe_call(auto fn, auto fmt, auto... args){

    auto safe_check = [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;){
        auto type_check = [](char type, auto arg){
            if( type == 'i'){
                return std::is_convertible_v&lt;decltype(arg),int&gt;;
            }else if( type == 'd'){
                return std::is_convertible_v&lt;decltype(arg),float&gt;;
            }
            return false;
        };
        return (true &amp;&amp; ... &amp;&amp; type_check(fmt[Ns],args));
    }(std::make_index_sequence&lt;sizeof...(args)&gt;{});

    if(safe_check)
    {
        return fn(args...);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5foWccqee">https://godbolt.org/z/5foWccqee</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>304 - Did you know that tuple can be implement just with lambdas?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/304.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/304.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that tuple can be implement just with lambdas?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/tuple">https://eel.is/c++draft/tuple</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto tuple = [][[nodiscard]](auto... args) {
    return [=][[nodiscard]](auto fn)  { return fn(args...); };
};

constexpr auto apply(auto fn, auto t) { return t(fn); };

static_assert(0 == apply([](auto... args) { return sizeof...(args); }, tuple()));
static_assert(1 == apply([](auto... args) { return sizeof...(args); }, tuple(1)));
static_assert(2 == apply([](auto... args) { return sizeof...(args); }, tuple(1, 2)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xTf9nMqPY">https://godbolt.org/z/xTf9nMqPY</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement get by number/type for lambda based tuple?</strong></p>
</li>
<li>
<p>Double points for not using std::tuple!</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto tuple = [][[nodiscard]](auto... args) {
    return [=][[nodiscard]](auto fn)  { return fn(args...); };
};

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t); // TODO
template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t); // TODO

static_assert(1 == get&lt;0&gt;(tuple(1, 2, 3)));
static_assert(2 == get&lt;1&gt;(tuple(1, 2, 3)));
static_assert(3 == get&lt;2&gt;(tuple(1, 2, 3)));

static_assert('a' == get&lt;0&gt;(tuple('a', 42, 77.)));
static_assert(42 == get&lt;1&gt;(tuple('a', 42, 77.)));
static_assert(77. == get&lt;2&gt;(tuple('a', 42, 77.)));

static_assert(42 == get&lt;int&gt;(tuple('a', 42, 77.)));
static_assert(77. == get&lt;double&gt;(tuple('a', 42, 77.)));
static_assert('a' == get&lt;char&gt;(tuple('a', 42, 77.)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jcsj51MG3">https://godbolt.org/z/jcsj51MG3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;type_traits&gt;
#include &lt;utility&gt;

template&lt;::std::size_t N, class ... Args&gt;
struct nth_type ;

template&lt;class T, class ... Args&gt;
struct nth_type&lt;0, T, Args...&gt; : ::std::type_identity&lt;T&gt; {};

template&lt;::std::size_t N, class T, class ... Args&gt;
struct nth_type&lt;N, T, Args...&gt; : nth_type&lt;N-1, Args...&gt; {};

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t)
{
    auto func = []&lt;class ... Args&gt;  (Args ... args)  {
        typename nth_type&lt;N, Args...&gt;::type result;
        auto impl = [Count = 0] (auto input, auto &amp; result) mutable {
            if (Count == N) {
                result = input;
            }
            ++Count;
        };
        (impl(args, result), ...);
        return result;
    };
    return t(func);
}

template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t)
{
    auto func = []&lt;class ... Args&gt;  (Args ... args)  {
        T result;
        auto impl = [has_val = false]&lt;class Arg&gt; (Arg input, auto &amp; result) mutable {
            if (::std::is_same_v&lt;T, Arg&gt; &amp;&amp; not has_val) {
                result = input;
                has_val = true;
            }
        };
        (impl(args, result), ...);
        return result;
    };
    return t(func);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/be7YTW5P5">https://godbolt.org/z/be7YTW5P5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-c++">namespace detail {
template &lt;std::size_t N, typename T&gt; struct elem_by_index { T &amp;ref; };
template &lt;typename T&gt; struct elem_by_type { T &amp;ref; };
} // namespace detail

template &lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t([]&lt;typename... Ts&gt;(Ts... elems) {
        return [&amp;]&lt;std::size_t... Is&gt;(std::index_sequence&lt;Is...&gt;) {
            struct all_elems : detail::elem_by_index&lt;Is, Ts&gt;... {};
            return []&lt;typename U&gt;(const detail::elem_by_index&lt;N, U&gt; &amp;elem) {
                return elem.ref;
            }(all_elems{elems...});
        }(std::index_sequence_for&lt;Ts...&gt;{});
    });
}

template &lt;class T&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t([]&lt;typename... Ts&gt;(Ts... elems) {
        struct all_elems : detail::elem_by_type&lt;Ts&gt;... {};
        return [](const detail::elem_by_type&lt;T&gt; &amp;elem) {
            return elem.ref;
        }(all_elems{elems...});
    });
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qnY6WdYY9">https://godbolt.org/z/qnY6WdYY9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;class T, std::size_t&gt;
struct tag {
  T value;
};

constexpr auto get(auto visitor) {
  return [=]&lt;class... Ts&gt;(Ts... args) {
    return [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
      struct : tag&lt;Ts, Ns&gt;... {
      } values{{.value = args}...};

      return visitor(values);
    }(std::index_sequence_for&lt;Ts...&gt;{});
  };
}

}  // namespace detail

template &lt;std::size_t N&gt;
[[nodiscard]] constexpr auto get(auto t) {
  return t(detail::get(
      []&lt;class T&gt;(detail::tag&lt;T, N&gt; &amp;element) { return element.value; }));
}

template &lt;class T&gt;
[[nodiscard]] constexpr auto get(auto t) {
  return t(detail::get(
      []&lt;auto N&gt;(detail::tag&lt;T, N&gt; &amp;element) { return element.value; }));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hb8W7z3YW">https://godbolt.org/z/hb8W7z3YW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N, auto I&gt;
requires (I &lt;= N)
constexpr auto get_by_index(auto first, auto... rest) {
    if constexpr (I == N) {
        return first;
    } else {
        return get_by_index&lt;N, I + 1&gt;(rest...);
    }
};

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t([](auto... args) {
        return get_by_index&lt;N, 0&gt;(args...);
    });
}

template &lt;class T&gt;
constexpr auto get_by_type(auto first, auto... rest) {
    if constexpr (std::is_same&lt;T, decltype(first)&gt;()) {
        return first;
    } else {
        return get_by_type&lt;T&gt;(rest...);
    }
};

template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t([](auto... args) {
        return get_by_type&lt;T&gt;(args...);
    });
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s3qrPv9GG">https://godbolt.org/z/s3qrPv9GG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto ignore_first = [][[nodiscard]](auto first, auto... args) {
    return [=][[nodiscard]](auto fn)  { return fn(args...); };
};

constexpr auto get_first = [][[nodiscard]](auto first, auto... args) {
    return first;
};

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) {
    if constexpr (N == 0){
        return t(get_first);
    }else{
        return get&lt;N-1&gt;(t(ignore_first));
    }
};

template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t){
    if constexpr(std::is_same_v&lt;T,decltype(t(get_first))&gt;){
        return t(get_first);
    }else{
        return get&lt;T&gt;(t(ignore_first));
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TP31x6xca">https://godbolt.org/z/TP31x6xca</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
struct any {
    T value{};
};

constexpr auto indicies = [](auto fn) {
    return [fn]&lt;class... Ts&gt;(Ts... args) {
        return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
            struct : any&lt;Ts, Ns&gt;... {
            } _{args...};
            return fn(_);
        }(std::make_index_sequence&lt;sizeof...(args)&gt;{});
    };
};

template &lt;auto N&gt;
[[nodiscard]] constexpr auto get(auto t) {
    return t(indicies([]&lt;class T&gt;(any&lt;T, N&gt;&amp; t) { return t.value; }));
}

template &lt;class T&gt;
[[nodiscard]] constexpr auto get(auto t) {
    return t(indicies([]&lt;auto N&gt;(any&lt;T, N&gt;&amp; t) { return t.value; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YbMbrGWdn">https://godbolt.org/z/YbMbrGWdn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_index = [](auto arg1, auto... args) {
    if constexpr(N == 0) {
        return arg1;
    }
    else {
        return nth_index&lt;N-1&gt;(args...);
    }
};

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t(nth_index&lt;N&gt;);
}

template&lt;typename T&gt;
constexpr auto Tth_type = [](auto arg1, auto... args) {
    if constexpr(std::is_same_v&lt;decltype(arg1),T&gt;) {
        return arg1;
    }
    else {
        return Tth_type&lt;T&gt;(args...);
    }
};

template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t) {
    return t(Tth_type&lt;T&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/so3q8a67h">https://godbolt.org/z/so3q8a67h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
auto getNth = [](auto t, auto...ts) {
    if constexpr(N==0)
        return t;
    else
        return getNth&lt;N-1&gt;(ts...);
};

template&lt;typename T&gt;
auto getT = [](auto t, auto...ts) {
    if constexpr( std::is_same_v&lt;T, decltype(t)&gt; )
        return t;
    else
        return getT&lt;T&gt;(ts...);
};


template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) { return t(getNth&lt;N&gt;); }
template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t) { return t(getT&lt;T&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YvcavT8E9">https://godbolt.org/z/YvcavT8E9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto apply(auto fn, auto t) { return t(fn); };

template &lt;typename T, std::size_t N&gt;
struct enumerated {
    T value{};
};

constexpr auto get_by(auto fn) {
    return [=]&lt;typename... Ts&gt;(Ts... args) {
        return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
            struct _ : enumerated&lt;decltype(args), Ns&gt;... {
            } args_and_ns{args...};

            return fn(args_and_ns);
        }(std::make_index_sequence&lt;sizeof...(args)&gt;{});
    };
};

template &lt;std::size_t N&gt;
[[nodiscard]] constexpr auto get(auto t) {
    return apply(get_by([]&lt;typename T&gt;(enumerated&lt;T, N&gt;&amp; t) { return t.value; }), t);
}

template &lt;typename T&gt;
[[nodiscard]] constexpr auto get(auto t) {
    return apply(get_by([]&lt;std::size_t N&gt;(enumerated&lt;T, N&gt;&amp; t) { return t.value; }), t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G4zToq8K">https://godbolt.org/z/G4zToq8K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t N&gt; struct any { T value{}; };

template&lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t){
    return t([](auto... args) {
        return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
            struct : any&lt;decltype(args), Ns&gt;... { } _{args...};
            return []&lt;class K&gt;(any&lt;K, N&gt;&amp; x) { return x.value; }(_);
        }
        (std::make_index_sequence&lt;sizeof...(args)&gt;{});
     });
}

template&lt;class T&gt; [[nodiscard]] constexpr auto get(auto t){
    return t([](auto... args) {
        return (... + [](auto x){
            if constexpr(std::is_same_v&lt;T, decltype(x)&gt;) return x;
            else return 0;
        }(args));
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rhMheWYhd">https://godbolt.org/z/rhMheWYhd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt; [[nodiscard]] constexpr auto get(auto t) {
  return t([](auto... args) {
    return [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return [](decltype((void*)Ns)..., auto* nth, auto*...) {
          return *nth;
        }(&amp;args...);
    }(std::make_index_sequence&lt;N&gt;());
  });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a7GrWPz8j">https://godbolt.org/z/a7GrWPz8j</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>303 - Did you about typename erasure technique to reduce compilation times with templates?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/303.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/303.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you about typename erasure technique to reduce compilation times with templates?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/#temp">https://eel.is/c++draft/#temp</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto...&gt; struct long_type {};

using long_type_t = decltype(
    []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return long_type&lt;Ns...&gt;{};
    }
    (std::make_index_sequence&lt;42&gt;{})
);

// typename erasure
struct short_type_t : long_type_t{};

// generic typename erasure
template&lt;class T&gt; using typename_erasure = decltype([] {
    struct s : T { using T::T; }; // generated in the compiler as `$0::s` or similar
    return s{};
}());

int main() {
    assert(std::string_view{typeid(long_type_t).name()}.size() &gt; 100); // long...
    assert(std::string_view{typeid(short_type_t).name()}.size() &lt; 15); // short
    assert(std::string_view{typeid(typename_erasure&lt;long_type_t&gt;).name()}.size() &lt; 25); // short
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/heaKzY7To">https://godbolt.org/z/heaKzY7To</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement typename_erasure function which will erase all given types?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] constexpr auto typename_erasure; // TODO


template&lt;auto... Ns&gt; struct long_type{ };
template&lt;auto N&gt; using long_type_t = decltype(
    []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
        return long_type&lt;Ns...&gt;{};
    }
    (std::make_index_sequence&lt;N&gt;{})
);

#include &lt;string_view&gt;
#include &lt;typeinfo&gt;
[[nodiscard]] consteval auto type_name(auto) { return std::string_view{__PRETTY_FUNCTION__}; }

static_assert(std::size(type_name(typename_erasure&lt;long_type_t&lt;100&gt;, long_type_t&lt;200&gt;&gt;())) &lt; 42);
static_assert(not std::is_base_of_v&lt;long_type_t&lt;300&gt;, decltype(typename_erasure&lt;long_type_t&lt;100&gt;, long_type_t&lt;200&gt;&gt;())&gt;);
static_assert(std::is_base_of_v&lt;long_type_t&lt;100&gt;, decltype(typename_erasure&lt;long_type_t&lt;100&gt;, long_type_t&lt;200&gt;&gt;())&gt;);
static_assert(std::is_base_of_v&lt;long_type_t&lt;200&gt;, decltype(typename_erasure&lt;long_type_t&lt;100&gt;, long_type_t&lt;200&gt;&gt;())&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zhd716b3T">https://godbolt.org/z/zhd716b3T</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] constexpr auto typename_erasure()
{
    struct s : Ts... {
        s() = default;
        s(Ts &amp;&amp;...arg) : Ts(::std::forward&lt;Ts&gt;(arg)) ... {}
    };
    return s{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xjoe54Mxh">https://godbolt.org/z/xjoe54Mxh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] constexpr auto typename_erasure(){
    struct s : public Ts...{};
    return s{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e1zPh5GGs">https://godbolt.org/z/e1zPh5GGs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; using typename_erasure_one = decltype([] {
    struct s : T { using T::T; };
    return s{};
}());

template&lt;class... Ts&gt;
[[nodiscard]] constexpr auto typename_erasure = [] {
    struct a : typename_erasure_one&lt;Ts&gt;...{};
    return a{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8hxM5h7a5">https://godbolt.org/z/8hxM5h7a5</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>302 - Did you now that with concepts you can override a type?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/302.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/302.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you now that with concepts you can override a type?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/temp.concept#def:concept">https://eel.is/c++draft/temp.concept#def:concept</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; struct foo  {
  static constexpr auto value = N;
};
static_assert(42 == foo&lt;42&gt;::value);

template&lt;auto N&gt;
  requires true // override -&gt; more specialized
struct foo&lt;N&gt; {
  static constexpr auto value = 0;
};
static_assert(42 == foo&lt;42&gt;::value); // memoized
static_assert(0 == foo&lt;43&gt;::value);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hPcsKG4an">https://godbolt.org/z/hPcsKG4an</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you override std::shared_ptr to avoid thred-safe guards?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;memory&gt;

// TODO override shared_ptr with std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt; which is is not thread-safe
// NOTE overriding STL is UB
// Alternative - boost::local_shared_ptr

#include &lt;type_traits&gt;
static_assert(std::is_base_of_v&lt;std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt;, std::shared_ptr&lt;int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7axP5or3q">https://godbolt.org/z/7axP5or3q</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace std {
    template&lt;class T&gt; requires ::std::is_same_v&lt;T, int&gt;
    class shared_ptr&lt;T&gt; : public __shared_ptr&lt;int, __gnu_cxx::_S_single&gt; {};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mhj1M7Yec">https://godbolt.org/z/Mhj1M7Yec</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace std {
template &lt;class T&gt;
    requires std::is_integral_v&lt;T&gt;
class shared_ptr&lt;T&gt; : public __shared_ptr&lt;int, __gnu_cxx::_S_single&gt; {};
}  // namespace std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sa9a937of">https://godbolt.org/z/sa9a937of</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace boost{
    template&lt;typename N&gt; requires std::is_same_v&lt;int,N&gt;
    struct shared_ptr&lt;N&gt; : std::__shared_ptr&lt;N, __gnu_cxx::_S_single&gt; {
    };
}

static_assert(std::is_base_of_v&lt;std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt;, boost::shared_ptr&lt;int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/acWKbG4fG">https://godbolt.org/z/acWKbG4fG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace std{
    template&lt;typename N&gt; requires is_same_v&lt;int,N&gt;
    struct shared_ptr&lt;N&gt; : std::__shared_ptr&lt;N, __gnu_cxx::_S_single&gt; {
    };
}

static_assert(std::is_base_of_v&lt;std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt;, std::shared_ptr&lt;int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z7YznT45n">https://godbolt.org/z/z7YznT45n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
concept integral = std::is_integral_v&lt;T&gt;;

namespace std{
    template&lt;integral T&gt;
    class shared_ptr&lt;T&gt; : public std::__shared_ptr&lt;T, __gnu_cxx::_S_single&gt;{
    };
}

#include &lt;type_traits&gt;
static_assert(std::is_base_of_v&lt;std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt;, std::shared_ptr&lt;int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PP6KEczMb">https://godbolt.org/z/PP6KEczMb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
requires true
class std::shared_ptr&lt;T&gt; : std::__shared_ptr&lt;T, __gnu_cxx::_S_single&gt; {
};

#include &lt;type_traits&gt;
static_assert(std::is_base_of_v&lt;std::__shared_ptr&lt;int, __gnu_cxx::_S_single&gt;, std::shared_ptr&lt;int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rrr8GP3qe">https://godbolt.org/z/rrr8GP3qe</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>301 - Did you now that functions in `&lt;charconv&gt;` are constexpr since C++23?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/301.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/301.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you now that functions in <code>&lt;charconv&gt;</code> are constexpr since C++23?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2291">https://wg21.link/P2291</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">consteval auto to_number(auto str) {
    int value;{}
    std::from_chars(std::cbegin(str), std::cend(str), value);
    return value;
}
static_assert(42 == to_number(std::string_view{&quot;42&quot;}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1fKhGd4Y7">https://godbolt.org/z/1fKhGd4Y7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement to_string which converts number to an array by applying constexpr to_chars?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value);

static_assert(std::array{'0', '0', '0', '1'} == to_string(1));
static_assert(std::array{'0', '0', '4', '2'} == to_string(42));
static_assert(std::array{'1', '2', '3', '4'} == to_string(1234));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cE3crocaK">https://godbolt.org/z/cE3crocaK</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value){
    std::array&lt;char, 4&gt; result {'0','0','0','0'};
    auto [ptr, _] = std::to_chars(result.begin(), result.end(), value);
    ::std::rotate(result.begin(), ptr, result.end());
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7oPKMGnsj">https://godbolt.org/z/7oPKMGnsj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(std::integral auto value)
    requires(!std::is_same_v&lt;decltype(value), bool&gt;)
 {
    std::array&lt;char, 4&gt; arr{'0', '0', '0'};  // at least 1 character is filled
    if (value &gt;= 10000 ||
        std::errc{} != std::to_chars(
            arr.data() + (value &lt; 1000) + (value &lt; 100) + (value &lt; 10),
            arr.data() + 4, value
        ).ec)
        throw;
    return arr;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1svYsaMd3">https://godbolt.org/z/1svYsaMd3</a></p>
</blockquote>
</details></p>
<p><code>cpp
template &lt;int N = 4&gt;
[[nodiscard]] consteval auto to_string(auto value) {
    std::array&lt;char, N&gt; res{};
    std::fill_n(std::begin(res), N, '0');
    if (auto [ptr, ec] = std::to_chars(std::begin(res), std::end(res), value);
        ec == std::errc{}) {
        std::rotate(std::begin(res), ptr, std::end(res));
    }
    return res;
}</code></p>
<blockquote>
<p><a href="https://godbolt.org/z/anffMq6qf">https://godbolt.org/z/anffMq6qf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value){
    constexpr size_t N = 4;
    char buf[N] = {'0','0','0','0'};
    std::array&lt;char,N&gt; return_val{'0','0','0','0'};
    const std::to_chars_result res = std::to_chars(buf, buf + N, value);
    if (res.ec == std::errc{})
    {
        const auto num_chars = static_cast&lt;int&gt;(res.ptr - buf);
        const auto starting_offset = N-num_chars;
        for (size_t i = 0; i &lt; num_chars; i++){
            return_val.at(starting_offset + i) = buf[i];
        }
    }
    return return_val;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ohsvvaYjf">https://godbolt.org/z/ohsvvaYjf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value){
    constexpr auto total_digits = 4;
    std::array&lt;char, total_digits&gt; result{'0', '0', '0', '0'};

    const auto num_digits = std::floor(std::log10(value) + 1);
    const int offset = total_digits - num_digits;

    std::to_chars(std::data(result) + offset, std::data(result) + std::size(result), value);
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5cq7vPceT">https://godbolt.org/z/5cq7vPceT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value) {
    std::array&lt;char, 4&gt; arr;
    for(int i=0, d=1000; i&lt;4; i++, d/=10) {
        arr[i] = value/d + '0';
        value -= (arr[i]-'0') * d;
    }
    return arr;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h9b45fd19">https://godbolt.org/z/h9b45fd19</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value){
    constexpr auto size = 4;
    std::array&lt;char, size&gt; chars{};

    for(auto i=size-1; i&gt;=0; --i){
        chars[i] = value%10 +'0';
        value = value /10;
    }

    return chars;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9Pnqq7W6j">https://godbolt.org/z/9Pnqq7W6j</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(const auto value) {
  std::array&lt;char, 4&gt; out;
  const auto end_num = std::to_chars(out.begin(), out.end(), value).ptr;
  const auto end_pad =
      std::copy(std::reverse_iterator{end_num}, out.rend(), out.rbegin());
  std::fill(end_pad, out.rend(), '0');
  return out;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MTo14GxE4">https://godbolt.org/z/MTo14GxE4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(const auto value) {
  auto out = std::array{'0', '0', '0', '0'};
  auto ec = std::errc::value_too_large;

  for (auto first = out.end(), last = out.end();
       ec == std::errc::value_too_large; --first) {
    ec = std::to_chars(first, last, value).ec;
  }

  return out;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x8xGqYW7h">https://godbolt.org/z/x8xGqYW7h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto value){
    const size_t digits = floor( log( value ) / log(10) ) + 1;
    std::array&lt;char,4&gt; v{'0','0','0','0'};
    auto [ptr, ec] = std::to_chars(v.data()+v.size()-digits, v.data()+v.size(), value);
    return v;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TM87MaPjb">https://godbolt.org/z/TM87MaPjb</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>300 - Did you know that C++23 added support for constexpr std::bitset?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/300.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/300.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added support for constexpr std::bitset?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/bitset">https://eel.is/c++draft/bitset</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;bitset&gt;

constexpr std::bitset&lt;4&gt; b1{&quot;0011&quot;};
static_assert(0b0011 == b1.to_ulong());

constexpr std::bitset&lt;4&gt; b2{0b0011};
static_assert(b1 == b2);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vo13Kf9Er">https://godbolt.org/z/vo13Kf9Er</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement consteval <code>to_string</code> which converts bitset to its string representation?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto bitset); // TODO

static_assert(std::string_view{&quot;0&quot;} != to_string(std::bitset&lt;1&gt;{&quot;1&quot;}));
static_assert(std::string_view{&quot;01&quot;} != to_string(std::bitset&lt;1&gt;{&quot;10&quot;}));
static_assert(std::string_view{&quot;111&quot;} != to_string(std::bitset&lt;1&gt;{&quot;000&quot;}));

static_assert(std::string_view{&quot;0&quot;} == to_string(std::bitset&lt;1&gt;{&quot;0&quot;}));
static_assert(std::string_view{&quot;1&quot;} == to_string(std::bitset&lt;1&gt;{&quot;1&quot;}));
static_assert(std::string_view{&quot;00&quot;} == to_string(std::bitset&lt;2&gt;{&quot;00&quot;}));
static_assert(std::string_view{&quot;01&quot;} == to_string(std::bitset&lt;2&gt;{&quot;01&quot;}));
static_assert(std::string_view{&quot;10&quot;} == to_string(std::bitset&lt;2&gt;{&quot;10&quot;}));
static_assert(std::string_view{&quot;11&quot;} == to_string(std::bitset&lt;2&gt;{&quot;11&quot;}));
static_assert(std::string_view{&quot;100&quot;} == to_string(std::bitset&lt;3&gt;{&quot;100&quot;}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/od8offTj5">https://godbolt.org/z/od8offTj5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto bitset){ return bitset.to_string(); }; 
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fvMcsrGW9">https://godbolt.org/z/fvMcsrGW9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;std::size_t ix&gt;
[[nodiscard]] consteval auto to_string(std::bitset&lt;ix&gt; bitset, char (&amp;&amp;arr)[ix+1] = {}) {
    for (std::size_t i{}; i &lt; bitset.size(); ++i)
        arr[i] = '0' + bitset.test(bitset.size() - 1 - i);
    return arr;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o51cY3bzh">https://godbolt.org/z/o51cY3bzh</a></p>
</blockquote>
<p>```cpp<br />
 template <std::size_t N><br />
[[nodiscard]] consteval auto to_string(std::bitset<N> bitset, char (&amp;&amp;arr)[N + 1] = {}) <br />
{<br />
    [&amp;]<std::size_t... I>(std::index_sequence<I...>) {<br />
        ((arr[I] = bitset.test(bitset.size() - 1 - I) ? '1' : '0'), ...);<br />
    }(std::make_index_sequence<N>{});</p>
<pre class="codehilite"><code>return arr;
</code></pre>

<p>}<br />
 ```</p>
<blockquote>
<p><a href="https://godbolt.org/z/W9Y6zbbMT">https://godbolt.org/z/W9Y6zbbMT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto bitset){
    return bitset.to_string();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/odjMYz9hd">https://godbolt.org/z/odjMYz9hd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t N&gt;
[[nodiscard]] consteval auto to_string(std::bitset&lt;N&gt; bitset) {
  return [&amp;]&lt;std::size_t... Is&gt;(std::index_sequence&lt;Is...&gt;) -&gt; std::string {
    return {(bitset.test(N - Is - 1uz) ? '1' : '0')...};
  }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/61bMGbYnh">https://godbolt.org/z/61bMGbYnh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto bit_to_char(auto bitset, std::size_t idx)
{
    if(bitset.test(idx))
        return '1';
    else
        return '0';
}

template&lt;size_t N&gt;
[[nodiscard]] constexpr auto to_string(std::bitset&lt;N&gt; bitset){
    return [&amp;]&lt;size_t... I&gt;(const std::bitset&lt;N&gt;&amp; bits,std::index_sequence&lt;I...&gt;)-&gt;std::string{
        return{(bit_to_char(bits,N-I-1))...};
    }(bitset,std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h5WhYPoaE">https://godbolt.org/z/h5WhYPoaE</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t B&gt;
[[nodiscard]] consteval auto to_string(std::bitset&lt;B&gt; bitset){
    return [&amp;]&lt;size_t... N&gt;(std::index_sequence&lt;N...&gt;) -&gt; std::string {
        constexpr auto bit_value = [](auto bit) -&gt; char { return bit + '0';};
        return {(bit_value(bitset[B-N-1]))...};
    }(std::make_index_sequence&lt;B&gt;());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G4q61zGbx">https://godbolt.org/z/G4q61zGbx</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto to_string(auto bitset) {
    return [&amp;]&lt;typename T, T...ints&gt;(std::integer_sequence&lt;T, ints...&gt;) {
        char a[] = { (bitset[sizeof...(ints) - ints -1] ? '1' : '0') ... }; 
        return std::string(a, sizeof...(ints));
    }(std::make_index_sequence&lt;bitset.size()&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EMW4rYnKP">https://godbolt.org/z/EMW4rYnKP</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>299 - Did you know that C++20 concepts can be used to avoid implicit conversions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/299.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/299.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 concepts can be used to avoid implicit conversions?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/concept.same">https://eel.is/c++draft/concept.same</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

void foo(int i);
void bar(std::same_as&lt;int&gt; auto i);


int main() {
  foo(42.0); // implicit conversion
  bar(42.0); // error: contraint not satisifed
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v45nYdaT7">https://godbolt.org/z/v45nYdaT7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement conversion safe <code>invoke[args...]</code>?</strong></p>
</li>
<li>
<p>Note: Doesn't allow implicit conversions neither for parameters nor for the return type</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](...); // TODO
} invoke;

auto foo(int, double, float) -&gt; void;

constexpr auto can_invoke_with = []&lt;class R, class... Ts&gt;(R fn(Ts...), auto&amp;&amp;... args) {
  return requires { { invoke.template operator[]&lt;R, Ts...&gt;(fn, std::forward&lt;decltype(args)&gt;(args)...) } -&gt; std::same_as&lt;R&gt;; };
};

static_assert(    can_invoke_with(foo, int{}, double{}, float{}));
static_assert(not can_invoke_with(foo, int{}, float{}, float{}));
static_assert(not can_invoke_with(foo, float{}, float{}, float{}));
static_assert(not can_invoke_with(foo, short{}, int{}, double{}, float{}));
static_assert(not can_invoke_with(foo, int{}, double{}, float{}, float{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vz9sxssE4">https://godbolt.org/z/vz9sxssE4</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](R fn(Ts...), std::same_as&lt;Ts&gt; auto... ts ) -&gt; R;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T4rvx87Wo">https://godbolt.org/z/T4rvx87Wo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">  template&lt;class R, class... Ts, class ...Ts2, ::std::enable_if_t&lt;
    sizeof...(Ts) == sizeof...(Ts2) &amp;&amp;
    (::std::is_same_v&lt;Ts, Ts2&gt; &amp;&amp; ...), int&gt; = 0&gt;
  [[nodiscard]] constexpr auto operator[](R fn(Ts...), Ts2... ts ) -&gt; R;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7fecsaErf">https://godbolt.org/z/7fecsaErf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
  template &lt;class R, class... Ts&gt;
  [[nodiscard]] constexpr auto operator[](R fn(Ts...),
                                          std::same_as&lt;Ts&gt; auto&amp;&amp;... args)
      -&gt; std::same_as&lt;R&gt; decltype(auto) {
    return fn(std::forward&lt;Ts&gt;(args)...);
  }
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cbGrTW74q">https://godbolt.org/z/cbGrTW74q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](R fn(Ts...), std::same_as&lt;Ts&gt; auto&amp;&amp;... args){
        return fn(std::forward&lt;decltype(args)&gt;(args)...);
    }
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/53jaMTK6z">https://godbolt.org/z/53jaMTK6z</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](auto&amp;&amp; fn, std::same_as&lt;Ts&gt; auto&amp;&amp;... args) -&gt; std::same_as&lt;R&gt; auto {
        return fn(std::forward&lt;Ts&gt;(args)...);
    }
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gjv51ev13">https://godbolt.org/z/Gjv51ev13</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](auto fn, std::same_as&lt;Ts&gt;auto ...params) -&gt; std::same_as&lt;R&gt; auto {
        return fn(params...);
    };
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9vMh8sje6">https://godbolt.org/z/9vMh8sje6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](auto F, auto... args) -&gt; std::same_as&lt;R&gt; auto requires (std::same_as&lt;Ts,decltype(args)&gt; &amp;&amp; ...) {
        return F(args...);
    };
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TjbzWd7dT">https://godbolt.org/z/TjbzWd7dT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](R fn(Ts...), std::same_as&lt;Ts&gt; auto&amp;&amp; ... args)-&gt;R;
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bz38Yb3c6">https://godbolt.org/z/bz38Yb3c6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct {
    template&lt;class R, class... Ts&gt;
    [[nodiscard]] constexpr auto operator[](auto f, std::same_as&lt;Ts&gt; auto &amp;&amp;...args){
        f(args...);
    }
} invoke;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MP9nK16xr">https://godbolt.org/z/MP9nK16xr</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>298 - Did you know that C++23 added static operator()?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/298.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/298.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added static operator()?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1169">https://wg21.link/P1169</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct s {
  static constexpr auto operator()() { return 1; }
};
auto l = [] static { return 2; };

static_assert(3 == s{}() + l());

static_assert(3 == s::operator()() +
         decltype(l)::operator()());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/43hhKcr59">https://godbolt.org/z/43hhKcr59</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement count which returns number of types which can be called with static operator()?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto count = 0; // TODO

struct e {};
struct s {
    static constexpr auto operator()() -&gt; void;
};
struct ns {
    constexpr auto operator()() -&gt; void;
};

auto l = [] { };
auto sl = [] static {};

static_assert(0 == count&lt;e&gt;);
static_assert(1 == count&lt;s&gt;);
static_assert(0 == count&lt;ns&gt;);
static_assert(0 == count&lt;decltype(l)&gt;);
static_assert(1 == count&lt;decltype(sl)&gt;);
static_assert(2 == count&lt;e, s, ns, decltype(l), decltype(sl)&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/McrMfasjq">https://godbolt.org/z/McrMfasjq</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-c++">template&lt;class... Ts&gt;
constexpr auto count = (requires { (void*)&amp;Ts::operator(); } + ... + 0);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Td6zxxaoM">https://godbolt.org/z/Td6zxxaoM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-c++">template&lt;class... Ts&gt;
constexpr auto count = (0 + ... + requires{Ts::operator();});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P74br35qh">https://godbolt.org/z/P74br35qh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
constexpr auto count = (... + requires { Ts::operator()(); });
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KoP4sxrxr">https://godbolt.org/z/KoP4sxrxr</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
concept is_static_call_operator = requires{T::operator()();};

template&lt;class... Ts&gt;
constexpr auto count = (0 + ... + is_static_call_operator&lt;Ts&gt;)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TEPKG3xa8">https://godbolt.org/z/TEPKG3xa8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto count =
(0 + ... + requires{Ts::operator()();})
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f1xKoEvKz">https://godbolt.org/z/f1xKoEvKz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto has_static_operator = [](){
    if constexpr (requires { T::operator();}){
        return 1;
    }
    else{
        return 0;
    }
}();

template&lt;class... Ts&gt;
constexpr auto count = [](){
    return 0 + (... + has_static_operator&lt;Ts&gt;);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j3a6o78Wf">https://godbolt.org/z/j3a6o78Wf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
concept HasStaticOp = requires(T) { T::operator(); };

template&lt;class... Ts&gt;
constexpr auto count = (HasStaticOp&lt;Ts&gt; + ...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yz53ebYn9">https://godbolt.org/z/Yz53ebYn9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto count = [] -&gt; int {
    return (requires {Ts::operator()();}+...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ne73vMMPW">https://godbolt.org/z/ne73vMMPW</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>297 - **Did you know that C++20 introduced coroutines?** (co__await)</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/297.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/297.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 introduced coroutines?</strong> (co__await)</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/dcl.fct.def.coroutine#def:coroutine">https://eel.is/c++draft/dcl.fct.def.coroutine#def:coroutine</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct task {
  struct promise_type {
    task get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    template&lt;class T&gt; void return_value(T) {}
    void unhandled_exception() {}
  };
};

template&lt;class T&gt;
class awaiter {
 public:
  auto operator co_await() {
    struct {
      awaiter&amp; aw;

      auto await_ready() const noexcept -&gt; bool { return aw.value; }
      auto await_suspend(std::coroutine_handle&lt;&gt; coroutine) noexcept {
        aw.coroutine = coroutine;
        return true;
      }

      auto await_resume() const noexcept {
        struct reset {
          T&amp; value;
          ~reset() { value = {}; }
        } _{aw.value};
        return aw.value;
      }
    } awaiter{*this};

    return awaiter;
  }

  void process(const T&amp; value) {
    this-&gt;value = value;
    coroutine.resume();
  }

 private:
  T value{};
  std::coroutine_handle&lt;&gt; coroutine{};
};

int main() {
    auto input = awaiter&lt;int&gt;{};
    auto sum = 0;

    const auto await_sum = [](auto&amp; input, auto&amp; sum) -&gt; task {
      for (;;) {
        sum += co_await input;
      }
    };

    [[maybe_unused]] auto _ = await_sum(input, sum);
    input.process(1);
    assert(1 == sum);

    input.process(42);
    assert(43 == sum);

    input.process(-10);
    assert(33 == sum);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fo4j1Mn8Y">https://godbolt.org/z/fo4j1Mn8Y</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a simple parser using co_await?</strong></p>
</li>
<li>
<p>Naive implementation: <a href="https://godbolt.org/z/Mjcj3jbva">https://godbolt.org/z/Mjcj3jbva</a></p>
</li>
</ul>
<p><img alt="parser" src="images/parser.png" /></p>
<pre class="codehilite"><code class="language-cpp">class parser {
 public:
  explicit parser(std::stringstream&amp; out) : out{out} { }

  void parse(std::string_view in) {
    for (const auto value : in) {
       input.process(value);
    }
  }

 private:
  task parse_impl() {
    // TODO
  }

  awaiter&lt;char&gt; input{};
  task start{parse_impl()};
  std::stringstream&amp; out;
};

int main() {
  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;0&quot;);
    assert(&quot;0&quot; == out.str());
  }

  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;01&quot;);
    assert(&quot;00&quot; == out.str());
  }

  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;0110&quot;);
    assert(&quot;0001&quot; == out.str());
  }

  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;0001&quot;);
    assert(&quot;0000&quot; == out.str());
  }

  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;000110&quot;);
    assert(&quot;000001&quot; == out.str());
  }

  {
    std::stringstream out{};
    parser p{out};
    p.parse(&quot;0110100010010001101001000111110010011001&quot;);
    assert(&quot;0001000000000000010000000000001000000100&quot; == out.str());
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6cxdqEno1">https://godbolt.org/z/6cxdqEno1</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct task {
  struct promise_type {
    task get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    template&lt;class T&gt; void return_value(T) { }
    void unhandled_exception() {}
  };
};

template&lt;class T&gt;
class awaiter {
 public:
  auto operator co_await() {
    struct {
      awaiter&amp; aw;

      auto await_ready() const noexcept -&gt; bool { return static_cast&lt;bool&gt;(aw.value); }
      auto await_suspend(std::coroutine_handle&lt;&gt; coroutine) noexcept {
        aw.coroutine = coroutine;
        return true;
      }

      auto await_resume() const noexcept {
        struct reset {
         std::optional&lt;T&gt;&amp; value;
          ~reset() { value = {}; }
        } _{aw.value};
        return *aw.value - '0';
      }
    } awaiter{*this};

    return awaiter;
  }

  void process(const T&amp; value) {
    this-&gt;value = value;
    coroutine.resume();
  }

 private:
  std::optional&lt;T&gt; value{};
  std::coroutine_handle&lt;&gt; coroutine{};
};

class parser {
 public:
  explicit parser(std::stringstream&amp; out) : out{out} { }

  void parse(std::string_view in) {
    for (const auto value : in) {
      input.process(value);
    }
  }

 private:
  task parse_impl() {
    enum state { A, B, C } state;
    for (;;) {
      const auto value = co_await input;
      const auto in = value != 0;
      switch (state) {
          case A:
              out &lt;&lt; '0';
              state = in ? B : A;
              break;
          case B:
              out &lt;&lt; '0';
              state = in ? C : A;
              break;
          case C:
              out &lt;&lt; (in ? '0' : '1');
              state = in ? C : A;
              break;
      };
    }
  }

  awaiter&lt;char&gt; input{};
  task start{parse_impl()};
  std::stringstream&amp; out;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yxc58vrWW">https://godbolt.org/z/Yxc58vrWW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct task {
  struct promise_type {
    task get_return_object() { return {}; }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    template &lt;class T&gt;
    void return_value(T) {}
    void unhandled_exception() {}
  };
};

template &lt;class T&gt;
class awaiter {
 public:
  auto operator co_await() {
    struct {
      awaiter&amp; aw;

      auto await_ready() const noexcept -&gt; bool {
        return static_cast&lt;bool&gt;(aw.value);
      }
      auto await_suspend(std::coroutine_handle&lt;&gt; coroutine) noexcept {
        aw.coroutine = coroutine;
        return true;
      }

      auto await_resume() const noexcept {
        struct reset {
          std::optional&lt;T&gt;&amp; value;
          ~reset() { value = {}; }
        } _{aw.value};
        return *aw.value - '0';
      }
    } awaiter{*this};

    return awaiter;
  }

  void process(const T&amp; value) {
    this-&gt;value = value;
    coroutine.resume();
  }

 private:
  std::optional&lt;T&gt; value{};
  std::coroutine_handle&lt;&gt; coroutine{};
};

class parser {
 public:
  explicit parser(std::stringstream&amp; out) : out{out} {}

  void parse(std::string_view in) {
    for (const auto value : in) {
      input.process(value);
    }
  }

 private:
  task parse_impl() {
    struct data {
      int value;
    };

    using namespace boost::sml;
    front::sm sm = [this] {
      constexpr auto is = [](auto value) {
        return [=](auto e) { return e.value == value; };
      };
      const auto print = [this](auto value) {
        return [=, this] { out &lt;&lt; value; };
      };

      return make_transition_table(
          // clang-format off
         *&quot;0&quot;_s + event&lt;data&gt; [is(1)] / print(0) = &quot;1&quot;_s,
          &quot;0&quot;_s + event&lt;data&gt;         / print(0),
          &quot;1&quot;_s + event&lt;data&gt; [is(1)] / print(0) = &quot;2&quot;_s,
          &quot;1&quot;_s + event&lt;data&gt;         / print(0) = &quot;0&quot;_s,
          &quot;2&quot;_s + event&lt;data&gt; [is(0)] / print(1) = &quot;0&quot;_s,
          &quot;2&quot;_s + event&lt;data&gt;         / print(0)
          // clang-format on
      );
    };

    while (true) {
      sm.process_event(data{.value = co_await input});
    }
  }

  awaiter&lt;char&gt; input{};
  task start{parse_impl()};
  std::stringstream&amp; out;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1fo5q4M4K">https://godbolt.org/z/1fo5q4M4K</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>296 - **Did you know that C++20 introduced coroutines?** (co_yield)</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/296.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/296.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 introduced coroutines?</strong> (co_yield)</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/dcl.fct.def.coroutine#def:coroutine">https://eel.is/c++draft/dcl.fct.def.coroutine#def:coroutine</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct generator {
  struct promise_type final {
    int value;
    generator get_return_object() { return {*this}; }
    constexpr std::suspend_always initial_suspend() noexcept {
      return {};
    }
    constexpr std::suspend_always final_suspend() noexcept {
      return {};
    }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(int value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  constexpr explicit(true) generator(promise_type &amp;promise)
      : coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  int value() const noexcept { return coroutine_.promise().value; }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};

auto generate = [] -&gt; generator {
  for (auto i = 0; ; i++) {
    co_yield i;
  }
};

int main() {
  auto g = generate();
  g.next();
  assert(0 == g.value());

  g.next();
  assert(1 == g.value());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y5v5GWesq">https://godbolt.org/z/Y5v5GWesq</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simple generator using a variadic pack?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class&gt;
struct generator {
 // TODO
};

template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator&lt;/*TODO*/&gt; {
 // TODO
};

constexpr auto sum = [](auto generator) {
  // TODO
  return 0;
};

int main() {
  using namespace boost::ut;

  &quot;coroutine.yield&quot;_test = [] {
    auto g = generate&lt;1, 2&gt;();
    expect(0_i == g.value());
    g.next();
    expect(1_i == g.value());
    g.next();
    expect(2_i == g.value());
  };

  &quot;coroutine.yield.sum&quot;_test = [] {
    expect(1_i == sum(generate&lt;1&gt;()));
    expect(3_i == sum(generate&lt;1, 2&gt;()));
    expect(24_i == sum(generate&lt;9, 8, 7&gt;()));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WKbqorE8r">https://godbolt.org/z/WKbqorE8r</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
struct generator {
  struct promise_type final {
    T value;
    auto get_return_object() -&gt; generator { return generator{*this}; }
    constexpr auto initial_suspend() noexcept -&gt; std::suspend_always {
      return {};
    }
    constexpr auto final_suspend() noexcept -&gt; std::suspend_always {
      return {};
    }
    constexpr auto unhandled_exception() noexcept -&gt; void {}
    auto yield_value(int value) noexcept -&gt; std::suspend_always {
      this-&gt;value = value;
      return {};
    }
  };

  constexpr explicit(true) generator(promise_type &amp;promise)
    : coroutine_{std::coroutine_handle&lt;promise_type&gt;::from_promise(promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  auto value() const noexcept -&gt; T { return coroutine_.promise().value; }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};

template &lt;auto... Ids&gt;
auto generate = [] -&gt; generator&lt;std::common_type_t&lt;decltype(Ids)...&gt;&gt; {
  (co_yield Ids, ...);
};

constexpr auto sum = [] (auto gen) {
  auto s = gen.value();
  while (gen.next()) {
    s += gen.value();
  };
  return s;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f6GGW6zrK">https://godbolt.org/z/f6GGW6zrK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
struct generator {
  struct promise_type final {
    T value;
    generator get_return_object() { return generator{*this}; }
    constexpr std::suspend_always initial_suspend() noexcept { return {}; }
    constexpr std::suspend_always final_suspend() noexcept { return {}; }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(T value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  constexpr explicit(true) generator(promise_type &amp;promise)
      : coroutine_{std::coroutine_handle&lt;promise_type&gt;::from_promise(promise)} {
  }
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  T value() const noexcept { return coroutine_.promise().value; }

 private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};

template &lt;auto... Ids&gt;
auto generate = [] -&gt; generator&lt;int&gt; { (..., co_yield Ids); };

constexpr auto sum = [](auto generator) {
  auto acc = decltype(generator.value()){};
  while (generator.next()) acc += generator.value();
  return acc;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/36McnK937">https://godbolt.org/z/36McnK937</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class&gt;
struct generator {
  struct promise_type final {
    int value;
    generator get_return_object() { return {*this}; }
    constexpr std::suspend_always initial_suspend() noexcept {
      return {};
    }
    constexpr std::suspend_always final_suspend() noexcept {
      return {};
    }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(int value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  generator(promise_type &amp;promise)
      : coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  int value() const noexcept { return coroutine_.promise().value; }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};

template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator&lt;class T&gt; {
  (co_yield Ids, ...);
};

constexpr auto sum = [](auto generator) {
  int s{};
  while (generator.next()) {
      s += generator.value();
  }
  return s;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a1vr96x7e">https://godbolt.org/z/a1vr96x7e</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Ids&gt;
struct generator {
  struct promise_type final {
    int value;
    generator get_return_object() { return {*this}; }
    constexpr std::suspend_always initial_suspend() noexcept {
      return {};
    }
    constexpr std::suspend_always final_suspend() noexcept {
      return {};
    }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(int value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  constexpr generator(promise_type &amp;promise)
      : ids_array_{{Ids...}}, coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    inited = true;
    coroutine_.resume();
    return not coroutine_.done();
  }

  int value() const noexcept {
      return (inited) ? ids_array_[coroutine_.promise().value] : 0;
  }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
  std::array&lt;int,sizeof...(Ids)&gt; ids_array_;
  bool inited{};
};

template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator&lt;Ids...&gt; {
 int cnt{};
 while( cnt &lt; sizeof...(Ids) )
 {
   co_yield cnt;
   cnt++;
 }
};

constexpr auto sum = [](auto generator) {
  int summed_val{};
  while(generator.next())
  {
    summed_val += generator.value();
  }
  return summed_val;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y56G9dxPP">https://godbolt.org/z/Y56G9dxPP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class&gt;
struct generator {
  struct promise_type final {
    int value;
    generator get_return_object() { return {*this}; }
    constexpr std::suspend_always initial_suspend() noexcept {
      return {};
    }
    constexpr std::suspend_always final_suspend() noexcept {
      return {};
    }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(int value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  generator(promise_type &amp;promise)
      : coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  int value() const noexcept { return coroutine_.promise().value; }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};

template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator&lt;int&gt; {
  (..., co_yield Ids);
};

constexpr auto sum = [](auto generator) {
  int total{};

  while(generator.next()){
      total += generator.value();
  }

  return total;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/45jE73sza">https://godbolt.org/z/45jE73sza</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct generator {
    struct promise_type final {
        int value = 0;
        generator get_return_object() { return {*this}; }
        constexpr std::suspend_always initial_suspend() noexcept {
            return {};
        }
        constexpr std::suspend_always final_suspend() noexcept {
           return {};
        }
        constexpr void return_void() noexcept {}
        constexpr void unhandled_exception() noexcept {}
        std::suspend_always yield_value(int value) noexcept {
            this-&gt;value = value;
            return {};
        }
    };

    generator(promise_type &amp;promise)
      : coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
    ~generator() noexcept { coroutine_.destroy(); }

    auto next() noexcept {
        coroutine_.resume();
        return not coroutine_.done();
    }

    int value() const noexcept { return coroutine_.promise().value; }

private:
    std::coroutine_handle&lt;promise_type&gt; coroutine_;
};


template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator {
    std::array&lt;int, sizeof...(Ids)&gt; vals = {Ids...};
    for (int i=0; i&lt;sizeof...(Ids); i++)
        co_yield vals[i];
};

constexpr auto sum = [](auto generator) {
    int sum = 0;
    while(generator.next())
        sum += generator.value();
    return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h5q19efj5">https://godbolt.org/z/h5q19efj5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class&gt;
struct generator {
  struct promise_type final {
    int value;
    generator get_return_object() { return {*this}; }
    constexpr std::suspend_always initial_suspend() noexcept {
      return {};
    }
    constexpr std::suspend_always final_suspend() noexcept {
      return {};
    }
    constexpr void return_void() noexcept {}
    constexpr void unhandled_exception() noexcept {}
    std::suspend_always yield_value(int value) noexcept {
      this-&gt;value = value;
      return {};
    }
  };

  generator(promise_type &amp;promise)
      : coroutine_{
            std::coroutine_handle&lt;promise_type&gt;::from_promise(
                promise)} {}
  ~generator() noexcept { coroutine_.destroy(); }

  auto next() noexcept {
    coroutine_.resume();
    return not coroutine_.done();
  }

  int value() const noexcept { return coroutine_.promise().value; }

private:
  std::coroutine_handle&lt;promise_type&gt; coroutine_;
};


template &lt;auto... Ids&gt;
auto generate = []() -&gt; generator&lt;int&gt; {
    [](...){}(((co_yield Ids), 0)...);
};

constexpr auto sum = [](auto generator) {
  auto i = 0;
  while(generator.next()){
      i+= generator.value();
  }
  return i;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/63oWK163Y">https://godbolt.org/z/63oWK163Y</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct [[nodiscard]] Generator {
    struct promise_type {
        auto get_return_object() noexcept { return Generator{*this}; }
        std::suspend_always initial_suspend() const noexcept { return {}; }
        std::suspend_always final_suspend() const noexcept { return {}; }
        std::suspend_always yield_value(const T&amp; value) noexcept {
            result = std::addressof(value);
            return {};
        }

        void return_void() const noexcept {}

        void unhandled_exception() noexcept(
            std::is_nothrow_copy_constructible_v&lt;std::exception_ptr&gt;) {
            result = std::current_exception();
        }

        bool is_value_initialized() const noexcept {
            return !std::holds_alternative&lt;std::monostate&gt;(result);
        }

        const T&amp; get_value() { return *std::get&lt;const T*&gt;(result); }

        bool has_exception() const noexcept {
            return std::holds_alternative&lt;std::exception_ptr&gt;(result);
        }

        void throw_if_exception() const {
            if (has_exception()) {
                std::rethrow_exception(std::get&lt;std::exception_ptr&gt;(result));
            }
        }

       private:
        std::variant&lt;std::monostate, const T*, std::exception_ptr&gt; result;
    };

    struct Iterator {
        using iterator_category = std::input_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = T;
        using reference = T&amp;;
        using pointer = T*;

        Iterator() noexcept = default;
        explicit Iterator(
            const std::coroutine_handle&lt;promise_type&gt;&amp; coro) noexcept
            : coro{&amp;coro} {}

        friend bool operator==(const Iterator&amp;,
                               const Iterator&amp;) noexcept = default;

        Iterator&amp; operator++() {
            assert(coro != nullptr);
            assert(!coro-&gt;done());

            coro-&gt;resume();
            if (coro-&gt;done()) {
                auto coro_handle = std::exchange(coro, nullptr);
                coro_handle-&gt;promise().throw_if_exception();
            }
            return *this;
        }

        auto&amp; operator*() const noexcept {
            assert(coro != nullptr);
            assert(!coro-&gt;done());

            return coro-&gt;promise().get_value();
        }

       private:
        const std::coroutine_handle&lt;promise_type&gt;* coro;
    };

    ~Generator() {
        if (coro) {
            coro.destroy();
        }
    }

    auto&amp; value() const {
        return coro.promise().get_value();
    }

    bool next() const noexcept {
        coro.resume();
        return !coro.done() || coro.promise().has_exception();
    }

    Iterator begin() const {
        if (coro.done()) {
            return end();
        }

        auto i = Iterator{coro};
        if (!coro.promise().is_value_initialized()) {
            ++i; // can throw
        }
        return i;
    }

    Iterator end() const noexcept {
        return {};
    }

   private:
    explicit Generator(promise_type&amp; promise) noexcept
        : coro{decltype(coro)::from_promise(promise)} {}

    std::coroutine_handle&lt;promise_type&gt; coro;
};

template &lt;auto... Ids&gt;
auto generate = []() -&gt; Generator&lt;int&gt; { (co_yield Ids, ...); };

constexpr auto sum = [](auto generator) {
    return std::accumulate(generator.begin(), generator.end(), 0);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6x3novYsE">https://godbolt.org/z/6x3novYsE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>295 - Did you know that C++23 added `stacktrace` library?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/295.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/295.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>stacktrace</code> library?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0881">https://wg21.link/P0881</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;stacktrace&gt;
#include &lt;iostream&gt;

int foo() {
  std::cout &lt;&lt; std::stacktrace::current();
  return {};
}

int main() {
  return foo();
}
</code></pre>

<pre class="codehilite"><code class="language-sh">0# foo()  at /app/example.cpp:5
1# main() at /app/example.cpp:10
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dd9x7Mejc">https://godbolt.org/z/dd9x7Mejc</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>call</code> function which will call itself recursively N times and <br />
  then it wil go through the stack and count how many calls has happend until the <br />
  call at given source line (from)?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;stacktrace&gt;

template&lt;auto N&gt;
[[nodiscard]] auto call(auto from);

int main() {
    using namespace boost::ut;

    &quot;stacktrace&quot;_test = [] {
        expect(1_u == call&lt;0&gt;(__LINE__));
        expect(3_u == call&lt;2&gt;(__LINE__));
        expect(4_u == call&lt;3&gt;(__LINE__));
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rhE8EKf73">https://godbolt.org/z/rhE8EKf73</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p><code>cpp
template &lt;auto N&gt; 
[[nodiscard]] auto call(auto from) 
{
    if constexpr (N == 0)
    {
        return 1;
    }
    else
    {
        return call&lt;N-1&gt;(from) + 1;
    }
}</code></p>
<blockquote>
<p><a href="https://godbolt.org/z/jsdPaP6Px">https://godbolt.org/z/jsdPaP6Px</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt; 
[[nodiscard]] auto call(auto from) 
{
    if constexpr (N &gt; 0)
    {
        return call&lt;N-1&gt;(from) + 1;
    }
    else
    {
        const auto st = std::stacktrace::current();
        return std::ranges::any_of(st, [from](const auto &amp; s) {
            return from == s.source_line();
        });
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hzj3nd36o">https://godbolt.org/z/hzj3nd36o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
[[nodiscard]] auto call(auto from) {
  if constexpr (N == 0) {
    const auto st = std::stacktrace::current();
    const auto it = std::find_if(std::begin(st), std::end(st),
        [&amp;] (const auto&amp; entry) { return entry.source_line() == from; });
    return std::distance(std::begin(st), it);
  } else {
    return call&lt;N-1&gt;(from);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EdTT115es">https://godbolt.org/z/EdTT115es</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from) {
    if constexpr(N &gt; 0) {
        return call&lt;N-1&gt;(from);
    }

    auto st = std::stacktrace::current();
    const auto first_empty = std::find_if(st.begin(), st.end(), [](auto&amp;&amp; trace) {
        return trace.description().empty();
    });
    return std::distance(st.begin(), first_empty);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aG1n9j4ba">https://godbolt.org/z/aG1n9j4ba</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from)
{
    if constexpr(N ==0)
    {
        auto bt = std::stacktrace::current();
        return std::distance ( bt.begin()
                             , std::find_if( bt.begin()
                                           , bt.end()
                                           , [from](auto&amp;&amp; entry){ return entry.source_line() == from;}
                                           )

                             );
    } else
        return call&lt;N-1&gt;(from);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v9nY35PK5">https://godbolt.org/z/v9nY35PK5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
[[nodiscard]] auto call(auto from) {
  if constexpr (N == 0) {
    const auto &amp;st = std::stacktrace::current();
    const auto it = std::find_if(
        std::cbegin(st), std::cend(st),
        [=](const auto &amp;entry) { return entry.source_line() == from; });
    return std::distance(std::cbegin(st), it);
  } else {
    return call&lt;N - 1&gt;(from);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hx9KbPTvr">https://godbolt.org/z/hx9KbPTvr</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from){
    if constexpr(N == 0){
        const auto&amp; stacktrace = std::stacktrace::current();
        const auto it = std::ranges::find_if(stacktrace,
                        [from](const auto&amp; entry){ return entry.source_line() == from; });

        return std::distance(std::cbegin(stacktrace), it);
    }
    else{
        return call&lt;N-1&gt;(from);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MfPGMc4xv">https://godbolt.org/z/MfPGMc4xv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from) {
    if constexpr (N == 0) {
        const auto&amp; st = std::stacktrace::current();
        auto last = std::find_if(st.begin(), st.end(), [from](auto&amp;&amp; it){
            return it.source_line() == from;
        });
        return std::distance(st.begin(), last);
    }
    else {
        return call&lt;N - 1&gt;(from);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9x84cfY4h">https://godbolt.org/z/9x84cfY4h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from) requires (N&gt;=0) {
    if constexpr (N == 0)
    {
        auto cnt = 0;
        for( auto frame : std::stacktrace::current() )
        {
            if (to_string(frame).contains(__FUNCTION__)) {
                cnt++;
            }
        }
        return cnt;
    }
    else
    {
        return call&lt;N-1&gt;(from);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nfKda9oGr">https://godbolt.org/z/nfKda9oGr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from) {
    if constexpr(N&gt;0)
        return call&lt;N-1&gt;(from);
    else {
        int n = 0;
        std::basic_stacktrace st = std::stacktrace::current();
        for(auto it = st.begin(); it &lt; st.end(); it++)
            if (it-&gt;description().starts_with(&quot;auto call&quot;))
                n++;
        return n;
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G61dhrYsr">https://godbolt.org/z/G61dhrYsr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] auto call(auto from){
    if constexpr (N &lt; 1){
        auto s = std::stacktrace().current();
        auto entry = std::find_if(s.begin(),s.end(), [from](auto e){ return e.source_line() == from;});
        return (entry-s.begin());
    }
    else{
        return call&lt;N-1&gt;(from);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oTWz4h6z4">https://godbolt.org/z/oTWz4h6z4</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>294 - Did you know that with C++20 (constexpr containers) TMP can be achieved with STL?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/294.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/294.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that with C++20 (constexpr containers) TMP can be achieved with STL?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1004R2">https://wg21.link/P1004R2</a></p>
</li>
<li><a href="https://github.com/boost-ext/mp">https://github.com/boost-ext/mp</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;ranges&gt;

template &lt;auto Begin, auto End, auto List&gt;
auto slice = List
           | std::ranges::views::drop(Begin)
           | std::ranges::views::take(End);

static_assert(
  slice&lt;1_c, 2_c, boost::mp::list&lt;int, double, float&gt;()&gt;
  ==
                  boost::mp::list&lt;double, float&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hfq8Y1xEn">https://godbolt.org/z/hfq8Y1xEn</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement algorithim which returns either last or first element of the list depending on which one has bigger size?<br />
<code>list&lt;byte[100], byte[200], byte[42]&gt;  -&gt; byte[100]
  list&lt;byte[100], byte[200], byte[142]&gt; -&gt; byte[142]
  list&lt;byte[100], byte[1],   byte[142]&gt; -&gt; byte[142]</code></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size; // TODO

static_assert(first_or_last_depending_on_size&lt;boost::mp::list&lt;std::byte[42], std::byte[43]&gt;()&gt; ==
                                              boost::mp::list&lt;std::byte[43]&gt;());

static_assert(first_or_last_depending_on_size&lt;boost::mp::list&lt;std::byte[42], std::byte[999], std::byte[43]&gt;()&gt; ==
                                              boost::mp::list&lt;std::byte[43]&gt;());

static_assert(first_or_last_depending_on_size&lt;boost::mp::list&lt;std::byte[142], std::byte[999], std::byte[43]&gt;()&gt; ==
                                              boost::mp::list&lt;std::byte[142]&gt;());

static_assert(first_or_last_depending_on_size&lt;boost::mp::list&lt;std::byte[1], std::byte[2], std::byte[3], std::byte[2]&gt;()&gt; ==
                                              boost::mp::list&lt;std::byte[2]&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/46Thzbf8n">https://godbolt.org/z/46Thzbf8n</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = [] consteval {
    auto LastList = List | std::ranges::views::reverse | std::ranges::views::take(1_c);
    if constexpr (auto FirstList = List | std::ranges::views::take(1_c); sizeof_list(FirstList) &gt; sizeof_list(LastList)) {
        return FirstList;
    } else {
        return LastList;
    }
} ();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PY5xdhvEc">https://godbolt.org/z/PY5xdhvEc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;class... Ts&gt; class TList, class... Ts&gt;
[[nodiscard]] consteval auto sizeof_list(TList&lt;Ts...&gt;) { return (sizeof(Ts) + ...);}

template&lt;template&lt;class... Ts&gt; class TList, class... Ts&gt;
[[nodiscard]] consteval auto size(TList&lt;Ts...&gt;) { return sizeof...(Ts); }

template &lt;auto List&gt;
auto first = List | std::ranges::views::take(1_c);

template &lt;auto List&gt;
auto last = List | std::ranges::views::drop(std::integral_constant&lt;std::size_t, size(List) - 1&gt;());

template &lt;auto List&gt;
auto first_or_last_depending_on_size = boost::mp::list&lt;
    std::byte[std::max(sizeof_list(first&lt;List&gt;), sizeof_list(last&lt;List&gt;))]
&gt;()
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K9vjM7Eao">https://godbolt.org/z/K9vjM7Eao</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = List | []&lt;class...&gt; {
    using boost::mp::operator&quot;&quot;_c;
    auto first = List | std::ranges::views::take(1_c);
    auto last  = List | std::ranges::views::reverse | std::ranges::views::take(1_c);
    auto size = []&lt;class T&gt; { return sizeof(T); };

    if constexpr ((first | size) &gt; (last | size)) {
        return first;
    } else {
        return last;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/15TY4YT89">https://godbolt.org/z/15TY4YT89</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = List | []&lt;class... Ts&gt;(auto) {
    using boost::mp::operator&quot;&quot;_c;
    auto first = List | std::ranges::views::take(1_c);
    auto last  = List | std::ranges::views::reverse | std::ranges::views::take(1_c);
    auto size =  [](auto list) { return list | []&lt;class T&gt; { return sizeof(T); };  };
    return std::array{
        (size(first)) &gt; (size(last)) ?
        boost::mp::meta{.index = 0} :
        boost::mp::meta{.index = sizeof...(Ts) - 1}
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hY95P6qYe">https://godbolt.org/z/hY95P6qYe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;class... Ts&gt; class TList, class... Ts&gt;
[[nodiscard]] consteval auto sizeof_list(TList&lt;Ts...&gt;) { return (sizeof(Ts) + ...);}

template &lt;auto List&gt;
constexpr auto first = List | std::ranges::views::take(1_c);

template &lt;auto List&gt;
auto last = first&lt;List | std::ranges::views::reverse&gt;;

template &lt;auto List&gt;
auto first_or_last_depending_on_size =
  [] {
    if constexpr (sizeof_list(first&lt;List&gt;) &gt; sizeof_list(last&lt;List&gt;)) {
      return first&lt;List&gt;;
    } else {
      return last&lt;List&gt;;
    }
  }();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6Mec4378M">https://godbolt.org/z/6Mec4378M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = List | [](boost::mp::concepts::meta auto types) {
    return std::array{
        types[0].size &gt; types[types.size() - 1].size - 1 ?
        boost::mp::meta{.index = 0} :
        boost::mp::meta{.index = types.size()-1}
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4fqhTd5xj">https://godbolt.org/z/4fqhTd5xj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = []{
    constexpr auto first = List | std::views::take(1_c);
    constexpr auto last = List | std::views::reverse | std::views::take(1_c);

    if constexpr(sizeof_list(first) &gt; sizeof_list(last)){
        return first;
    }
    else{
        return last;
    }
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fMcEh33rY">https://godbolt.org/z/fMcEh33rY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = [] {
    constexpr auto first = List | views::take(1_c);
    constexpr auto last =  List | views::reverse | views::take(1_c);

    if constexpr (sizeof_list(first) &gt; sizeof_list(last)) {
        return first;
    } else {
        return last;
    }
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cssW4cq51">https://godbolt.org/z/cssW4cq51</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;class... Ts&gt; class TList, class... Ts&gt;
[[nodiscard]] consteval auto sizeof_list(TList&lt;Ts...&gt;) { return (sizeof(Ts) + ...);}

namespace rv = std::ranges::views;

template &lt;auto List&gt;
auto first = [] { return List | rv::take(1_c); };

template &lt;auto List&gt;
auto last = [] { return List | rv::reverse | rv::take(1_c); };

template &lt;auto List&gt;
auto first_or_last_depending_on_size = [] {
    auto first_element = first&lt;List&gt;();
    auto last_element = last&lt;List&gt;();

    if constexpr (sizeof_list(first_element) &gt; sizeof_list(last_element)) {
        return first_element;
    } else {
        return last_element;
    }
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x8nKj3qdn">https://godbolt.org/z/x8nKj3qdn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto List&gt;
auto first_or_last_depending_on_size = List | [] (boost::mp::concepts::meta auto types) {
  auto first = types.front();
  auto last = types.back();
  return std::array{first.size &lt; last.size ? last : first};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jdrdhP3z8">https://godbolt.org/z/jdrdhP3z8</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>293 - Did you know that C++17 [[nodiscard]] attribute can be applied not only to function?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/293.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/293.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 [[nodiscard]] attribute can be applied not only to function?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/dcl.attr.nodiscard#:attribute,nodiscard">http://eel.is/c++draft/dcl.attr.nodiscard#:attribute,nodiscard</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
   [[nodiscard]] foo(auto&amp; resource) {}
};

struct [[nodiscard]] bar {};

auto fn() -&gt; bar;

[[nodiscard]] auto fn2() -&gt; bool;

int main(int, char** argv){
    foo{argv}; // ignoring temp created by [[nodiscard]]
    fn();      // ignoring return value with [[nodiscard]]
    fn2();     // ignoring return value with [[nodiscard]]
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mch6cGM1h">https://godbolt.org/z/Mch6cGM1h</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you mark all provided types/functions as [[nodiscard]] and handle the consequenes?</strong></p>
</li>
<li>
<p>Do you know any production use cases when applying nodiscard for non-functions improves the code?</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">// TODO: mark nodiscard
struct foo { };
auto fn1() -&gt; foo;
auto fn2() -&gt; bool;

int main() {
    // TODO: handle nodiscard
    foo();
    fn1();
    fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/coPPe4KTP">https://godbolt.org/z/coPPe4KTP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo { };
[[nodiscard]] auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
    (void)foo(); 
    (void)fn1();
    (void)fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h997hnKM4">https://godbolt.org/z/h997hnKM4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo { };
[[nodiscard]] auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
    std::ignore = foo();
    std::ignore = fn1();
    std::ignore = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MjjM8fdrn">https://godbolt.org/z/MjjM8fdrn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo { };
[[nodiscard]] auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
    auto not_ignored = foo();
    auto not_ignored1 = fn1();
    auto not_ignored2 = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sf9qPfj48">https://godbolt.org/z/sf9qPfj48</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo { };
[[nodiscard]] auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
  [[maybe_unused]] auto f = foo{};
  (void) fn1();
  ignore = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eja8rc4sf">https://godbolt.org/z/eja8rc4sf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo {};
auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
  std::ignore = foo();
  std::ignore = fn1();
  std::ignore = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a73973Ge3">https://godbolt.org/z/a73973Ge3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo { };      
[[nodiscard]] auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
    static_cast&lt;void&gt;(foo());
    [[maybe_unused]] foo  = fn1();
    std::ignore = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1WYx6WesG">https://godbolt.org/z/1WYx6WesG</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard(&quot;Attribute 1&quot;)]] foo { };
[[nodiscard(&quot;Attribute 2&quot;)]] auto fn1() -&gt; foo;
[[nodiscard(&quot;Attribute 3&quot;)]] auto fn2() -&gt; bool;

int main() {
    // TODO: handle nodiscard
    static_cast&lt;void&gt;(foo());
    static_cast&lt;void&gt;(fn1());
    auto or_this = fn2();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z5KTYG6s4">https://godbolt.org/z/z5KTYG6s4</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct [[nodiscard]] foo {};
auto fn1() -&gt; foo;
[[nodiscard]] auto fn2() -&gt; bool;

int main() {
    // TODO: handle nodiscard
    static_cast&lt;void&gt;(foo());
    static_cast&lt;void&gt;(fn1());
    static_cast&lt;void&gt;(fn2());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4c8rhq3W7">https://godbolt.org/z/4c8rhq3W7</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>292 - Did you know about memoized for less types (more compile-time friendly) conditional_t?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/292.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/292.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about memoized for less types (more compile-time friendly) conditional_t?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/meta.type.synop">https://eel.is/c++draft/meta.type.synop</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;bool&gt; struct conditional;
template &lt;&gt; struct conditional&lt;false&gt; {
  template &lt;class, class T&gt; using fn = T;
};
template &lt;&gt; struct conditional&lt;true&gt; {
  template &lt;class T, class&gt; using fn = T;
};
} // namespace detail

template &lt;bool B, typename T, typename F&gt;
using conditional_t = typename detail::conditional&lt;B&gt;::template fn&lt;T, F&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jePqT64bn">https://godbolt.org/z/jePqT64bn</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement tribool memoized version of conditional?</strong></p>
</li>
<li>
<p>Note: it should only instansiate 3 classes (for tribool) and use an alias for the T, F</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto B, class T, class F&gt;
using conditional_t; // TODO - memoized for tribool

static_assert(conditional_t&lt;true, std::true_type, std::false_type&gt;{});
static_assert(not conditional_t&lt;false, std::true_type, std::false_type&gt;{});
static_assert(typeid(void)  == typeid(conditional_t&lt;boost::logic::indeterminate, std::true_type, std::false_type&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/En53E8qPc">https://godbolt.org/z/En53E8qPc</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;auto&gt;
struct conditional_t;

template &lt;&gt;
struct conditional_t&lt;true&gt; {
    template &lt;class T, class&gt;
    using meta_func = T;
};
template &lt;&gt;
struct conditional_t&lt;false&gt; {
    template &lt;class, class T&gt;
    using meta_func = T;
};
template &lt;&gt;
struct conditional_t&lt;boost::logic::indeterminate&gt; {
    template &lt;class, class&gt;
    using meta_func = void;
};
}  // namespace detail

template &lt;auto B, class T, class F&gt;
using conditional_t = detail::conditional_t&lt;B&gt;::template meta_func&lt;T, F&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7GYxq83j6">https://godbolt.org/z/7GYxq83j6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;boost::logic::tribool&gt;
struct conditional;

template &lt;&gt;
struct conditional&lt;true&gt; {
  template &lt;class T, class&gt;
  using fn = T;
};

template &lt;&gt;
struct conditional&lt;false&gt; {
  template &lt;class, class F&gt;
  using fn = F;
};

template &lt;&gt;
struct conditional&lt;boost::logic::indeterminate&gt; {
  template &lt;class, class&gt;
  using fn = void;
};

template &lt;boost::logic::tribool B, class T, class F&gt;
using conditional_t = boost::mp11::mp_invoke_q&lt;conditional&lt;B&gt;, T, F&gt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a6csGT9nq">https://godbolt.org/z/a6csGT9nq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto B&gt;
struct conditional;

template &lt;&gt;
struct conditional&lt;true&gt; {
  template &lt;class T, class&gt;
struct conditional&lt;boost::logic::indeterminate&gt; {
  template &lt;class, class&gt;
  using type = void;
};

template &lt;auto B, class T, class F&gt;
using conditional_t = typename conditional&lt;B&gt;::type&lt;T, F&gt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E56r5cdzM">https://godbolt.org/z/E56r5cdzM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;auto B&gt;
struct conditional_impl;

template &lt;&gt;
using conditional_t = typename detail::conditional_impl&lt;B&gt;::type&lt;T, F&gt;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eK3TbjsKf">https://godbolt.org/z/eK3TbjsKf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto B&gt; struct conditional{
    template &lt;class T, class F&gt; using fn = void;
};
template &lt;&gt; struct conditional&lt;false&gt; {
  template &lt;class, class T&gt; using fn = T;
};
template &lt;&gt; struct conditional&lt;true&gt; {
  template &lt;class T, class&gt; using fn = T;
};

template &lt;auto B, typename T, typename F&gt;
using conditional_t = typename conditional&lt;B&gt;::template fn&lt;T, F&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/b74KhKas3">https://godbolt.org/z/b74KhKas3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;boost::logic::tribool&gt; struct conditional;
template &lt;&gt; struct conditional&lt;false&gt; {
  template &lt;class, class T&gt; using fn = T;
};
template &lt;&gt; struct conditional&lt;true&gt; {
  template &lt;class T, class&gt; using fn = T;
};
template &lt;&gt; struct conditional&lt;boost::logic::indeterminate&gt; {
  template &lt;class, class&gt; using fn = void;
};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zxMTEa7Gd">https://godbolt.org/z/zxMTEa7Gd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;boost::tribool&gt; struct conditional;
template &lt;&gt; struct conditional&lt;false&gt; {
    template&lt;class , class T&gt; using fn = T;
};

template &lt;&gt; struct conditional&lt;true&gt; {
    template&lt;class T, class&gt; using fn = T;
};

template&lt;&gt; struct conditional&lt;boost::logic::indeterminate&gt; {
    template&lt;class , class&gt; using fn = void;
};
} //namespace detail


template &lt;auto B, class T, class F&gt;
using conditional_t = typename detail::conditional&lt;B&gt;::template fn&lt;T, F&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KWvbGMozx">https://godbolt.org/z/KWvbGMozx</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>291 - Did you know about [[gnu::cold]] function attribute to mark functions which are unlikely to be called?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/291.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/291.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about [[gnu::cold]] function attribute to mark functions which are unlikely to be called?</strong></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes">https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">void report_error();
[[gnu::cold]] void report_error_cold();
void logic();

/*
cold(bool):
        test    edi, edi
        jne     .LBB0_1
        jmp     logic()
.LBB0_1:
        jmp     report_error_cold()
*/
auto cold(bool error) {
    if (error) {
        report_error_cold();
        return;
    }

    logic();
}

/*
normal(bool):
        test    edi, edi
        je      .LBB1_2
        jmp     report_error()
.LBB1_2:
        jmp     logic()
*/
auto normal(bool error) {
    if (error) {
        report_error();
        return;
    }

    logic();
}

/*
unlikely(bool):
        test    edi, edi
        jne     .LBB2_1
        jmp     logic()
.LBB2_1:
        jmp     report_error()
*/
auto unlikely(bool error) {
    if (error) [[unlikely]] {
        report_error();
        return;
    }

    logic();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EE1jjG45j">https://godbolt.org/z/EE1jjG45j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement required error policies using provided lambdas so that they will match assembly?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">void logic();

template&lt;auto ErrorPolicy&gt;
auto handle(bool error) {
  if (error) {
    ErrorPolicy(error);
    return;
  }
  logic();
}

/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) {}&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) { if (error) throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) {  }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xPGs36dTM">https://godbolt.org/z/xPGs36dTM</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">auto test_lambda_cold(bool error) {
    handle&lt;[][[gnu::cold]](bool error) {}&gt;(error);
}

auto test_lambda_throw(bool error) {
    handle&lt;[](bool error) { if (error) throw; }&gt;(error);
}

auto test_lambda_abort(bool error) {
    handle&lt;[][[gnu::hot]] (bool error) { if (error) abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fas5c6KKG">https://godbolt.org/z/fas5c6KKG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void report_error();
[[gnu::cold]] void report_error_cold();
void logic();

/*
cold(bool):
        test    edi, edi
        jne     .LBB0_1
        jmp     logic()
.LBB0_1:
        jmp     report_error_cold()
*/
auto cold(bool error) {
    if (error) {
        report_error_cold();
        return;
    }

    logic();
}

/*
normal(bool):
        test    edi, edi
        je      .LBB1_2
        jmp     report_error()
.LBB1_2:
        jmp     logic()
*/
auto normal(bool error) {
    if (error) {
        report_error();
        return;
    }

    logic();
}

/*
unlikely(bool):
        test    edi, edi
        jne     .LBB2_1
        jmp     logic()
.LBB2_1:
        jmp     report_error()
*/
auto unlikely(bool error) {
    if (error) [[unlikely]] {
        report_error();
        return;
    }

    logic();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EE1jjG45j">https://godbolt.org/z/EE1jjG45j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement required error policies using provided lambdas so that they will match assembly?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">void logic();

template&lt;auto ErrorPolicy&gt;
auto handle(bool error) {
  if (error) {
    ErrorPolicy(error);
    return;
  }
  logic();
}

/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) {}&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) { if (error) throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) {  }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xPGs36dTM">https://godbolt.org/z/xPGs36dTM</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
  // adding the [[gnu::cold]] attribute to the lambda changes je to jne
  handle&lt;[] [[gnu::cold]] (bool) {}&gt;(error);
}

/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
  // no attribute needed here: does the throw already cause coldness?
  // consider: an if branch that throws is already considered [[unlikely]]
  handle&lt;[] (bool) { throw; }&gt;(error);
}

#include &lt;cstdlib&gt;

/*
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
  // does abort also imply coldness?
  // [[noreturn]] makes no difference here but may also imply coldness?
  handle&lt;[] [[noreturn]] (bool) { std::abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j39c5Kf4x">https://godbolt.org/z/j39c5Kf4x</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    handle&lt;[](bool error) {[[gnu::cold]]; }&gt;(error);
}

/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    handle&lt;[](bool error) { if (error) throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    handle&lt;[](bool error) { abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P5ssGz9f8">https://godbolt.org/z/P5ssGz9f8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    handle&lt;[] [[gnu::cold]] (bool error) {}&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    handle&lt;[](bool error) { if (error) throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    handle&lt;[](bool error) { std::abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s7KxMrhrK">https://godbolt.org/z/s7KxMrhrK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
  handle&lt;[] [[gnu::cold]] {}&gt;(error);
}

/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L6
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L6:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
  handle&lt;[] [[gnu::cold]] { throw; }&gt;(error);
}

#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L11
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L11:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
  handle&lt;[] [[gnu::cold]] { std::abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a8463WjzP">https://godbolt.org/z/a8463WjzP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[] [[gnu::cold]] (bool error) { }&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool) { throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) { std::abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1zd87f1Gj">https://godbolt.org/z/1zd87f1Gj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[] [[gnu::cold]] (bool error) {}&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[] (bool error) { throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[] [[gnu::cold]] (bool error) { abort(); }&gt;(error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5sz1jxdbe">https://godbolt.org/z/5sz1jxdbe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt; [][[gnu::cold]](bool error) {}&gt; (error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[]  (bool error) { if (error) [[unlikely]] throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[] (bool error) { if(error) [[unlikely]] abort(); }&gt;( error);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/88b58cd45">https://godbolt.org/z/88b58cd45</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">/*
test_lambda_cold(bool):
        test    dil, dil
        jne     .L1
        jmp     logic()
.L1:
        ret
*/
auto test_lambda_cold(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error ) { [[unlikely]] return;}&gt;(error);
}


/*
test_lambda_throw(bool):
        test    dil, dil
        jne     .L7
        jmp     logic()
test_lambda_throw(bool) [clone .cold]:
.L7:
        push    rax
        call    __cxa_rethrow
*/
auto test_lambda_throw(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) { if (error)[[unlikely]] throw; }&gt;(error);
}


#include &lt;cstdlib&gt;

/**
test_lambda_abort(bool):
        test    dil, dil
        jne     .L12
        jmp     logic()
test_lambda_abort(bool) [clone .cold]:
.L12:
        push    rax
        call    abort
*/
auto test_lambda_abort(bool error) {
    // TODO - modify the following line to get the above assembly
    handle&lt;[](bool error) { if (error)[[unlikely]] abort();  }&gt;(error) ;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/frv8MPTY8">https://godbolt.org/z/frv8MPTY8</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>290 - Did you know that lambda expression is guaranteed to have a unique type?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/290.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/290.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that lambda expression is guaranteed to have a unique type?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/expr.prim.lambda">https://eel.is/c++draft/expr.prim.lambda</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(typeid([]{}) != typeid([]{}));

template&lt;auto = []{}&gt;
struct foo{};

foo f1, f2;
static_assert(typeid(f1) != typeid(f2));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wrhfqba69">https://godbolt.org/z/Wrhfqba69</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement <code>create</code> which creates given type as a unique type or same type?</strong></p>
</li>
<li>
<p>Note: For type uniqueness inheritance might be used</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">class same;
class unique;

template&lt;class...&gt;
[[nodiscard]] constexpr auto create(); // TODO

struct foo {};
static_assert(typeid(create&lt;foo&gt;()) == typeid(create&lt;foo&gt;()));
static_assert(typeid(create&lt;foo, class unique&gt;()) != typeid(create&lt;foo, class unique&gt;()));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YKKej87dE">https://godbolt.org/z/YKKej87dE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, auto UniqueTag&gt;
struct wrap_unique: T {};

template&lt;class T, typename UniqueOrSame = class same, auto UniqueTag = []{}&gt;
[[nodiscard]] constexpr std::convertible_to&lt;T&gt; auto create()
{
    if constexpr (std::same_as&lt;UniqueOrSame, class unique&gt;) {
        return wrap_unique&lt;T, UniqueTag&gt;{};
    } else {
        return T{};
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j5xvPzd47">https://godbolt.org/z/j5xvPzd47</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto = []{}&gt;
struct uniquify : T {};

template &lt;class T, class C = same, class U = uniquify&lt;T&gt;&gt;
[[nodiscard]] constexpr auto create()
  -&gt; std::conditional_t&lt;std::same_as&lt;C, unique&gt;, U, T&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s6o7E4Kj6">https://godbolt.org/z/s6o7E4Kj6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto&gt;
struct uniquify : T {};

template &lt;class T, class U = same, auto V = [] {}&gt;
[[nodiscard]] constexpr auto create() {
  if constexpr (std::same_as&lt;U, unique&gt;) {
    return uniquify&lt;T, V&gt;{};
  } else {
    return T{};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K8q3KdGbx">https://godbolt.org/z/K8q3KdGbx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class U = same, auto UniqueLambda = []{}&gt;
[[nodiscard]] constexpr auto create() {
    if constexpr (std::is_same_v&lt;U, unique&gt;) {
        return UniqueLambda;
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nTb5h5x4o">https://godbolt.org/z/nTb5h5x4o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class first, class second = same, auto = [] {}&gt;
[[nodiscard]] constexpr auto create() {
  if constexpr (std::is_same_v&lt;second, same&gt;) {
    return first{};
  } else {
    return [] {};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Msodn95Tf">https://godbolt.org/z/Msodn95Tf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class Tp, auto = []{}&gt;
class Holder : Tp {};

template&lt;class Tp, class Option = same, class Held = Holder&lt;Tp&gt; &gt;
[[nodiscard]] constexpr auto create() {
    if constexpr (std::is_same_v&lt;Option, same&gt;)
        return Tp{};
    else
        return Held{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r8jcWz5ee">https://godbolt.org/z/r8jcWz5ee</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto = []{}&gt;
class diff : T{};

template&lt;class T, class U = same, class V = diff&lt;T&gt;&gt;
[[nodiscard]] constexpr auto create(){
    if constexpr(std::is_same_v&lt;U, unique&gt;){
        return V{};
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/47Wc8r5js">https://godbolt.org/z/47Wc8r5js</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>289 - Did you know that [[assume]] attribute has been accepted to C++23?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/289.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/289.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that [[assume]] attribute has been accepted to C++23?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1774">https://wg21.link/P1774</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">/*
divide_by_32_no_assume(int):
        lea     eax, [rdi + 31]
        test    edi, edi
        cmovns  eax, edi
        sar     eax, 5
        ret
*/
auto divide_by_32_no_assume(int x) {
    return x / 32;
}


/*
divide_by_32_assume(int):
        mov     eax, edi
        shr     eax, 5
        ret
*/
auto divide_by_32_assume(int x) {
    __builtin_assume(x &gt;= 0);
    return x / 32;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EY43Moa4z">https://godbolt.org/z/EY43Moa4z</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you modify given examples by adding assume attribute so that sum_impl/g1/g2 functions will be optimized?</strong></p>
</li>
<li>
<p>Note: Expected optimized assembly is provided above the functions</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">/* TODO - modify sum_impl by adding assume attribute so that sum_impl will be optimized */
auto sum(auto... ts) {
    return sum_impl(ts...);
}

/*
  sum_impl(int, int, int):
        imul    esi, edx
        lea     eax, [rsi + rdi]
        ret
 */
auto sum_impl(int src, int n, int s) {
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}



/* TODO - modify smart_ptr by adding assume attribute so that g1/g2 will be optimized */
struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};

/*
  g1(smart_ptr):
        mov     eax, dword ptr [rdi]
        ret
*/
auto g1(smart_ptr p) { return p.counter(); }

/*
  g2(smart_ptr):
        mov     eax, dword ptr [rdi]
        inc     eax
        ret
*/
auto g2(smart_ptr p) { return g1(p); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r5P4jYdnd">https://godbolt.org/z/r5P4jYdnd</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
auto sum_impl(int src, int n, int s) {</p>
<pre class="codehilite"><code>auto i = 0;
__builtin_assume(i &lt; n);
for (; i &lt; n ; ++i) {
    src += s;
}

return src;
</code></pre>

<p>}</p>
<p>struct smart_ptr final {<br />
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {<br />
        __builtin_assume(counter_ &gt;= 1);<br />
        ++counter_;<br />
    }</p>
<pre class="codehilite"><code>~smart_ptr() {
    if (--counter_ == 0) {
        destroy();
    }
}

[[nodiscard]] auto counter() const { return counter_; }
</code></pre>

<p>private:<br />
    void destroy();<br />
    int counter_{};<br />
};</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/h79ncYKWM](https://godbolt.org/z/h79ncYKWM)

```cpp
auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt; 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(r.counter_ &gt;= 1);
        ++counter_;
    }

    ~smart_ptr() {
        __builtin_assume(counter_ &gt; 0);
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/vooc977sW">https://cpp_tip_of_the_week.godbolt.org/z/vooc977sW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
  __builtin_assume(n &gt;= 0);
  for (auto i = 0; i &lt; n; ++i) {
    src += s;
  }
  return src;
}

struct smart_ptr final {
  constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
    __builtin_assume(counter_ &gt; 0);
    ++counter_;
  }

  ~smart_ptr() {
    if (--counter_ == 0) destroy();
  }

  [[nodiscard]] auto counter() const { return counter_; }

private:
  void destroy();
  int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wzx6zWEfb">https://godbolt.org/z/Wzx6zWEfb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;= 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt;= 1);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6dWMTjh5o">https://godbolt.org/z/6dWMTjh5o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;= 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xs8T8M53Y">https://godbolt.org/z/xs8T8M53Y</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
  __builtin_assume(n &gt;= 0);
  for (auto i = 0; i &lt; n; ++i) {
    src += s;
  }
  return src;
}

struct smart_ptr final {
  constexpr explicit(false) smart_ptr(const smart_ptr&amp; r)
      : counter_(r.counter_) {
    __builtin_assume(counter_ &gt; 0);
    ++counter_;
  }

  ~smart_ptr() {
    if (--counter_ == 0) destroy();
  }

  [[nodiscard]] auto counter() const { return counter_; }

 private:
  void destroy();
  int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/79c79r8b4">https://godbolt.org/z/79c79r8b4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    //src += n * s;
    __builtin_assume(n &gt; 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt;= 1);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ocvnTrzrq">https://godbolt.org/z/ocvnTrzrq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#if defined(__clang__)
#define ASSUME(expr) __builtin_assume(expr)
#elif defined(__GNUC__) &amp;&amp; !defined(__ICC)
#define ASSUME(expr) if (expr) {} else { __builtin_unreachable(); }
#elif defined(_MSC_VER) || defined(__ICC)
#define ASSUME(expr) __assume(expr)
#endif

auto sum_impl(int src, int n, int s) {
    ASSUME(n &gt; 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        ASSUME(counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dqEr5nMxW">https://godbolt.org/z/dqEr5nMxW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;= 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jYoqM4sbo">https://godbolt.org/z/jYoqM4sbo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;= 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1ezTeK8o7">https://godbolt.org/z/1ezTeK8o7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(r.counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hETMdvjKE">https://godbolt.org/z/hETMdvjKE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_impl(int src, int n, int s) {
    __builtin_assume(n &gt;= 0);
    for (auto i = 0; i &lt; n; ++i) {
        src += s;
    }
    return src;
}

struct smart_ptr final {
    constexpr explicit(false) smart_ptr(const smart_ptr&amp; r) : counter_(r.counter_) {
        __builtin_assume(counter_ &gt; 0);
        ++counter_;
    }

    ~smart_ptr() {
        if (--counter_ == 0) destroy();
    }

    [[nodiscard]] auto counter() const { return counter_; }

   private:
    void destroy();
    int counter_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KdaEh9fKo">https://godbolt.org/z/KdaEh9fKo</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>288 - Did you know you can pass an array by reference?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/288.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/288.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know you can pass an array by reference?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/dcl.array">http://eel.is/c++draft/dcl.array</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">void foo1(int*);
void foo2(int[42]);
void foo3(int[]);
void foo4(int(&amp;)[42]);

int main() {
    int a[42]{};
    foo1(a); // ok
    foo2(a); // ok
    foo3(a); // ok
    foo4(a); // ok
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3qn8rM7Ee">https://godbolt.org/z/3qn8rM7Ee</a> </p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>array_size</code> which returns the size of given array?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto array_size(auto); // TODO

static_assert(1uz == [] { bool a[]{{}}; return array_size(a); }());
static_assert(3uz == [] { int a[]{{}, {}, {}}; return array_size(a); }());
static_assert(42uz == [] { int a[42]{}; return array_size(a); }());

static_assert(0uz == array_size(std::array&lt;bool, 0&gt;{}));
static_assert(3uz == array_size(std::array&lt;int, 3&gt;{}));
static_assert(42uz == array_size(std::array&lt;char, 42&gt;{}));

static_assert(1uz == array_size(std::vector{1}));
static_assert(3uz == array_size(std::vector{1, 2, 3}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3Gec1YqM1">https://godbolt.org/z/3Gec1YqM1</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto array_size(auto&amp;&amp; x) {
    return std::size(x);
}
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/jWYnhnqos">https://cpp_tip_of_the_week.godbolt.org/z/jWYnhnqos</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt; typename T, size_t N &gt; constexpr size_t array_size (T (&amp;) [N]){ return N; }
template&lt; typename T&gt; constexpr auto array_size (T &amp;&amp; t){ return t.size(); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1zY5Pdn8P">https://godbolt.org/z/1zY5Pdn8P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto array_size(auto&amp;&amp; arr){
    if constexpr(std::is_array_v&lt;std::remove_cvref_t&lt;decltype(arr)&gt;&gt;) {
        return sizeof(arr) / sizeof(arr[0]);
    }
    else {
        return std::size(arr);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vdEn5Yf9x">https://godbolt.org/z/vdEn5Yf9x</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, auto N&gt;
[[nodiscard]] consteval auto array_size(T(&amp;)[N]) { return N; }

template &lt;typename T&gt;
requires requires { std::declval&lt;T&gt;().size(); }
[[nodiscard]] constexpr auto array_size(T&amp;&amp; t) {
  return t.size();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1xdTY6aev">https://godbolt.org/z/1xdTY6aev</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, std::size_t N&gt;
[[nodiscard]] consteval auto array_size(T(&amp;)[N]) { return N; }

template &lt;typename T&gt;
requires requires { std::declval&lt;const T &amp;&gt;().size(); }
[[nodiscard]] consteval auto array_size(const T&amp; array) { return array.size(); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c9dds6MY6">https://godbolt.org/z/c9dds6MY6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto array_size(const auto&amp; t) {
    return std::size(t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/81777x44Y">https://godbolt.org/z/81777x44Y</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T, std::size_t N&gt;
[[nodiscard]] consteval std::size_t array_size(T(&amp;)[N]){
  return N;
}

[[nodiscard]] consteval std::size_t array_size(auto x){
  return std::size(x);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bn9scvvrq">https://godbolt.org/z/bn9scvvrq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t sz&gt;
[[nodiscard]] consteval auto array_size(const auto (&amp; my_array)[sz])
{
    return sz;
}

template &lt;class T, std::size_t sz&gt;
[[nodiscard]] consteval auto array_size(const std::array&lt;T, sz&gt;&amp;)
{
    return sz;
}

[[nodiscard]] consteval auto array_size(const auto&amp; v)
{
    return std::size(v);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ex5jhv3q1">https://godbolt.org/z/ex5jhv3q1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
[[nodiscard]] consteval auto array_size(T (&amp;)[N]){
  return N;
}
[[nodiscard]] consteval auto array_size(auto aa){
  if constexpr (requires { aa.size(); }) {
    return aa.size();
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1b9x8dfPz">https://godbolt.org/z/1b9x8dfPz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto array_size(auto &amp;&amp;ar){
    if constexpr (requires {ar.size();})
        return ar.size();
    else
        return sizeof(ar) / sizeof(ar[0]);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bGb7EzaGM">https://godbolt.org/z/bGb7EzaGM</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>287 - Did you know that C++23 added `auto(x): decay-copy in the language`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/287.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/287.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>auto(x): decay-copy in the language</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0849">https://wg21.link/P0849</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto foo(auto&amp;&amp;);

int main() {
    int i{};
    const int c{};

    foo(42);       // int
    foo(i);        // int&amp;
    foo(int{i});   // int
    foo(auto{i});  // int
    foo(auto(42)); // int
    foo(c);        // const int&amp;
    foo(int{c});   // int
    foo(auto(c));  // int
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Thh4YohGG">https://godbolt.org/z/Thh4YohGG</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement C++20/C++23 version of <code>copy_and_sum_ts</code> which copies and sums given parameters...?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct copy {
    bool copied{};
    constexpr copy() = default;
    constexpr copy(const copy&amp;) : copied{true} {}
    constexpr operator auto() const { return copied; }
};

namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts); // TODO
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts); // TODO
}

int main() {
  constexpr copy c1, c2, c3;

  static_assert(0 == cpp20::copy_and_sum_ts());
  static_assert(1 == cpp20::copy_and_sum_ts(c1));
  static_assert(2 == cpp20::copy_and_sum_ts(c1, c2));
  static_assert(3 == cpp20::copy_and_sum_ts(c1, c2, c3));

  static_assert(0 == cpp23::copy_and_sum_ts());
  static_assert(1 == cpp23::copy_and_sum_ts(c1));
  static_assert(2 == cpp23::copy_and_sum_ts(c1, c2));
  static_assert(3 == cpp23::copy_and_sum_ts(c1, c2, c3));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hja3qoPdx">https://godbolt.org/z/hja3qoPdx</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
namespace cpp20 {</p>
<p>namespace detail {<br />
constexpr auto clone(const auto &amp; t) { return t; }<br />
} // namespace detail</p>
<p>constexpr auto copy_and_sum_ts(auto &amp;...ts) {<br />
    return (0 + ... + detail::clone(ts));<br />
}<br />
} // namespace cpp20</p>
<p>namespace cpp23 {<br />
constexpr auto copy_and_sum_ts(auto &amp;...ts) {<br />
    return (0 + ... + auto{ts});<br />
}<br />
} // namespace cpp23</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/a1en6xv5f](https://godbolt.org/z/a1en6xv5f)

```cpp
namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts) {
       return (copy{} + ... + copy{ts});
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
    return (copy{} + ... + auto{ts});
  }
}
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/naseW8j7n">https://cpp_tip_of_the_week.godbolt.org/z/naseW8j7n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts){
        auto sum = 0;
        auto copier = [](auto&amp; ts) {
          auto copy = ts;
          return copy;
        };
        return (0 + ... + copier(ts));
   };
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts){
      return (0 + ... + auto{ts});
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Eq4ven6sf">https://godbolt.org/z/Eq4ven6sf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp11 {
   template&lt;class... Ts&gt;
   constexpr auto copy_and_sum_ts(Ts&amp;... ts){
     return (0uz + ... + Ts(ts));
   }
}

namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts){
     return (0uz + ... + std::remove_cvref_t&lt;decltype(ts)&gt;(ts));
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts){
      return (0uz + ... + auto{ts});
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YxnKzrq7b">https://godbolt.org/z/YxnKzrq7b</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
    return (0 + ... + [] (auto&amp; t) { return t; }(ts));
  }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
    return (0 + ... + auto{ts});
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h7xWjhnhx">https://godbolt.org/z/h7xWjhnhx</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
constexpr auto copy_and_sum_ts(auto&amp;... ts) {
  return (0 + ... + decltype(ts){ts});
}
}  // namespace cpp20

namespace cpp23 {
constexpr auto copy_and_sum_ts(auto&amp;... ts) { return (0 + ... + auto{ts}); }
}  // namespace cpp23
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h7v16rfdv">https://godbolt.org/z/h7v16rfdv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts) {
       return (std::remove_cvref_t&lt;decltype(ts)&gt;{ts} + ... + 0);
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
      return (auto{ts} + ... + 0);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xKfnhGs7b">https://godbolt.org/z/xKfnhGs7b</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts){
       return (decltype(ts){ts} + ... + 0);
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts){
      return (auto{ts} + ... + 0);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wha7G9fEv">https://godbolt.org/z/Wha7G9fEv</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts) {
       return (0 + ... + std::remove_cvref_t&lt;decltype(ts)&gt;{ts});
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
      return (0 + ... + auto{ts});
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4Pz8Gfod5">https://godbolt.org/z/4Pz8Gfod5</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts) {
       constexpr auto Auto = [](auto x) {return x;};

       return (0 + ... + Auto(ts));
    }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) { return (0 + ... + auto(ts)); }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GGG5Wf4cK">https://godbolt.org/z/GGG5Wf4cK</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
typename std::decay&lt;T&gt;::type
constexpr decay_copy (T&amp;&amp; t) {
    return std::forward&lt;T&gt;(t);
}

struct copy {
    bool copied{};
    constexpr copy() = default;
    constexpr copy(const copy&amp;) : copied{true} {}
    constexpr operator auto() const { return copied; }
};

namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts){
       return (decay_copy(ts) + ... + 0);
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts){
      return (auto(ts) + ... + 0);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P8EYhxcx3">https://godbolt.org/z/P8EYhxcx3</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace cpp20 {
   constexpr auto copy_and_sum_ts(auto&amp;... ts) {
       return (copy(ts).copied + ... + 0);
   }
}

namespace cpp23 {
  constexpr auto copy_and_sum_ts(auto&amp;... ts) {
      return ( auto(ts).copied + ... + 0);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1bGs96G7M">https://godbolt.org/z/1bGs96G7M</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>286 - Did you know that Circle supports Python's extended slice syntax for variadic packs?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/286.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/286.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Circle supports Python's extended slice syntax for variadic packs?</strong></p>
</li>
<li>
<p><a href="https://docs.python.org/2.3/whatsnew/section-slices.html">https://docs.python.org/2.3/whatsnew/section-slices.html</a></p>
</li>
<li><a href="https://github.com/seanbaxter/circle/blob/master/comprehension/README.md">https://github.com/seanbaxter/circle/blob/master/comprehension/README.md</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto foo(auto... ts) {
    // syntax: ...[start:stop:step]
    std::cout &lt;&lt; ts...[0] &lt;&lt; '\n';             // prints first element
    ((std::cout &lt;&lt; ts...[0:2]), ...) &lt;&lt; '\n';  // prints frist two elemetns
    ((std::cout &lt;&lt; ts...[::2]), ...) &lt;&lt; '\n';  // prints every second
    ((std::cout &lt;&lt; ts...[::-1]), ...) &lt;&lt; '\n'; // prints in reverse
}

int main() {
    foo(1, 2, 3, 4);
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/Pj7E5cPe1">https://circle.godbolt.org/z/Pj7E5cPe1</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you add missing extened slice expressions on variadic packs to match the requirements?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...};    }(1, 2, 3)); // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{/*TODO*/}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/33P78nG7e">https://circle.godbolt.org/z/33P78nG7e</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[2]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1] ...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[1:3] ...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2] ...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[0:sizeof...(ts)/2] ...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[sizeof...(ts)/2:] ...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/Gn8WETGMY">https://circle.godbolt.org/z/Gn8WETGMY</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[-3:]...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[:sizeof...(ts)/2]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[sizeof...(ts)/2:]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/7b3f5T7bf">https://circle.godbolt.org/z/7b3f5T7bf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[-3:-1:1]...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // evens
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[:sizeof...(ts)/2:]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[sizeof...(ts)/2::]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/fEdn1G6r7">https://circle.godbolt.org/z/fEdn1G6r7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[-3:]... /*[-2:]*/}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[:sizeof...(ts)/2]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[sizeof...(ts)/2:]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/rvh4YGnx6">https://circle.godbolt.org/z/rvh4YGnx6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[1:3]...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[:sizeof...(ts) / 2]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[sizeof...(ts) / 2:]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/qxbbWv4o1">https://circle.godbolt.org/z/qxbbWv4o1</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[1:]...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[:3]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[3:]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/sW7hccoE7">https://circle.godbolt.org/z/sW7hccoE7</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...}; }(1, 2, 3));  // identity
static_assert(std::tuple{2}        == [](auto... ts) { return std::tuple{ts...[1]}; }(1, 2, 3)); // second
static_assert(std::tuple{3}        == [](auto... ts) { return std::tuple{ts...[-1]}; }(1, 2, 3)); // last
static_assert(std::tuple{3, 2, 1}  == [](auto... ts) { return std::tuple{ts...[::-1]...}; }(1, 2, 3)); // reverse
static_assert(std::tuple{2, 3}     == [](auto... ts) { return std::tuple{ts...[-3:]...}; }(1, 2, 3)); // last two
static_assert(std::tuple{2, 4}     == [](auto... ts) { return std::tuple{ts...[1::2]...}; }(1, 2, 3, 4)); // odds
static_assert(std::tuple{1, 2, 3}  == [](auto... ts) { return std::tuple{ts...[0:3]...}; }(1, 2, 3, 4, 5, 6)); // first half
static_assert(std::tuple{4, 5, 6}  == [](auto... ts) { return std::tuple{ts...[3:]...}; }(1, 2, 3, 4, 5, 6)); // second half
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/7cnWsP5Mq">https://circle.godbolt.org/z/7cnWsP5Mq</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>285 - Did you know about C++20 template specialization with concepts?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/285.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/285.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++20 template specialization with concepts?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/temp.constr">https://eel.is/c++draft/temp.constr</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; concept fooable = requires(T t) { t.foo; };
template&lt;class T&gt; concept barable = requires(T t) { t.bar; };

template&lt;class T&gt; constexpr auto foobar = &quot;unknown&quot;sv;
template&lt;fooable T&gt; constexpr auto foobar&lt;T&gt; = &quot;foo&quot;sv;
template&lt;barable T&gt; constexpr auto foobar&lt;T&gt; = &quot;bar&quot;sv;

struct none {};
static_assert(&quot;unknown&quot;sv == foobar&lt;none&gt;);
struct f { int foo; };
static_assert(&quot;foo&quot;sv == foobar&lt;f&gt;);
struct b { int bar; };
static_assert(&quot;bar&quot;sv == foobar&lt;b&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r3ro915Gv">https://godbolt.org/z/r3ro915Gv</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>foobars</code> specialization which is<br />
  { complete : when its passed with <code>fooable/barable</code> type list, in-complete : otherwise}?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; concept fooable = requires(T t) { t.foo; };
template&lt;class T&gt; concept barable = requires(T t) { t.bar; };

template&lt;class...&gt; struct foobars; // TODO

struct none {};
struct f { int foo; };
struct b { int bar; };

template&lt;class T&gt;
concept is_complete = requires { sizeof(T); };

static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;none&gt;, std::tuple&lt;&gt;&gt;&gt;);
static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;none&gt;, std::tuple&lt;none&gt;&gt;&gt;);
static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;b&gt;, std::tuple&lt;&gt;&gt;&gt;);
static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;&gt;, std::tuple&lt;f&gt;&gt;&gt;);
static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;f, b&gt;, std::tuple&lt;b&gt;&gt;&gt;);
static_assert(not is_complete&lt;foobars&lt;std::tuple&lt;f, f, f&gt;, std::tuple&lt;b, f, b&gt;&gt;&gt;);

static_assert(is_complete&lt;foobars&lt;std::tuple&lt;&gt;, std::tuple&lt;&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;std::tuple&lt;f&gt;, std::tuple&lt;&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;std::tuple&lt;f&gt;, std::tuple&lt;b&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;std::tuple&lt;f, f&gt;, std::tuple&lt;b&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;std::tuple&lt;f, f, f&gt;, std::tuple&lt;b, b&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;boost::mp11::mp_list&lt;&gt;, boost::mp11::mp_list&lt;b&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;boost::mp11::mp_list&lt;f&gt;, boost::mp11::mp_list&lt;b&gt;&gt;&gt;);
static_assert(is_complete&lt;foobars&lt;boost::mp11::mp_list&lt;f, f, f&gt;, boost::mp11::mp_list&lt;b, b&gt;&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dzM13WTa3">https://godbolt.org/z/dzM13WTa3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-c++">template&lt;class...&gt; struct foobars;
template&lt;template &lt;typename...&gt; typename FTL, template &lt;typename ...&gt; typename BTL,
         fooable... Fs, barable... Bs&gt;
struct foobars&lt;FTL&lt;Fs...&gt;, BTL&lt;Bs...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M9E9ozjT8">https://godbolt.org/z/M9E9ozjT8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-c++">template &lt;template &lt;typename...&gt; typename TFooables,
          template &lt;typename...&gt; typename TBarables,
          fooable... Fooables,
          barable... Barables&gt;
struct foobars&lt;TFooables&lt;Fooables...&gt;, TBarables&lt;Barables...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7fMK6zazz">https://godbolt.org/z/7fMK6zazz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename, typename&gt;
struct foobars;

template &lt;template &lt;typename...&gt; class TContainer, fooable... TFoos,
          barable... TBars&gt;
struct foobars&lt;TContainer&lt;TFoos...&gt;, TContainer&lt;TBars...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9dWE6MEec">https://godbolt.org/z/9dWE6MEec</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct foobars;

template &lt;template &lt;class...&gt; class TList, fooable... Ts, barable... Us&gt;
struct foobars&lt;TList&lt;Ts...&gt;, TList&lt;Us...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fjY7eP6T1">https://godbolt.org/z/fjY7eP6T1</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct foobars;

template &lt;template &lt;class...&gt; class List, fooable... Ts, barable... Us&gt;
struct foobars&lt;List&lt;Ts...&gt;, List&lt;Us...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EYMWd5vcE">https://godbolt.org/z/EYMWd5vcE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct foobars;

template&lt;template &lt;class...&gt; class TList,
  fooable... TFoos, barable... TBars&gt;
struct foobars&lt;TList&lt;TFoos...&gt;, TList&lt;TBars...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ns7M1KMPd">https://godbolt.org/z/ns7M1KMPd</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct foobars;
template&lt;template&lt;typename...&gt; typename C, fooable... fs, barable... bs&gt;
struct foobars&lt;C&lt;fs...&gt;, C&lt;bs...&gt;&gt; {};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jcGqv3nW3">https://godbolt.org/z/jcGqv3nW3</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>284 - Did you know about C++23 ispanstream - A strstream replacement using span&lt;charT&gt; as buffer?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/284.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/284.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++23 ispanstream - A strstream replacement using span<charT> as buffer?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0448">https://wg21.link/P0448</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;span&gt;
#include &lt;spanstream&gt;
#include &lt;iostream&gt;

int main() {
  char input[] = &quot;1 2 3&quot;;
  std::ispanstream is{std::span&lt;char&gt;{input}};
  int i1, i2, i3;
  is &gt;&gt; i1 &gt;&gt; i2 &gt;&gt; i3;
  std::cout &lt;&lt; i1 &lt;&lt; i2 &lt;&lt; i3; // prints 123
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sxT84Mq6h">https://godbolt.org/z/sxT84Mq6h</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement to_tuple which converts (using ispanstream) given input into tuple of Ts...?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]); // TODO

int main() {
  using namespace boost::ut;

  &quot;to_tuple.ints&quot;_test = [] {
    char input[] = &quot;1 2 3&quot;;
    expect(std::tuple{1, 2, 3} == to_tuple&lt;int, int, int&gt;(input));
  };

  &quot;to_tuple.floats&quot;_test = [] {
    char input[] = &quot;1.2 2.3 3.4&quot;;
    expect(std::tuple{1.2f, 2.3f, 3.4f} == to_tuple&lt;float, float, float&gt;(input));
  };

  &quot;to_tuple.mix&quot;_test = [] {
    char input[] = &quot;42 4.2&quot;;
    expect(std::tuple{42, 4.2d} == to_tuple&lt;int, double&gt;(input));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9z6T11hbq">https://godbolt.org/z/9z6T11hbq</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... Ts&gt;
constexpr auto set_vals(auto tuple, auto&amp; stream) {
  T &amp;val = std::get&lt;std::tuple_size_v&lt;decltype(tuple)&gt; - sizeof...(Ts) - 1&gt;(tuple);
  stream &gt;&gt; val;
  if constexpr (sizeof...(Ts) &gt; 0) {
    tuple = set_vals&lt;Ts...&gt;(tuple, stream);
  }
  return tuple;
}

template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
  std::ispanstream stream{std::span&lt;char&gt;{input}};
  return set_vals&lt;Ts...&gt;(std::tuple&lt;Ts...&gt;{}, stream);
}
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/4f9ssz41x">https://cpp_tip_of_the_week.godbolt.org/z/4f9ssz41x</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;typename TArg&gt;
[[nodiscard]] constexpr auto extract_arg(auto&amp; stream) {
    TArg arg{};
    stream &gt;&gt; arg;
    return arg;
}

}  // namespace detail

template &lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
    std::ispanstream stream{std::span&lt;char&gt;{input}};
    return std::tuple{detail::extract_arg&lt;Ts&gt;(stream)...};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Txn53EKhY">https://godbolt.org/z/Txn53EKhY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
    std::tuple&lt;Ts...&gt; result;
    auto&amp; [...refs] = result;
    std::ispanstream stream{input};
    ((stream &gt;&gt; refs), ...);
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jWxshM7bd">https://godbolt.org/z/jWxshM7bd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
  constexpr auto extract = []&lt;class T&gt;(auto&amp; input) -&gt; T {
    T t{};
    input &gt;&gt; t;
    return t;
  };
  std::ispanstream is{input};
  return std::tuple{extract.template operator()&lt;Ts&gt;(is)...};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/76nd8zr1n">https://godbolt.org/z/76nd8zr1n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt; std::tuple&lt;T&gt; parse(std::ispanstream&amp; is)
{
  T t; is &gt;&gt; t;
  return std::tuple&lt;T&gt;(std::move(t));
}

template &lt;typename T, typename Arg, typename... Args&gt;
std::tuple&lt;T, Arg, Args...&gt; parse(std::ispanstream&amp; is)
{
  T t; is &gt;&gt; t;
  return std::tuple_cat(std::tuple&lt;T&gt;(std::move(t)),
                        parse&lt;Arg, Args...&gt;(is));
}

template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N])
{
    std::ispanstream is{std::span&lt;char&gt;{input}};
    return parse&lt;Ts...&gt;(is);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6EsnE7joY">https://godbolt.org/z/6EsnE7joY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
    auto stream = std::ispanstream{input};
    auto values = std::tuple&lt;Ts...&gt;{};
    std::apply([&amp;](auto&amp;... value) {
        ((stream &gt;&gt; value), ...);
    }, values);
    return values;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r5E8oaW89">https://godbolt.org/z/r5E8oaW89</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
  std::ispanstream is{std::span{input}};
  std::tuple&lt;Ts...&gt; return_values;
  std::apply(
    [&amp;](Ts &amp;... elements) {
      (is &gt;&gt; ... &gt;&gt; elements);
    },
    return_values
  );
  return return_values;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P99ss9ndG">https://godbolt.org/z/P99ss9ndG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
  std::tuple&lt;Ts...&gt; t;
  std::apply(
      [&amp;](Ts &amp;...elements) {
        (std::ispanstream{std::span{input}} &gt;&gt; ... &gt;&gt; elements);
      },
      t);
  return t;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9xxKT5qKE">https://godbolt.org/z/9xxKT5qKE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]){
    std::ispanstream is{std::span&lt;char&gt;{input}};
    std::tuple&lt;Ts...&gt; t;
    [&amp;]&lt;std::size_t... Indices&gt;(std::index_sequence&lt;Indices...&gt;){
        ((is &gt;&gt; std::get&lt;Indices&gt;(t)), ...);
    }(std::make_index_sequence&lt;sizeof...(Ts)&gt;());
    return t;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rWhTToxxK">https://godbolt.org/z/rWhTToxxK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]) {
    std::ispanstream is{std::span{input, N}};
    std::tuple&lt;Ts...&gt; tp;
    [&amp;is, &amp;tp]&lt;size_t... I&gt;(std::index_sequence&lt;I...&gt; const&amp;) {
        ((is &gt;&gt; std::get&lt;I&gt;(tp)), ...);
    }(std::index_sequence_for&lt;Ts...&gt;{});
    return tp;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K8oonfWv7">https://godbolt.org/z/K8oonfWv7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, auto N&gt;
[[nodiscard]] constexpr auto to_tuple(char (&amp;input)[N]){
    std::tuple&lt;Ts...&gt; my_tuple;
    std::apply(
        [&amp;](Ts&amp; ... args){
            (std::ispanstream{std::span{input}} &gt;&gt; ... &gt;&gt; args);
        }, my_tuple
    );
    return my_tuple;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f3WsEc1WE">https://godbolt.org/z/f3WsEc1WE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>283 - Did you know that C++23 added `ranges::to` (conversion from ranges to containers)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/283.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/283.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>ranges::to</code> (conversion from ranges to containers)?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1206">https://wg21.link/P1206</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  auto v = ranges::views::ints | ranges::views::take(2);
  auto o = v | ranges::to&lt;std::vector&gt;();
  assert(std::size(o) == 2 and o[0] == 0 and o[1] == 1);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wq4h347WG">https://godbolt.org/z/Wq4h347WG</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_vector</code> which converts given range into vector using ranges/stl?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    // TODO
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    // TODO
}
} // test::stl

int main() {
  using boost::ut::operator &quot;&quot;_test;
  using boost::ut::expect;

  auto test = [](auto to_vector) {
    &quot;ranges.to&quot;_test = [=] {
        &quot;view&quot;_test = [=] {
            const auto view = ranges::views::ints | ranges::views::take(3);
            expect(std::vector{0, 1, 2} == to_vector(view));
        };

        &quot;list&quot;_test = [=] {
            const std::list l{1, 2, 3};
            expect(std::vector{1, 2, 3} == to_vector(l));
        };

        &quot;string&quot;_test = [=] {
            const std::string s = &quot;str&quot;;
            expect(std::vector{'s', 't', 'r'} == to_vector(s));
        };
    };
  };

  test([](auto... ts) { return test::ranges::to_vector(ts...); });
  test([](auto... ts) { return test::stl::to_vector(ts...); });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cPboh4nav">https://godbolt.org/z/cPboh4nav</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {

[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}

}  // namespace test::ranges

namespace test::stl {

[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    using value_type =
        std::remove_cvref_t&lt;decltype(*std::ranges::begin(range))&gt;;
    std::vector&lt;value_type&gt; output{};
    if constexpr (requires { std::size(range); }) {
        output.reserve(std::size(range));
    }
    std::ranges::copy(std::ranges::begin(range), std::ranges::end(range),
                      std::back_inserter(output));
    return output;
}

}  // namespace test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s7aKThfos">https://godbolt.org/z/s7aKThfos</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    auto cv = ::ranges::views::common(range);
    return std::vector(cv.begin(), cv.end());
}
}  // namespace test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    auto cv = ::std::ranges::views::common(std::move(range));
    return std::vector(cv.begin(), cv.end());
}
}  // namespace test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/onqh7z3nz">https://godbolt.org/z/onqh7z3nz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}
}  // namespace test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
  std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt; ret;
  if constexpr(std::ranges::sized_range&lt;decltype(range)&gt;) {
    ret.reserve(std::ranges::size(range));
  }
  std::ranges::copy(range, std::back_inserter(ret));
  return ret;
}
}  // namespace test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d6jW731zc">https://godbolt.org/z/d6jW731zc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    // TODO
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    // TODO
}
} // test::stl

int main() {
  using boost::ut::operator &quot;&quot;_test;
  using boost::ut::expect;

  auto test = [](auto to_vector) {
    &quot;ranges.to&quot;_test = [=] {
        &quot;view&quot;_test = [=] {
            const auto view = ranges::views::ints | ranges::views::take(3);
            expect(std::vector{0, 1, 2} == to_vector(view));
        };

        &quot;list&quot;_test = [=] {
            const std::list l{1, 2, 3};
            expect(std::vector{1, 2, 3} == to_vector(l));
        };

        &quot;string&quot;_test = [=] {
            const std::string s = &quot;str&quot;;
            expect(std::vector{'s', 't', 'r'} == to_vector(s));
        };
    };
  };

  test([](auto... ts) { return test::ranges::to_vector(ts...); });
  test([](auto... ts) { return test::stl::to_vector(ts...); });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cPboh4nav">https://godbolt.org/z/cPboh4nav</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
  return ::ranges::to&lt;std::vector&gt;(std::move(range));
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
  auto v = std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt;{};
  v.reserve(std::ranges::distance(std::ranges::begin(range), std::ranges::end(range)));
  std::ranges::copy(std::ranges::begin(range), std::ranges::end(range), std::back_inserter(v));
  return v;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E4ns1M7dr">https://godbolt.org/z/E4ns1M7dr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return ::ranges::to&lt;std::vector&gt;(range);
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt; output{};
    output.reserve(std::ranges::size(range));
    std::ranges::copy(range.begin(), range.end(), std::back_inserter(output));
    return output;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vvPKex7r9">https://godbolt.org/z/vvPKex7r9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return std::move(range) | ::ranges::to&lt;std::vector&gt;();
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    auto vec = std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt;{};
    vec.reserve(std::ranges::size(range));
    std::ranges::move(range, std::back_inserter(vec));
    return vec;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eKaejMz3r">https://godbolt.org/z/eKaejMz3r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jKT3c7Y8K">https://godbolt.org/z/jKT3c7Y8K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt; vec{};
    vec.reserve(std::ranges::size(range));
    std::ranges::copy(std::ranges::begin(range), std::ranges::end(range), std::back_inserter(vec));
    return vec;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aaGdM1x7M">https://godbolt.org/z/aaGdM1x7M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return range | ::ranges::to&lt;std::vector&gt;();
}
} // test::ranges

namespace test::stl {
template &lt;::std::ranges::range R&gt;
[[nodiscard]] constexpr auto to_vector(R range) {
    auto vec = std::vector&lt;std::ranges::range_value_t&lt;R&gt;&gt;{};
    std::ranges::copy(range, std::back_inserter(vec));
    return vec;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5fovezv5W">https://godbolt.org/z/5fovezv5W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt; v;
    std::ranges::copy(range, std::back_inserter(v));
    return v;
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    using iT = std::ranges::iterator_t&lt;decltype(range)&gt;;
    using T = std::ranges::range_value_t&lt;decltype(range)&gt;;
    std::vector&lt;T&gt; v;
    for(iT iE = range.begin(); iE !=range.end(); iE++)
        v.push_back(*iE);
    return v;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P18j1q64h">https://godbolt.org/z/P18j1q64h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace test::ranges {
[[nodiscard]] constexpr auto to_vector(std::ranges::range auto range) {
    return ::ranges::to&lt;std::vector&gt;(range);
}
} // test::ranges

namespace test::stl {
[[nodiscard]] constexpr auto to_vector(::std::ranges::range auto range) {
    std::vector&lt;std::ranges::range_value_t&lt;decltype(range)&gt;&gt; v;
    if constexpr(std::ranges::sized_range&lt;decltype(range)&gt;) {
        v.reserve(std::ranges::size(range));
    }
    std::ranges::copy(range, std::back_inserter(v));
    return v;
}
} // test::stl
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6Mvv4fzPo">https://godbolt.org/z/6Mvv4fzPo</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>282 - Did you know about introduced in C++20 `object concepts`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/282.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/282.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about introduced in C++20 <code>object concepts</code>?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/concepts.object">http://eel.is/c++draft/concepts.object</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

struct movable {
  constexpr movable(movable&amp;&amp;) = default;
  constexpr auto operator=(movable &amp;&amp;) -&gt; movable &amp; = default;
};

static_assert(std::movable&lt;movable&gt;)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f3fco5M6K">https://godbolt.org/z/f3fco5M6K</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you fulfill given types so that they will satisfy provided object concepts?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

struct movable; // TODO
struct not_movable; // TODO

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable; // TODO
struct not_copyable; // TODO

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular; // TODO
struct semiregular; // TODO

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular; // TODO
struct regular; // TODO

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P8E77Paxa">https://godbolt.org/z/P8E77Paxa</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

struct movable {};
struct not_movable {
    // Either of these works - both for completeness
    not_movable(not_movable&amp;&amp;) = delete;
    not_movable&amp; operator=(not_movable&amp;&amp;) = delete;
};

static_assert(std::movable&lt;movable&gt;);
static_assert(not std::movable&lt;not_movable&gt;);

struct copyable {};
struct not_copyable {
    // Either of these works - both for completeness
    not_copyable(const not_copyable&amp;) = delete;
    not_copyable&amp; operator=(const not_copyable&amp;) = delete;
};

static_assert(std::copyable&lt;copyable&gt;);
static_assert(not std::copyable&lt;not_copyable&gt;);

struct semiregular {};
struct not_semiregular {
    // Any of these works - all for completeness
    constexpr not_semiregular(auto) {}
    not_semiregular(const not_semiregular&amp;) = delete;
    not_semiregular&amp; operator=(const not_semiregular&amp;) = delete;
};

static_assert(std::semiregular&lt;semiregular&gt;);
static_assert(not std::semiregular&lt;not_semiregular&gt;);

struct regular {
    constexpr bool operator==(const regular&amp;) const = default;
};
struct not_regular {};

static_assert(std::regular&lt;regular&gt;);
static_assert(not std::regular&lt;not_regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ja13qbc8j">https://godbolt.org/z/ja13qbc8j</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#include &lt;concepts&gt;

struct movable{};
struct not_movable{
  constexpr not_movable(not_movable&amp;&amp;) = delete;
  constexpr auto operator=(not_movable &amp;&amp;) -&gt; not_movable &amp; = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable{};
struct not_copyable{
  constexpr not_copyable(not_copyable&amp;) = delete;
  constexpr auto operator=(not_copyable &amp;) -&gt; not_copyable &amp; = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular{
  constexpr not_semiregular(auto) {}
  constexpr not_semiregular(not_semiregular&amp;) = default;
  constexpr auto operator=(not_semiregular &amp;) -&gt; not_semiregular &amp; = default;
};
struct semiregular{};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular{};
struct regular{
    constexpr bool operator==(regular const&amp;) const = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/Mzjzz3eKW">https://cpp_tip_of_the_week.godbolt.org/z/Mzjzz3eKW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {};
struct not_movable{not_movable(not_movable&amp;&amp;)=delete;};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {};
struct not_copyable {not_copyable(const not_copyable&amp;)=delete;};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular { not_semiregular()=delete; };
struct semiregular {};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular {};
struct regular {bool operator==(const regular&amp;) const = default;};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aYMre189a">https://godbolt.org/z/aYMre189a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {};
struct not_movable {
  constexpr not_movable(const not_movable&amp;) = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {};
struct not_copyable {
  constexpr not_copyable(not_copyable&amp;&amp;) = default;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular { not_semiregular() = delete; }; // unnfortunately
struct semiregular {};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular {};
struct regular {
  friend constexpr auto operator==(regular, regular) -&gt; bool = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xY49zG9KP">https://godbolt.org/z/xY49zG9KP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {};
struct not_movable {
  not_movable(not_movable &amp;&amp;) = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {};
struct not_copyable {
  not_copyable(const not_copyable &amp;) = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct semiregular {};
struct not_semiregular {
  not_semiregular() = delete;
};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular {};
struct regular {
  constexpr auto operator==(const regular &amp;) const -&gt; bool = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/44748dedf">https://godbolt.org/z/44748dedf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {};
struct not_movable{
    constexpr auto operator=(not_movable &amp;&amp;) = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {};
struct not_copyable {
    constexpr not_copyable(not_copyable &amp;) = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct semiregular {};
struct not_semiregular {
    constexpr not_semiregular(not_semiregular &amp;) = delete;
    constexpr not_semiregular() = delete;
};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular{};
struct regular{
    constexpr bool operator&lt;=&gt;(const regular&amp;) const = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cKfqzbnaG">https://godbolt.org/z/cKfqzbnaG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {
    constexpr movable(movable&amp;&amp;) = default;
    constexpr auto operator=(movable&amp;&amp;) -&gt; movable&amp; = default;
};
struct not_movable {
    constexpr not_movable(not_movable&amp;&amp;) = delete;
    constexpr auto operator=(not_movable&amp;&amp;) -&gt; not_movable&amp; = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {
    constexpr copyable(const copyable&amp;) = default;
    constexpr auto operator=(const copyable&amp;) -&gt; copyable&amp; = default;
};

struct not_copyable {
    constexpr not_copyable(const not_copyable&amp;) = delete;
    constexpr auto operator=(const not_copyable&amp;) -&gt; not_copyable&amp; = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular {
    constexpr not_semiregular() = delete;
    constexpr not_semiregular(const not_semiregular&amp;) = delete;
    constexpr auto operator=(const not_semiregular&amp;) -&gt; not_semiregular&amp; = default;
};

struct semiregular {
    constexpr semiregular() = default;
    constexpr semiregular(const semiregular&amp;) = default;
    constexpr auto operator=(const semiregular&amp;) -&gt; semiregular&amp; = default;
};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular {
    constexpr not_regular() = delete;
    constexpr not_regular(const not_regular&amp;) = delete;
    constexpr auto operator==(const not_regular&amp;) const -&gt; bool = delete;
};

struct regular {
    constexpr regular() = default;
    constexpr regular(const regular&amp;) = default;
    constexpr auto operator==(const regular&amp;) const -&gt; bool = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nT1T33EWa">https://godbolt.org/z/nT1T33EWa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable{
    constexpr movable() = delete;
    constexpr movable(const movable &amp;) = delete;
    constexpr movable(movable &amp;&amp;) = default;
    constexpr auto operator=(movable &amp;&amp;) -&gt; movable&amp; = default;
    constexpr auto operator=(const movable &amp;) -&gt; movable&amp; = delete;
    constexpr auto operator==(const movable &amp;) const -&gt; bool = delete;
};
struct not_movable{
    constexpr not_movable() = default;
    constexpr not_movable(const not_movable &amp;) = default;
    constexpr not_movable(not_movable &amp;&amp;) = delete;
    constexpr auto operator=(not_movable &amp;&amp;) -&gt; not_movable&amp; = delete;
    constexpr auto operator=(const not_movable &amp;) -&gt; not_movable&amp; = default;
    constexpr auto operator==(const not_movable &amp;) const -&gt; bool = default;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable{
    constexpr copyable() = delete;
    constexpr copyable(const copyable &amp;) = default;
    constexpr copyable(copyable &amp;&amp;) = default;
    constexpr auto operator=(copyable &amp;&amp;) -&gt; copyable&amp; = default;
    constexpr auto operator=(const copyable &amp;) -&gt; copyable&amp; = default;
    constexpr auto operator==(const copyable &amp;) const -&gt; bool = delete;
};
struct not_copyable{
    constexpr not_copyable() = default;
    constexpr not_copyable(const not_copyable &amp;) = delete;
    constexpr not_copyable(not_copyable &amp;&amp;) = delete;
    constexpr auto operator=(not_copyable &amp;&amp;) -&gt; not_copyable&amp; = delete;
    constexpr auto operator=(const not_copyable &amp;) -&gt; not_copyable&amp; = delete;
    constexpr auto operator==(const not_copyable &amp;) const -&gt; bool = default;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular{
    constexpr not_semiregular() = delete;
    constexpr not_semiregular(const not_semiregular &amp;) = delete;
    constexpr not_semiregular(not_semiregular &amp;&amp;) = delete;
    constexpr auto operator=(not_semiregular &amp;&amp;) -&gt; not_semiregular&amp; = delete;
    constexpr auto operator=(const not_semiregular &amp;) -&gt; not_semiregular&amp; = delete;
    constexpr auto operator==(const not_semiregular &amp;) const -&gt; bool = default;

};
struct semiregular{
    constexpr semiregular() = default;
    constexpr semiregular(const semiregular &amp;) = default;
    constexpr semiregular(semiregular &amp;&amp;) = default;
    constexpr auto operator=(semiregular &amp;&amp;) -&gt; semiregular&amp; = default;
    constexpr auto operator=(const semiregular &amp;) -&gt; semiregular&amp; = default;
    constexpr auto operator==(const semiregular &amp;) const -&gt; bool = delete;
};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular{
    constexpr not_regular() = delete;
    constexpr not_regular(const not_regular &amp;) = delete;
    constexpr not_regular(not_regular &amp;&amp;) = delete;
    constexpr auto operator=(not_regular &amp;&amp;) -&gt; not_regular&amp; = delete;
    constexpr auto operator=(const not_regular &amp;) -&gt; not_regular&amp; = delete;
    constexpr auto operator==(const not_regular &amp;) const -&gt; bool = delete;

};
struct regular{
    constexpr regular() = default;
    constexpr regular(const regular &amp;) = default;
    constexpr regular(regular &amp;&amp;) = default;
    constexpr auto operator=(regular &amp;&amp;) -&gt; regular&amp; = default;
    constexpr auto operator=(const regular &amp;) -&gt; regular&amp; = default;
    constexpr auto operator==(const regular &amp;) const -&gt; bool = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fWodj4KaP">https://godbolt.org/z/fWodj4KaP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {};
struct not_movable {
    not_movable(not_movable &amp;&amp;) = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {};
struct not_copyable {
    not_copyable(const not_copyable&amp;) = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular {
    not_semiregular(int) {}
};
struct semiregular {};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular {};
struct regular {
    constexpr bool operator==(const regular&amp;) const = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/drWv4c6d7">https://godbolt.org/z/drWv4c6d7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable{};
struct not_movable{
    constexpr not_movable(not_movable&amp;&amp;) = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable{};
struct not_copyable{
    constexpr not_copyable(const not_copyable&amp;) = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct not_semiregular{
    constexpr not_semiregular() = delete;
};
struct semiregular{};

static_assert(not std::semiregular&lt;not_semiregular&gt;);
static_assert(std::semiregular&lt;semiregular&gt;);

struct not_regular{};
struct regular{
    constexpr auto operator==(const regular&amp;) const -&gt; bool = default;
};

static_assert(not std::regular&lt;not_regular&gt;);
static_assert(std::regular&lt;regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y4a64a8Gr">https://godbolt.org/z/Y4a64a8Gr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct movable {
  constexpr movable(movable&amp;&amp;) = default;
  constexpr auto operator=(movable &amp;&amp;) -&gt; movable &amp; = default;
};
struct not_movable {
  constexpr not_movable(not_movable&amp;&amp;) = delete;
  constexpr auto operator=(not_movable &amp;&amp;) -&gt; not_movable &amp; = delete;
};

static_assert(not std::movable&lt;not_movable&gt;);
static_assert(std::movable&lt;movable&gt;);

struct copyable {
  constexpr copyable(const copyable&amp;) = default;
  constexpr copyable(copyable&amp;&amp;) = default;
  constexpr auto operator=(const copyable &amp;) -&gt; copyable &amp; = default;
  constexpr auto operator=(copyable &amp;&amp;) -&gt; copyable &amp; = default;
};
struct not_copyable {
  constexpr not_copyable(const not_copyable&amp;) = delete;
  constexpr not_copyable(not_copyable&amp;&amp;) = delete;
  constexpr auto operator=(const not_copyable &amp;) -&gt; not_copyable &amp; = delete;
  constexpr auto operator=(not_copyable &amp;&amp;) -&gt; not_copyable &amp; = delete;
};

static_assert(not std::copyable&lt;not_copyable&gt;);
static_assert(std::copyable&lt;copyable&gt;);

struct semiregular {
  constexpr semiregular() = default;
  constexpr semiregular(const semiregular&amp;) = default;
  constexpr semiregular(semiregular&amp;&amp;) = default;
  constexpr auto operator=(const semiregular &amp;) -&gt; semiregular &amp; = default;
  constexpr auto operator=(semiregular &amp;&amp;) -&gt; semiregular &amp; = default;
};
struct not_semiregular {
  constexpr not_semiregular() = delete;
  constexpr not_semiregular(const not_semiregular&amp;) = delete;
  constexpr not_semiregular(not_semiregular&amp;&amp;) = delete;
  constexpr auto operator=(const not_semiregular &amp;) -&gt; not_semiregular &amp; = delete;
  constexpr auto operator=(not_semiregular &amp;&amp;) -&gt; not_semiregular &amp; = delete;
};

static_assert(std::semiregular&lt;semiregular&gt;);
static_assert(not std::semiregular&lt;not_semiregular&gt;);

struct regular {
  constexpr regular() = default;
  constexpr regular(const regular&amp;) = default;
  constexpr regular(regular&amp;&amp;) = default;
  constexpr auto operator=(const regular &amp;) -&gt; regular &amp; = default;
  constexpr auto operator=(regular &amp;&amp;) -&gt; regular &amp; = default;
  constexpr auto operator==(const regular&amp;) const -&gt; bool = default;
};

struct not_regular {
  constexpr not_regular() = delete;
  constexpr not_regular(const not_regular&amp;) = delete;
  constexpr not_regular(not_regular&amp;&amp;) = delete;
  constexpr auto operator=(const not_regular &amp;) -&gt; not_regular &amp; = delete;
  constexpr auto operator=(not_regular &amp;&amp;) -&gt; not_regular &amp; = delete;
  constexpr auto operator==(const not_regular&amp;) const -&gt; bool = delete;
};

static_assert(std::regular&lt;regular&gt;);
static_assert(not std::regular&lt;not_regular&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nhKaYas7j">https://godbolt.org/z/nhKaYas7j</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>281 - Did you know about gtest.gmock mocking framework?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/281.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/281.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about gtest.gmock mocking framework?</strong></p>
</li>
<li>
<p><a href="https://google.github.io/googletest/gmock_for_dummies.html">https://google.github.io/googletest/gmock_for_dummies.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;gmock/gmock.h&gt;

struct mock {
  MOCK_METHOD(void, on, (int));
};

int main() {
  StrictMock&lt;mock&gt; mock{};
  EXPECT_CALL(mock, on(42));
  mock.on(43); // failure : Unexpected mock function call
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s1dvcj4Td">https://godbolt.org/z/s1dvcj4Td</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement generic-strict <code>mock_on</code> for on calls with given types...?</strong></p>
</li>
<li>
<p>Note: Inheritance from <code>StrictMock&lt;T&gt;</code> for each <code>T</code> in <code>TEvents</code> is required</p>
<ul>
<li><a href="https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy">https://google.github.io/googletest/gmock_cook_book.html#NiceStrictNaggy</a></li>
</ul>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TEvents&gt;
struct mock_on; // TODO

template&lt;class T&gt;
class foo {
  public:
    explicit(true) foo(const T&amp; t) : t_{t} { }

    auto run(const auto&amp; event) const -&gt; void {
        t_.on(event);
    }

  private:
    const T&amp; t_;
};

int main() {
    struct event1 { constexpr auto operator&lt;=&gt;(const event1&amp;) const = default; } event1;
    struct event2 { constexpr auto operator&lt;=&gt;(const event2&amp;) const = default; } event2;
    struct event3 { constexpr auto operator&lt;=&gt;(const event3&amp;) const = default; } event3;

    &quot;mock single event&quot;_test = [&amp;] {
        mock_on&lt;decltype(event1)&gt; mock{};
        foo foo{mock};

        EXPECT_CALL(mock, on(event1));

        foo.run(event1);
    };

    &quot;mock mutliple events&quot;_test = [&amp;] {
        mock_on&lt;decltype(event1), decltype(event2), decltype(event3)&gt; mock{};
        foo foo{mock};

        EXPECT_CALL(mock, on(event1));
        EXPECT_CALL(mock, on(event2));
        EXPECT_CALL(mock, on(event3));

        foo.run(event1);
        foo.run(event2);
        foo.run(event3);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9d5Gq1M7x">https://godbolt.org/z/9d5Gq1M7x</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;typename TEvent&gt;
struct mock_on_impl
{
    MOCK_METHOD(void, on, (TEvent), (const));
};

template&lt;typename...TEvents&gt;
struct mock_on : mock_on_impl&lt;TEvents&gt;...
{
    using mock_on_impl&lt;TEvents&gt;::gmock_on...;
    using mock_on_impl&lt;TEvents&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/551zWc1xW">https://godbolt.org/z/551zWc1xW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class TEvent&gt;
struct mock_on_impl {
    MOCK_METHOD(void, on, (TEvent), (const));
};

}  // namespace detail

template &lt;class... TEvents&gt;
struct mock_on : testing::StrictMock&lt;detail::mock_on_impl&lt;TEvents&gt;&gt;... {
    using detail::mock_on_impl&lt;TEvents&gt;::on...;
    using detail::mock_on_impl&lt;TEvents&gt;::gmock_on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/16ex6b9hn">https://godbolt.org/z/16ex6b9hn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template &lt;class TEvent&gt;
  struct mock {
    MOCK_METHOD(void, on, (const TEvent&amp;), (const));
  };
}

template &lt;class... TEvents&gt;
struct mock_on : ::testing::StrictMock&lt;detail::mock&lt;TEvents&gt;&gt;... {
  using ::testing::StrictMock&lt;detail::mock&lt;TEvents&gt;&gt;::on...;
  using ::testing::StrictMock&lt;detail::mock&lt;TEvents&gt;&gt;::gmock_on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EerzEKM48">https://godbolt.org/z/EerzEKM48</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class TEvent&gt;
struct on_impl {
    MOCK_METHOD(void, on, (const TEvent&amp;), (const));
};

template &lt;class... TEvents&gt;
struct mock_on : testing::StrictMock&lt;on_impl&lt;TEvents&gt;&gt;... {
    using testing::StrictMock&lt;on_impl&lt;TEvents&gt;&gt;::on...;
    using testing::StrictMock&lt;on_impl&lt;TEvents&gt;&gt;::gmock_on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1vqeY4nGf">https://godbolt.org/z/1vqeY4nGf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;int N&gt; struct None{};

template&lt;class TEvent1, class TEvent2 = None&lt;0&gt; , class TEvent3 = None&lt;1&gt; &gt;
struct mock_on {
    MOCK_METHOD(void, on, (TEvent1), (const));
    MOCK_METHOD(void, on, (TEvent2), (const));
    MOCK_METHOD(void, on, (TEvent3), (const));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n557c9oP3">https://godbolt.org/z/n557c9oP3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class TEvent&gt;
struct mock{
    MOCK_METHOD(void, on, (const TEvent&amp;), (const));
};

template&lt;class... TEvents&gt;
struct mock_on : ::testing::StrictMock&lt;mock&lt;TEvents&gt;&gt;...{
    using ::testing::StrictMock&lt;mock&lt;TEvents&gt;&gt;::on...;
    using ::testing::StrictMock&lt;mock&lt;TEvents&gt;&gt;::gmock_on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MnasrTYrh">https://godbolt.org/z/MnasrTYrh</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>280 - Did you know about use cases for type-based `reserved` decorator?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/280.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/280.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about use cases for type-based <code>reserved</code> decorator?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/#containers">http://eel.is/c++draft/#containers</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t Size&gt;
struct reserved : T {
  constexpr reserved() {
    T::reserve(Size);
  }
};

int main() {
  std::cout &lt;&lt; std::vector&lt;int&gt;{}.capacity();               // prints 0
  std::cout &lt;&lt; reserved&lt;std::vector&lt;int&gt;, 42&gt;{}.capacity(); // prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sKKzzx64z">https://godbolt.org/z/sKKzzx64z</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you extend <code>reserved</code> to support inherited constructors from type T?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved; // TODO

int main() {
    using namespace boost::ut;

    &quot;reserved&quot;_test = [] {
        &quot;default ctor&quot;_test = [] {
            reserved&lt;boost::container::flat_map&lt;int, int&gt;, 42&gt; map{};
            expect(0_u == map.size());
            expect(42_u == map.capacity());
        };

        &quot;reserved with constructor&quot;_test = [] {
            reserved&lt;std::vector&lt;int&gt;, 42&gt; v(2, 100);
            expect(2_u == v.size());
            expect(42_u == v.capacity());
            expect(100_i == v[0]);
            expect(100_i == v[1]);
        };

        &quot;reserved with initializer constructor&quot;_test = [] {
            reserved&lt;std::vector&lt;int&gt;, 42&gt; v{
                1,
                2,
            };
            expect(2_u == v.size());
            expect(42_u == v.capacity());
            expect(1 == v[0]);
            expect(2 == v[1]);
        };
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5f71s4jh6">https://godbolt.org/z/5f71s4jh6</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  constexpr reserved(auto ...args) : T(args...) {
    T::reserve(Size);
  }

  template&lt;typename TVal&gt;
  constexpr reserved(std::initializer_list&lt;TVal&gt;&amp;&amp; list) : T{list} {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mvbcnbshb">https://godbolt.org/z/Mvbcnbshb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t Size&gt;
struct reserved : T {
  constexpr reserved()  {
    T::reserve(Size);
  }

  constexpr reserved(std::size_t size, auto&amp;&amp; arg) : T(size, arg) {
    T::reserve(Size);
  }

  template&lt;typename Arg&gt;
  constexpr reserved(std::initializer_list&lt;Arg&gt;&amp;&amp; arg) : T{arg} {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/rM4n1aTf4">https://cpp_tip_of_the_week.godbolt.org/z/rM4n1aTf4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#define FWD(...) static_cast&lt;decltype(__VA_ARGS__)&amp;&amp;&gt;(__VA_ARGS__)

template &lt;class T, auto Size&gt;
struct reserved : T {
    [[nodiscard]] constexpr reserved(auto&amp;&amp;... args) : T(FWD(args)...) {
        T::reserve(Size);
    }

    template &lt;typename TValue&gt;
    [[nodiscard]] constexpr reserved(std::initializer_list&lt;TValue&gt;&amp;&amp; list)
        : T{FWD(list)} {
        T::reserve(Size);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GdaW7srYv">https://godbolt.org/z/GdaW7srYv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
    template &lt;typename M&gt;
    constexpr reserved(std::initializer_list&lt;M&gt; list) {
        T::reserve(Size);
        T::insert(std::end(*this), std::begin(list), std::end(list));
    }

    constexpr reserved(auto&amp;&amp;...args) : T(std::forward&lt;decltype(args)&gt;(args)...) {
        T::reserve(Size);
    }

};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WjxWxfGxs">https://godbolt.org/z/WjxWxfGxs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  template &lt;typename... TArgs&gt;
  constexpr reserved(TArgs&amp;&amp;... args)
    requires requires { T(std::forward&lt;TArgs&gt;(args)...); }
    : T(std::forward&lt;TArgs&gt;(args)...) {
    T::reserve(Size);
  }

  template &lt;typename TArg&gt;
  constexpr reserved(std::initializer_list&lt;TArg&gt; init)
    requires requires { T{init}; }
    : T{init} {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1dzGEfovx">https://godbolt.org/z/1dzGEfovx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  template &lt;typename... Args&gt;
  constexpr reserved(Args&amp;&amp;... args) : T(std::forward&lt;Args&gt;(args)...) {
    T::reserve(Size);
  }
  template &lt;typename L&gt;
  constexpr reserved(std::initializer_list&lt;L&gt; l ) : T(l) {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sYxxfEejT">https://godbolt.org/z/sYxxfEejT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  template &lt;class... Args&gt;
  constexpr reserved(Args &amp;&amp;...args)
    requires requires { T(std::forward&lt;Args&gt;(args)...); }
  : T(std::forward&lt;Args&gt;(args)...) {
    T::reserve(Size);
  }

  template &lt;class U&gt;
  constexpr reserved(std::initializer_list&lt;U&gt; init)
    requires requires { T(init); }
  : T(init) {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h7exGhTfe">https://godbolt.org/z/h7exGhTfe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
    constexpr reserved() {
        T::reserve(Size);
    }

    template&lt;typename ... C&gt;
    constexpr reserved(C ...args) : T(args...) {
        T::reserve(Size);
    }

    template&lt;typename D&gt;
    constexpr reserved(std::initializer_list&lt;D&gt; init) : T(init) {
        T::reserve(Size);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dj7oxKhcz">https://godbolt.org/z/dj7oxKhcz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
    template &lt;typename U&gt;
    constexpr reserved(std::initializer_list&lt;U&gt; ilist)
    requires requires { T(ilist); }
    : T(ilist) {
        T::reserve(Size);
    }

    constexpr reserved(auto&amp;&amp;... args)
    requires requires { T(std::forward&lt;decltype(args)&gt;(args)...); }
    : T(std::forward&lt;decltype(args)&gt;(args)...) {
        T::reserve(Size);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/scn4h66Gv">https://godbolt.org/z/scn4h66Gv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  using AllocType = typename T::allocator_type;
  using SizeType  = typename T::size_type;
  using ValueType = typename T::value_type;

  constexpr reserved(){
    T::reserve(Size);
  }

  constexpr reserved(SizeType n,
                     const std::integral auto &amp;val,
                     const AllocType&amp; alloc = AllocType()) : T(n, val, alloc){
    T::reserve(Size);
  }

  constexpr reserved( std::initializer_list&lt;ValueType&gt; init,
                      const AllocType&amp; alloc = AllocType() ) : T{init, alloc} {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qhhY9TM1f">https://godbolt.org/z/qhhY9TM1f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
    template &lt;class... Args&gt;
    constexpr reserved(Args&amp;&amp;... args) : T(std::forward&lt;Args&gt;(args)...) {
        T::reserve(Size);
    }

    template &lt;class Arg&gt;
    constexpr reserved(std::initializer_list&lt;Arg&gt; arg) : T(arg) {
        T::reserve(Size);
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fK6sdT3TP">https://godbolt.org/z/fK6sdT3TP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
    template &lt;class... U&gt;
    constexpr reserved(U&amp;&amp;... args) : T(std::forward&lt;U&gt;(args)...) {
        T::reserve(Size);
    }
    template &lt;class U&gt;
    constexpr reserved(std::initializer_list&lt;U&gt; init) : T(init) {
        T::reserve(Size);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Tccd7aGjE">https://godbolt.org/z/Tccd7aGjE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T
{
    reserved(auto&amp;&amp;... args) : T(std::forward&lt;decltype(args)&gt;(args)...)
    {
        T::reserve(Size);
    }

    reserved(std::initializer_list&lt;typename T::value_type&gt; l) : T{l}
    {
        T::reserve(Size);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zn1c9q4qM">https://godbolt.org/z/zn1c9q4qM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Size&gt;
struct reserved : T {
  constexpr reserved(auto... args) : T(args...){
    T::reserve(Size);
  }

  template &lt;typename TL&gt;
  constexpr reserved(  std::initializer_list&lt;TL&gt; tl) : T(tl) {
    T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/19vrWffv7">https://godbolt.org/z/19vrWffv7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t Size&gt;
struct reserved : T {
  constexpr reserved(std::initializer_list&lt;typename T::value_type&gt; const &amp;items):T(items){
      T::reserve(Size);
  }
  constexpr reserved(auto&amp;&amp;... args):T(args...){
      T::reserve(Size);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s9nWdYWGs">https://godbolt.org/z/s9nWdYWGs</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>279 - Did you know that C++20 made `std::string` constexpr?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/279.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/279.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++20 made <code>std::string</code> constexpr?</p>
</li>
<li>
<p><a href="https://wg21.link/P0980R1">https://wg21.link/P0980R1</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;string&gt;

constexpr auto foo() {
  return std::string{&quot;bar&quot;};
}

static_assert(&quot;bar&quot; == foo());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P9qW6jYav">https://godbolt.org/z/P9qW6jYav</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>concat</code> which concatenates given strings?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args); // TODO

static_assert(&quot;&quot;s == concat());
static_assert(&quot;a&quot;s == concat([]{return &quot;a&quot;s;}));
static_assert(&quot;ab&quot;s == concat([]{return &quot;a&quot;s;}, []{return &quot;b&quot;s;}));
static_assert(&quot;abc&quot;s == concat([]{return &quot;a&quot;s;}, []{return &quot;b&quot;s;}, []{return &quot;c&quot;s;}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6MaMqrKzE">https://godbolt.org/z/6MaMqrKzE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args) {
    return ( &quot;&quot;s + ... + args() );
}
</code></pre>

<blockquote>
<p><a href="https://cpp_tip_of_the_week.godbolt.org/z/3f7fh4Yd5">https://cpp_tip_of_the_week.godbolt.org/z/3f7fh4Yd5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args) {
    std::string result{};
    (result.append(args()), ...);
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xh8oancaf">https://godbolt.org/z/xh8oancaf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args) {
  return (args() + ... + std::string{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rjPz7qnn8">https://godbolt.org/z/rjPz7qnn8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args){
    if constexpr(sizeof...(args) &gt; 0){
        return std::string{(args() + ...)};
    }
    return std::string{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c4eojWhTs">https://godbolt.org/z/c4eojWhTs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto concat(auto... args) {
    return (args() + ... + &quot;&quot;s);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TeEcEWcra">https://godbolt.org/z/TeEcEWcra</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>278 - Did you know that C++23 added Literal Suffix for (signed) size_t?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/278.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/278.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added Literal Suffix for (signed) size_t?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p0330">https://wg21.link/p0330</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(-42 == -42z);
static_assert(-42 == -42Z);
static_assert(42 == 42uz);
static_assert(42 == 42uZ);
static_assert(42 == 42Uz);
static_assert(42 == 42ZU);
static_assert(42 == 42Zu);

static_assert(std::is_same_v&lt;std::size_t, decltype(42uz)&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wxe9Kfze3">https://godbolt.org/z/Wxe9Kfze3</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you make the following snippets compatible with 32/64 bit arch?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
    std::vector v{1, 2, 3};

    for (auto i = 0; i &lt; v.size(); ++i) {
    }

    for (auto i = 0, s = std::size(v); i &lt; s; ++i) {
    }

    std::max(0, std::ssize(v));
    std::min(0, std::size(v));
      std::max(0, std::min(0, v.size()));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EEdfz5451">https://godbolt.org/z/EEdfz5451</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">for (auto i = 0uz; i &lt; v.size(); ++i) {
}

for (auto i = 0uz, s = std::size(v); i &lt; s; ++i) {
}

std::max(0z, std::ssize(v));
std::min(0uz, std::size(v));
std::max(0uz, std::min(0uz, v.size()));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dfTbhx1r7">https://godbolt.org/z/dfTbhx1r7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#include &lt;array&gt; // Change vector to array for elision of generated code. :)

int main() {
  std::array v{1, 2, 3};

  for (auto i = 0uz; i &lt; v.size(); ++i) {
  }

  for (auto i = 0uz, s = std::size(v); i &lt; s; ++i) {
  }

  std::max(0z, std::ssize(v));
  std::min(0uz, std::size(v));
    std::max(0uz, std::min(0uz, v.size()));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GhdW1Ebo8">https://godbolt.org/z/GhdW1Ebo8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::vector v{1, 2, 3};

  for (auto i = 0uz; i &lt; v.size(); ++i) {
  }

  for (auto i = 0uz, s = std::size(v); i &lt; s; ++i) {
  }

  std::max(0z, std::ssize(v));
  std::min(0uz, std::size(v));
    std::max(0uz, std::min(0uz, v.size()));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KeKKPG7cv">https://godbolt.org/z/KeKKPG7cv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::vector v{1, 2, 3};

  for (auto i = 0UZ; i &lt; v.size(); ++i) {
  }

  for (auto i = 0UZ, s = std::size(v); i &lt; s; ++i) {
  }

  std::max(0Z, std::ssize(v));
  std::min(0UZ, std::size(v));
    std::max(0UZ, std::min(0UZ, v.size()));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xxqzE1cee">https://godbolt.org/z/xxqzE1cee</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>277 - Did you know that C++17 structured bindings support to custom classes can be added?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/277.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/277.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 structured bindings support to custom classes can be added?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1061">https://wg21.link/P1061</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
    int i{};
    std::string s{};
};

template &lt;auto N&gt;
const auto&amp; get(const foo&amp; f) {
    if constexpr (N == 0) {
        return f.i;
    } else if constexpr (N == 1) {
        return f.s;
    }
}

namespace std {
template &lt;&gt;
struct tuple_size&lt;::foo&gt; : integral_constant&lt;std::size_t, 2&gt; {};

template &lt;std::size_t N&gt;
struct tuple_element&lt;N, ::foo&gt; {
    using type = decltype(get&lt;N&gt;(std::declval&lt;::foo&amp;&gt;()));
};
}  // namespace std

int main() {
    auto [i, s] = foo{.i = 42, .s = &quot;str&quot;};
    assert(42 == i);
    assert(&quot;str&quot; == s);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n66GMfWao">https://godbolt.org/z/n66GMfWao</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you add structured bindings support to std::index_sequence?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">namespace std {
    // TODO
}

int main() {
    {
        auto [... Is] = std::make_index_sequence&lt;0&gt;{};
        static_assert(sizeof...(Is) == 0);
    }
    {
        auto [... Is] = std::make_index_sequence&lt;3&gt;{};
        static_assert(sizeof...(Is) == 3);
        static_assert(
            typeid(std::tuple{std::integral_constant&lt;std::size_t, 0&gt;{},
                              std::integral_constant&lt;std::size_t, 1&gt;{},
                              std::integral_constant&lt;std::size_t, 2&gt;{}}) ==
            typeid(std::tuple{Is...}));
    }
    {
        auto [... Is] = std::make_index_sequence&lt;42&gt;{};
        static_assert(sizeof...(Is) == 42);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qavcThr9K">https://godbolt.org/z/qavcThr9K</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace std {

template &lt;std::size_t N&gt;
using index_constant = std::integral_constant&lt;std::size_t, N&gt;;

template &lt;auto N, auto... Is&gt;
auto get(index_sequence&lt;Is...&gt;) {
    return index_constant&lt;N&gt;{};
}

template &lt;auto... Is&gt;
struct tuple_size&lt;index_sequence&lt;Is...&gt;&gt; : index_constant&lt;sizeof...(Is)&gt; {};

template &lt;auto N, auto... Is&gt;
struct tuple_element&lt;N, index_sequence&lt;Is...&gt;&gt; {
    using type = index_constant&lt;N&gt;;
};

}  // namespace std
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/466j7snqK">https://godbolt.org/z/466j7snqK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace std {

template&lt;auto N, size_t ...Ints&gt;
auto constexpr get(const index_sequence&lt;Ints...&gt;&amp;) {
    return get&lt;N&gt;(tuple{integral_constant&lt;size_t, Ints&gt;{}...});
};

template&lt;size_t ... Ints&gt;
struct tuple_size&lt;index_sequence&lt;Ints...&gt;&gt; : integral_constant&lt;size_t, sizeof...(Ints)&gt; {};

template&lt;size_t N, size_t ...Ints&gt;
struct tuple_element&lt;N, index_sequence&lt;Ints...&gt;&gt; {
    using type = decltype(get&lt;N&gt;(tuple{integral_constant&lt;size_t, Ints&gt;{}...}));
};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6fb7e89fK">https://godbolt.org/z/6fb7e89fK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace stdext {

template &lt;std::size_t... Is&gt;
struct index_sequence : std::index_sequence&lt;Is...&gt; {
  template &lt;std::size_t I&gt;
  auto get() const -&gt; std::tuple_element_t&lt;I, index_sequence&gt; {
    return {};
  }
};

namespace detail {

template &lt;std::size_t N, class = std::make_index_sequence&lt;N&gt;&gt;
struct make_index_sequence;

template &lt;std::size_t N, auto... Is&gt;
struct make_index_sequence&lt;N, std::index_sequence&lt;Is...&gt;&gt; {
  using type = index_sequence&lt;Is...&gt;;
};

}  // namespace detail

template &lt;std::size_t N&gt;
using make_index_sequence = typename detail::make_index_sequence&lt;N&gt;::type;

}  // namespace stdext
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jeY9qoYG4">https://godbolt.org/z/jeY9qoYG4</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>276 - Did you know that C++23 added `bind_back` to simplify writing higher order functions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/276.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/276.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++23 added <code>bind_back</code> to simplify writing higher order functions?</p>
</li>
<li>
<p><a href="https://wg21.link/p0356">https://wg21.link/p0356</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::cout &lt;&lt; std::bind_front(std::divides{}, 2.)(1.); // prints 2
  std::cout &lt;&lt; std::bind_back (std::divides{}, 2.)(1.); // prints 0.5
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qK3rdKh39">https://godbolt.org/z/qK3rdKh39</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement a simplified version of <code>bind_back</code> to illustrate its usage with higher order functions?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bind_back(auto&amp;&amp;...); // TODO

int main() {
  using namespace boost::ut;

  &quot;bind_back&quot;_test = [] {
    expect(3._d == bind_back(std::plus{}, 1.)(2.));
    expect(3._d == bind_back(std::plus{}, 2.)(1.));
    expect(3._d == bind_back(std::plus{}, 1., 2.)());
    expect(3._d == bind_back(std::plus{})(1., 2.));

    expect(2._d == bind_back(std::divides{}, 1.)(2.));
    expect(.5_d == bind_back(std::divides{}, 2.)(1.));

    expect(1._d == bind_back(std::minus{}, 1.)(2.));
    expect(-1._d == bind_back(std::minus{}, 2.)(1.));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7rnfG6v7q">https://godbolt.org/z/7rnfG6v7q</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#define FWD(...) static_cast&lt;decltype(__VA_ARGS__)&amp;&amp;&gt;(__VA_ARGS__)

[[nodiscard]] constexpr auto bind_back(const auto&amp; func, auto... bound_args) {
    return [=] [[nodiscard]] (auto&amp;&amp;... unbound_args) {
        return func(FWD(unbound_args)..., bound_args...);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zjG8191Wb">https://godbolt.org/z/zjG8191Wb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bind_back(auto&amp;&amp; fn, auto&amp;&amp;...bound_args) {
    return [=](auto&amp;&amp;...args){
        return fn(args..., bound_args...);
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Md978687E">https://godbolt.org/z/Md978687E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bind_back(auto&amp;&amp; fn, auto&amp;&amp;... back_args) {
  return [fn = std::forward&lt;decltype(fn)&gt;(fn),
          ...back_args = std::forward&lt;decltype(back_args)&gt;(back_args)] (auto&amp;&amp;... front_args) {
    return std::invoke(fn, front_args..., back_args...);
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d89xW84no">https://godbolt.org/z/d89xW84no</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// From [https://wg21.link/p2445](https://wg21.link/p2445)
namespace proposed_std {
template &lt;typename T, typename U&gt;
using __override_ref_t = std::conditional_t&lt;std::is_rvalue_reference_v&lt;T&gt;,
                                            std::remove_reference_t&lt;U&gt; &amp;&amp;, U &amp;&gt;;
template &lt;typename T, typename U&gt;
using __copy_const_t = std::conditional_t&lt;std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;,
                                          U const, U&gt;;
template &lt;typename T, typename U&gt;
using __forward_like_t = __override_ref_t&lt;T &amp;&amp;, __copy_const_t&lt;T, std::remove_reference_t&lt;U&gt;&gt;&gt;;

template &lt;typename T&gt;
[[nodiscard]] constexpr
auto forward_like(auto&amp;&amp; x) noexcept -&gt; __forward_like_t&lt;T, decltype(x)&gt; {
  return static_cast&lt;__forward_like_t&lt;T, decltype(x)&gt;&gt;(x);
}
}

template &lt;typename F, typename... BackArgs&gt;
[[nodiscard]] constexpr auto bind_back(F&amp;&amp; fn, BackArgs&amp;&amp;... back_args) {
  return [fn = std::forward&lt;F&gt;(fn),
          ...back_args = std::forward&lt;BackArgs&gt;(back_args)]
          &lt;typename Self, typename... FrontArgs&gt; (
            this Self&amp;&amp; self, FrontArgs&amp;&amp;... front_args) -&gt; decltype(auto) {
    return std::invoke(
      proposed_std::forward_like&lt;Self&gt;(fn),
      std::forward&lt;FrontArgs&gt;(front_args)...,
      proposed_std::forward_like&lt;Self&gt;(back_args)...);
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a6M3E48E3">https://godbolt.org/z/a6M3E48E3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename F, typename ... BArgs&gt;
auto bind_back_helper (F const &amp; f, BArgs ... bound_args)
{
    return [f,... bound_args = std::forward&lt;BArgs&gt;(bound_args)](auto... call_args){
        return std::invoke_r&lt;double&gt;(f,call_args...,bound_args...);
    };
}

template &lt;typename ... Args&gt;
[[nodiscard]] constexpr auto bind_back(auto &amp;&amp;... args)
{
    return bind_back_helper&lt;Args...&gt;(args...);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/58rzfz9a9">https://godbolt.org/z/58rzfz9a9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bind_back(auto&amp;&amp;... args)
{
    if constexpr (sizeof...(args) == 1) {
        auto [fun] = std::tuple{args...};
        return [fun=fun](auto arg1, auto arg2) { return fun(arg1, arg2); };
     } else if constexpr(sizeof ...(args) == 2) {
        auto [fun, arg] = std::tuple{args...};
        return [fun=fun, arg1=arg](auto arg2) { return fun(arg2, arg1); };
    } else {
        auto [fun, arg1, arg2] = std::tuple{args...};
        return [fun=fun, arg1=arg1, arg2=arg2]() { return fun(arg1, arg2);};
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hnd9G63v6">https://godbolt.org/z/hnd9G63v6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename F, typename ... Args1&gt;
[[nodiscard]] constexpr auto bind_back( F &amp;&amp; f, Args1 &amp;&amp; ... args1 ){
    return [&amp;]&lt;typename ... Args2&gt;( Args2 &amp;&amp; ... args2 ){
        return std::invoke(f, std::forward&lt;Args2&gt;(args2)..., std::forward&lt;Args1&gt;(args1)...);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3rKqx86M5">https://godbolt.org/z/3rKqx86M5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// Heavily inspired by [https://stackoverflow.com/questions/64712892/mimic-stdbind-front-in-c17-for-calling-member-functions](https://stackoverflow.com/questions/64712892/mimic-stdbind-front-in-c17-for-calling-member-functions)
// [https://godbolt.org/z/cqPjTY](https://godbolt.org/z/cqPjTY)

[[nodiscard]] constexpr auto bind_back(auto &amp;&amp;f, auto&amp;&amp;... args){
    return [f=std::forward&lt;decltype(f)&gt;(f),
            frontArgs = std::make_tuple(std::forward&lt;decltype(args)&gt;(args)...)]
            (auto&amp;&amp;...backArgs) {
            return std::apply(
                f,
                std::tuple_cat(
                    std::forward_as_tuple(backArgs...),
                    frontArgs
                ));
        };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T9x8s59jh">https://godbolt.org/z/T9x8s59jh</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>275 - Did you know what is the underlying type of NTTP string aka `fixed_string`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/275.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/275.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know what is the underlying type of NTTP string aka <code>fixed_string</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/P0732">http://wg21.link/P0732</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t N&gt; struct fixed_string final {
  constexpr explicit(false) fixed_string(const char (&amp;str)[N + 1]) {
    std::copy_n(str, N + 1, std::data(data));
  }

  [[nodiscard]] constexpr auto operator&lt;=&gt;(const fixed_string &amp;) const = default;

  std::array&lt;char, N + 1&gt; data{};
};

template &lt;std::size_t N&gt;
fixed_string(const char (&amp;str)[N]) -&gt; fixed_string&lt;N - 1&gt;;

template&lt;fixed_string&gt; struct foo;

int main() {
  what_is_my_type&lt;&quot;Quantlab&quot;&gt;{}; // clang: 'what_is_my_type&lt;{{&quot;Quantlab&quot;}}&gt;'
                                 // gcc: struct what_is_my_type&lt;fixed_string&lt;8&gt;{std::array&lt;char, 9&gt;{&quot;Quantlab&quot;}}&gt;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fqWo5nvTa">https://godbolt.org/z/fqWo5nvTa</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_string_t</code> which converts <code>fixed_string</code> into <code>string&lt;char...&gt;</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt; struct string {};
template &lt;class T, T... Cs&gt; [[nodiscard]] constexpr auto operator&quot;&quot;_cs() { return string&lt;Cs...&gt;{}; }

template &lt;std::size_t N&gt;
struct fixed_string; // TODO

template &lt;fixed_string Str&gt;
using to_string_t; // TODO

static_assert(std::is_same_v&lt;decltype(&quot;&quot;_cs), to_string_t&lt;&quot;&quot;&gt;&gt;);
static_assert(std::is_same_v&lt;decltype(&quot;Q&quot;_cs), to_string_t&lt;&quot;Q&quot;&gt;&gt;);
static_assert(std::is_same_v&lt;decltype(&quot;Foo&quot;_cs), to_string_t&lt;&quot;Foo&quot;&gt;&gt;);
static_assert(std::is_same_v&lt;decltype(&quot;Bar&quot;_cs), to_string_t&lt;&quot;Bar&quot;&gt;&gt;);
static_assert(not std::is_same_v&lt;decltype(&quot;fo&quot;_cs), to_string_t&lt;&quot;foo&quot;&gt;&gt;);
static_assert(not std::is_same_v&lt;decltype(&quot;foo&quot;_cs), to_string_t&lt;&quot;Foo&quot;&gt;&gt;);
static_assert(not std::is_same_v&lt;decltype(&quot;Foo&quot;_cs), to_string_t&lt;&quot;Bar&quot;&gt;&gt;);
static_assert(not std::is_same_v&lt;decltype(&quot;Bar&quot;_cs), to_string_t&lt;&quot;Foo&quot;&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/adT4rfEbh">https://godbolt.org/z/adT4rfEbh</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t N&gt;
struct fixed_string final {
    constexpr explicit(false) fixed_string(const char (&amp;str)[N + 1]) {
        std::copy_n(str, N + 1, std::data(data));
    }

    [[nodiscard]] constexpr auto
    operator&lt;=&gt;(const fixed_string &amp;) const = default;

    std::array&lt;char, N + 1&gt; data{};
};

template &lt;std::size_t N&gt;
fixed_string(const char (&amp;str)[N]) -&gt; fixed_string&lt;N - 1&gt;;

template &lt;fixed_string Str&gt;
using to_string_t = decltype([]&lt;std::size_t... Is&gt;(std::index_sequence&lt;Is...&gt;) {
    return string&lt;Str.data[Is]...&gt;{};
}(std::make_index_sequence&lt;Str.data.size() - 1&gt;()))
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fo4dz7Y8e">https://godbolt.org/z/fo4dz7Y8e</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#define FWD(...) static_cast&lt;decltype(__VA_ARGS__)&amp;&amp;&gt;(__VA_ARGS__)

namespace detail {

template &lt;auto Container, auto... Is&gt;
[[nodiscard]] consteval decltype(auto) apply_impl(auto&amp;&amp; func,
                                                  std::index_sequence&lt;Is...&gt;) {
    return func.template operator()&lt;Container[Is]...&gt;();
}

template &lt;auto Container&gt;
[[nodiscard]] consteval decltype(auto) apply(auto&amp;&amp; func) {
    return detail::apply_impl&lt;Container&gt;(
        FWD(func), std::make_index_sequence&lt;std::size(Container)&gt;{});
}

}  // namespace detail

template &lt;char... Cs&gt;
struct string {};

template &lt;class T, T... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_cs() {
    return string&lt;Cs...&gt;{};
}

template &lt;std::size_t N&gt;
struct fixed_string {
    constexpr explicit(false) fixed_string(const char (&amp;str)[N + 1]) {
        std::copy_n(str, N, std::data(chars));
    }

    std::array&lt;char, N&gt; chars;
};
template &lt;std::size_t N&gt;
fixed_string(const char (&amp;str)[N]) -&gt; fixed_string&lt;N - 1&gt;;

template &lt;fixed_string Str&gt;
using to_string_t = decltype(detail::apply&lt;Str.chars&gt;(
    []&lt;char... Cs&gt;() { return string&lt;Cs...&gt;{}; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d5rbc5Wch">https://godbolt.org/z/d5rbc5Wch</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;fixed_string Str&gt;
using to_string_t = decltype([]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
  return string&lt;Str[Is]...&gt;{};
}(std::make_index_sequence&lt;std::size(Str) - 1&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/11rcY9nGb">https://godbolt.org/z/11rcY9nGb</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>274 - Did you know about C++23 proposal `Structured Bindings can introduce a Pack`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/274.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/274.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++23 proposal <code>Structured Bindings can introduce a Pack</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1061">https://wg21.link/P1061</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;cassert&gt;

int main() {
  auto [first, ...ts] = std::tuple{1, 2 ,3};
  assert(1 == first);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7aax7P3c5">https://godbolt.org/z/7aax7P3c5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a function which returns first and last elements from a variadic pack?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args); // TODO

int main() {
  using namespace boost::ut;

  &quot;first and last&quot;_test = [] {
     expect(std::tuple{1, 2} == first_and_last(1, 2));
     expect(std::tuple{1, 3} == first_and_last(1, 2, 3));
     expect(std::tuple{0, 2} == first_and_last(0, 10, 2));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ax7Tnxh18">https://godbolt.org/z/ax7Tnxh18</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
[[nodiscard]] constexpr auto first_and_last(auto... args)<br />
{<br />
     auto [first, ...ts] = std::tuple{args...};<br />
     auto tail = std::tuple{ts...};<br />
     return std::tuple{first, std::get<sizeof...(ts) - 1>(tail)};<br />
}</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/eq74xv991](https://godbolt.org/z/eq74xv991)

```cpp
[[nodiscard]] constexpr auto first_and_last(auto... args) {
    auto const [first, ...tail] = std::tuple{args...};
    auto const [...mid, last] = std::tuple{args...}; // Note, using `tail` here causes ICE.
    return std::tuple{first, last};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nqbnz6W1f">https://godbolt.org/z/nqbnz6W1f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args)
    requires(sizeof...(args) == 2)
{
    // This function is only needed because an empty pack seems to ICE in every
    // way I could think of writing it. Remove this overload for a demonstration
    // of the ICE.
    return std::tuple{args...};
}

[[nodiscard]] constexpr auto first_and_last(auto... args) {
    auto [first, ... _, last] = std::tuple{args...};
    return std::tuple{first, last};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ejcxnPP4s">https://godbolt.org/z/ejcxnPP4s</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args); // TODO

int main() {
  using namespace boost::ut;

  &quot;first and last&quot;_test = [] {
     expect(std::tuple{1, 2} == first_and_last(1, 2));
     expect(std::tuple{1, 3} == first_and_last(1, 2, 3));
     expect(std::tuple{0, 2} == first_and_last(0, 10, 2));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ax7Tnxh18">https://godbolt.org/z/ax7Tnxh18</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args) requires (sizeof...(args) &gt;= 2) {
  auto [first, ...suffix] = std::tuple{args...};
  auto [...prefix, last] = std::tuple{args...};
  return std::tuple{first, last};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fGTs5vc1v">https://godbolt.org/z/fGTs5vc1v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto first, auto last) {
    return std::tuple{first, last};
}

[[nodiscard]] constexpr auto first_and_last(auto... args) requires (sizeof...(args) &gt; 2) {
    auto [first, ...ts, last] = std::tuple{args...};
    return std::tuple{first, last};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4W9Ws3q8v">https://godbolt.org/z/4W9Ws3q8v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto arg1, auto arg2, auto... args){
  return std::make_tuple(arg1, [](auto recur, auto ... args){
      return recur(recur, args ...);
    }([](auto recur, auto arg, auto ... args){
        if constexpr(sizeof ... (args) == 0){
          return arg;
        } else {
          return recur(recur, args ...);
        }
      }, arg2, args ...));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oPTnPbfno">https://godbolt.org/z/oPTnPbfno</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args) {
     return std::make_tuple(std::get&lt;0&gt;(std::make_tuple(args...)), std::get&lt;sizeof...(args)-1&gt;(std::make_tuple(args...))   );
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W47jWGssn">https://godbolt.org/z/W47jWGssn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args) requires (sizeof...(args) == 2){
    auto [first, last] = std::tuple{args...};
    return std::tuple{first, last};
}

[[nodiscard]] constexpr auto first_and_last(auto... args) requires (sizeof...(args) &gt; 2){
    auto [first, ...mid, last] = std::tuple{args...};
    return std::tuple{first, last};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sPT9nv464">https://godbolt.org/z/sPT9nv464</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto last(auto... args) {
    const auto [...rest, _last] = std::tuple{args...};
    return _last;
}

constexpr auto first(auto... args) {
    const auto [_first, ...rest] = std::tuple{args...};
    return _first;
}

[[nodiscard]] constexpr auto first_and_last(auto... args){
    return std::tuple{first(args...), last(args...)};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c15h1GT6E">https://godbolt.org/z/c15h1GT6E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto first, auto... args) {
    return std::tuple{first, (args, ...)};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WordnMWTT">https://godbolt.org/z/WordnMWTT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args) {
  if constexpr (sizeof...(args) != 2) {
    auto [first, ... values, last] = std::tuple{args...};
    return std::tuple{first, last};
  } else {
    return std::tuple{args...};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5Eqcf7ejM">https://godbolt.org/z/5Eqcf7ejM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args){
    std::common_type_t&lt;decltype(args)...&gt; first;
    (void)(((first = args, true) || ...));
    std::common_type_t&lt;decltype(args)...&gt; last;
    (void)(((last = args, false) || ...));
    return std::make_tuple(first,last);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T6PaMKK7M">https://godbolt.org/z/T6PaMKK7M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto... args){
    auto [first, ...ts, last] = std::tuple&lt;decltype(args)...&gt;(args...);
    return std::make_tuple(first,last);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9a34WaE8f">https://godbolt.org/z/9a34WaE8f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto first_and_last(auto first, auto... rest) {
  return std::tuple{first, (..., (rest = rest))};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zfPTTYrjG">https://godbolt.org/z/zfPTTYrjG</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>273 - Did you know that concept can be passed via lambda expression?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/273.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/273.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that concept can be passed via lambda expression?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/#concepts">http://eel.is/c++draft/#concepts</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert([]&lt;class T&gt;{ return std::integral&lt;T&gt;; }.operator()&lt;int&gt;());

struct f { auto foo() -&gt; void; };
static_assert([](auto t){ return requires { t.foo(); }; }(f{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3KbevGYK3">https://godbolt.org/z/3KbevGYK3</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement concept <code>fooable</code> which is satisfied if its parameters satisfies given concepts?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, auto... Ts&gt;
concept fooable; // TODO

struct bar  { };
static_assert(not fooable&lt;bar&gt;);

struct foo1 { void foo(int); };
static_assert(fooable&lt;foo1, []&lt;class T&gt; { return std::integral&lt;T&gt;; }&gt;);

struct foo2 { void foo(int, short); };
static_assert(fooable&lt;foo2, []&lt;class T&gt; { return std::integral&lt;T&gt;; },
                            []&lt;class T&gt; { return std::same_as&lt;short, T&gt;; }&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ja439rq4o">https://godbolt.org/z/ja439rq4o</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto... ConceptCheckers&gt;
concept fooable = requires(T t) { &amp;T::foo; };
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KrWrvze85">https://godbolt.org/z/KrWrvze85</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;typename...&gt;
struct type_list {};

template &lt;auto...&gt;
struct value_list {};

template &lt;typename T&gt;
concept has_foo = requires(T t) { &amp;T::foo; };

template &lt;typename&gt;
struct foo_function_traits;

template &lt;typename TBase, typename TReturn, typename... TArgs&gt;
struct foo_function_traits&lt;TReturn (TBase::*)(TArgs...)&gt; {
    using arg_types = type_list&lt;TArgs...&gt;;
};

template &lt;typename... TArgs, auto... ConceptCheckers&gt;
[[nodiscard]] consteval auto check_foo_args(type_list&lt;TArgs...&gt;,
                                            value_list&lt;ConceptCheckers...&gt;) {
    if constexpr (sizeof...(TArgs) != sizeof...(ConceptCheckers)) {
        return false;
    } else {
        return (... and ConceptCheckers.template operator()&lt;TArgs&gt;());
    }
}

}  // namespace detail

template &lt;class T, auto... ConceptCheckers&gt;
concept fooable =
    detail::has_foo&lt;T&gt; and
    detail::check_foo_args(
        typename detail::foo_function_traits&lt;decltype(&amp;T::foo)&gt;::arg_types{},
        detail::value_list&lt;ConceptCheckers...&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ac6M6vKsv">https://godbolt.org/z/ac6M6vKsv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Constraint&gt;
struct ArgConstraint {
    template &lt;typename T&gt;
        requires (Constraint.template operator()&lt;T&gt;())
    operator T();
};

template&lt;class T, auto... Ts&gt;
concept fooable = requires (T x) { x.foo(ArgConstraint&lt;Ts&gt;{}...); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3e6rPGT4f">https://godbolt.org/z/3e6rPGT4f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T, typename R, typename ... Args&gt;
consteval auto get_arguments(R(T::*)(Args...))
{
    return std::tuple&lt;Args...&gt;();
}

template &lt;class ArgumentTuple, class FunctionTuple&gt;
consteval decltype(auto) for_each(ArgumentTuple &amp;&amp; tuple, FunctionTuple &amp;&amp; f)
{
    if constexpr (std::tuple_size_v&lt;ArgumentTuple&gt; != std::tuple_size_v&lt;FunctionTuple&gt;)
        return false;

    return [] &lt;std::size_t... I&gt;
        (ArgumentTuple &amp;&amp; tuple, FunctionTuple&amp;&amp; f, std::index_sequence&lt;I...&gt;)
        {
            return (std::get&lt;I&gt;(f).template operator()&lt;std::remove_reference_t&lt;decltype(std::get&lt;I&gt;(tuple))&gt;&gt;() &amp;&amp; ...);
        }
        (std::forward&lt;ArgumentTuple&gt;(tuple), std::forward&lt;FunctionTuple&gt;(f),
        std::make_index_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;ArgumentTuple&gt;&gt;&gt;{});
}

template&lt;class T, auto... Ts&gt;
concept fooable = for_each(get_arguments(&amp;T::foo), std::tuple(Ts...));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YKs9zGKqz">https://godbolt.org/z/YKs9zGKqz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, class C&gt;
using satifies = boost::mp11::mp_bool&lt;C{}.template operator()&lt;T&gt;()&gt;;

template &lt;class T&gt;
struct indexed_arg {
  template &lt;class N&gt;
  using fn = typename boost::mpl::at&lt;T, N&gt;::type;
};

template &lt;class F&gt;
using arg_list = boost::mp11::mp_pop_front&lt;boost::mp11::mp_transform_q&lt;
      indexed_arg&lt;boost::function_types::parameter_types&lt;F&gt;&gt;,
      boost::mp11::mp_iota_c&lt;boost::function_types::function_arity&lt;F&gt;::value&gt;&gt;&gt;;

template &lt;class T, auto... Ts&gt;
concept fooable = boost::mp11::mp_apply&lt;boost::mp11::mp_all,
  boost::mp11::mp_transform&lt;
    satifies,
    arg_list&lt;decltype(&amp;T::foo)&gt;,
    boost::mp11::mp_list&lt;decltype(Ts)...&gt;&gt;&gt;::value;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cev74a6jq">https://godbolt.org/z/cev74a6jq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct type_list{};
template&lt;class&gt; struct function_traits;
template&lt;class R, class B, class... Ts&gt;
struct function_traits&lt;R(B::*)(Ts...)&gt; {
  using args_t = type_list&lt;Ts...&gt;;
};

template&lt;class T, auto... Ts&gt;
concept fooable = []&lt;class... TArgs&gt;(type_list&lt;TArgs...&gt;) {
  return (decltype(Ts){}.template operator()&lt;TArgs&gt;() and ...);
}(typename function_traits&lt;decltype(&amp;T::foo)&gt;::args_t{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4hxe4EYfq">https://godbolt.org/z/4hxe4EYfq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto... Vs&gt;
concept fooable = []&lt;class R, class... Args&gt;(R (T::*)(Args...), auto... tests) {
  return (... and tests.template operator()&lt;Args&gt;());
}(&amp;T::foo, Vs...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ar59cM1rW">https://godbolt.org/z/ar59cM1rW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Validate&gt;
struct AnyType {
    template&lt;class T&gt;
    operator T() {
        static_assert( Validate.template operator()&lt;T&gt;() );
        return T{}; }
};

template&lt;class T, auto... Ts&gt;
concept fooable = requires(T v ) {
    v.foo(AnyType&lt;Ts&gt;{} ...);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/avvbGdbK9">https://godbolt.org/z/avvbGdbK9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Constraint&gt; struct satisfies {
  template &lt;class T&gt; requires (Constraint.template operator()&lt;T&gt;()) operator T();
};

template&lt;class T, auto... Ts&gt;
concept fooable = requires (T t) { t.foo(satisfies&lt;Ts&gt;{}...); };
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jz7Yrf4Wr">https://godbolt.org/z/jz7Yrf4Wr</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>272 - **Did you know that C++20 added std::ranges::{all_of, any_of, none_of} algorithms**?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/272.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/272.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added std::ranges::{all_of, any_of, none_of} algorithms</strong>?</p>
</li>
<li>
<p><a href="http://eel.is/c++draft/#ranges">http://eel.is/c++draft/#ranges</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  assert(std::ranges::all_of (std::array{1, 1, 1}, [](const auto&amp; value) { return value == 1; }));
  assert(std::ranges::any_of (std::array{1, 2, 3}, [](const auto&amp; value) { return value == 2; }));
  assert(std::ranges::none_of(std::array{1, 2, 3}, [](const auto&amp; value) { return value == 4; }));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/czv4q433f">https://godbolt.org/z/czv4q433f</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement consteval equivalents of {all_of, any_of, none_of} algorithms</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool; // TODO

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool; // TODO

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool; // TODO

static_assert(all_of([](auto v) { return v == 1; }));
static_assert(all_of&lt;1, 1, 1&gt;([](auto v) { return v == 1; }));
static_assert(all_of&lt;1&gt;([](auto v) { return v == 1; }));
static_assert(not all_of&lt;1, 2, 1&gt;([](auto v) { return v == 1; }));
static_assert(not all_of&lt;1, 2&gt;([](auto v) { return v == 1; }));
static_assert(not all_of&lt;1, 2&gt;([](auto v) { return v == 2; }));

static_assert(any_of&lt;1, 2, 3&gt;([](auto v) { return v == 1; }));
static_assert(any_of&lt;1, 2, 3&gt;([](auto v) { return v == 2; }));
static_assert(any_of&lt;1, 2, 3&gt;([](auto v) { return v == 3; }));
static_assert(any_of&lt;1&gt;([](auto v) { return v == 1; }));
static_assert(not any_of([](auto v) { return v == 1; }));
static_assert(not any_of&lt;1, 2, 3&gt;([](auto v) { return v == 0; }));
static_assert(not any_of&lt;1, 2, 3&gt;([](auto v) { return v == 4; }));

static_assert(none_of([](auto v) { return v == 1; }));
static_assert(none_of&lt;1, 2, 3&gt;([](auto v) { return v == 0; }));
static_assert(none_of&lt;1, 2, 3&gt;([](auto v) { return v == 4; }));
static_assert(none_of&lt;1, 1, 1&gt;([](auto v) { return v == 2; }));
static_assert(not none_of&lt;1&gt;([](auto v) { return v == 1; }));
static_assert(not none_of&lt;1, 2, 3&gt;([](auto v) { return v == 1; }));
static_assert(not none_of&lt;1, 2, 3&gt;([](auto v) { return v == 2; }));
static_assert(not none_of&lt;1, 2, 3&gt;([](auto v) { return v == 3; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zdrsM6G1G">https://godbolt.org/z/zdrsM6G1G</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<p>```cpp<br />
 template<auto... Values><br />
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {<br />
    return (expr(Values) &amp;&amp; ...);<br />
}</p>
<p>template<auto... Values><br />
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {<br />
    return (expr(Values) || ...);<br />
}</p>
<p>template<auto... Values><br />
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {<br />
    return !(expr(Values) || ...);<br />
}</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/fWzn1dE99](https://godbolt.org/z/fWzn1dE99)

```cpp
template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool
{
    if constexpr (sizeof...(Values) &gt; 0)
        return std::ranges::all_of(std::array{Values...}, expr);
    return true;
}


template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool
{
    if constexpr (sizeof...(Values) &gt; 0)
        return std::ranges::any_of(std::array{Values...}, expr);
    return false;
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool
{
    if constexpr (sizeof...(Values) &gt; 0)   
        return std::ranges::none_of(std::array{Values...}, expr);
    return true;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hYWW5nzbh">https://godbolt.org/z/hYWW5nzbh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    return (expr(Values) and ...);
}
template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    return (expr(Values) or ...);
}
template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    return not (expr(Values) or ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a1hWKjKb9">https://godbolt.org/z/a1hWKjKb9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    return (... and expr(Values));
}

template &lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    return (... or expr(Values));
}

template &lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    return not any_of&lt;Values...&gt;(expr);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xsP5MeE9v">https://godbolt.org/z/xsP5MeE9v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
  return (expr(Values) and ...);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
  return (expr(Values) or ...);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
  return not any_of&lt;Values...&gt;(expr);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YG5jroEGY">https://godbolt.org/z/YG5jroEGY</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    return (... and expr(Values));
}

template &lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    return (... or expr(Values));
}

template &lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    return not any_of&lt;Values...&gt;(expr);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8411orvcE">https://godbolt.org/z/8411orvcE</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    if constexpr(sizeof...(Values)) return std::ranges::all_of(std::array{Values...}, expr);
    return true;
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    if constexpr (sizeof...(Values)) return std::ranges::any_of(std::array{Values...}, expr);
    return false;
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    if constexpr(sizeof...(Values)) return std::ranges::none_of(std::array{Values...}, expr);
    return true;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K9ecvxvjo">https://godbolt.org/z/K9ecvxvjo</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    return std::ranges::all_of(std::array&lt;int, sizeof...(Values)&gt;{Values...}, expr);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    return std::ranges::any_of(std::array&lt;int, sizeof...(Values)&gt;{Values...}, expr);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    return std::ranges::none_of(std::array&lt;int, sizeof...(Values)&gt;{Values...}, expr);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dvYW9qdsG">https://godbolt.org/z/dvYW9qdsG</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool{
    if constexpr (sizeof...(Values) == 0) return true;
    else
        return std::ranges::all_of(std::array&lt;std::common_type_t&lt;decltype(Values)...&gt;, sizeof...(Values)&gt;{{Values...}}, expr);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool{
    if constexpr (sizeof...(Values) == 0) return false;
    else
        return std::ranges::any_of(std::array&lt;std::common_type_t&lt;decltype(Values)...&gt;, sizeof...(Values)&gt;{{Values...}}, expr);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool{
    if constexpr (sizeof...(Values) == 0) return true;
    else
        return std::ranges::none_of(std::array&lt;std::common_type_t&lt;decltype(Values)...&gt;, sizeof...(Values)&gt;{{Values...}}, expr);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aos37bd8W">https://godbolt.org/z/aos37bd8W</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Values&gt;
[[nodiscard]] consteval auto all_of(auto expr) -&gt; bool {
    return (expr(Values) &amp; ... &amp; true) ;
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto any_of(auto expr) -&gt; bool {
    return (expr(Values) || ... || false);
}

template&lt;auto... Values&gt;
[[nodiscard]] consteval auto none_of(auto expr) -&gt; bool {
    return ( (not expr(Values)) &amp; ... &amp; true);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/edKfKvcxr">https://godbolt.org/z/edKfKvcxr</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>271 - Did you know that C++20 added support for floating point values as non-type template parameters?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/271.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/271.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added support for floating point values as non-type template parameters?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0127">https://wg21.link/P0127</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;double Value&gt; constexpr auto value = Value;

int main() {
    std::cout &lt;&lt; value&lt;4.2&gt;; // prints 4.2
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4cfMPY686">https://godbolt.org/z/4cfMPY686</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement function calc which adds values from <code>Vl1s...</code> multipled by all values from <code>Vls2...</code>?</strong><br />
    For example : Vl1s = { 1., 2. }, Vl2 { 3., 4.}; calc = (1. * 3. * 4.) + (2. * 3. * 4.)</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Values&gt; struct values {};

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;) // TODO

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}

static_assert(eq(1. * 2., calc(values&lt;1.&gt;{}, values&lt;2.&gt;{})));
static_assert(eq(2.*3.*4., calc(values&lt;2.&gt;{}, values&lt;3., 4.&gt;{})));
static_assert(eq(4.2 * 2. * 3. + .1 * 2. * 3., calc(values&lt;4.2, .1&gt;{}, values&lt;2., 3.&gt;{})));
static_assert(eq(1. * 4. * 5. + 2. * 4. * 5., calc(values&lt;1., 2.&gt;{}, values&lt;4., 5.&gt;{})));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7KhKaK8jT">https://godbolt.org/z/7KhKaK8jT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;) {
    constexpr auto mul = (Vl2s * ...);
    return ((Vl1s * mul) + ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K7T9czezG">https://godbolt.org/z/K7T9czezG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;double... List1, double... List2&gt;
[[nodiscard]] consteval auto calc(values&lt;List1...&gt;, values&lt;List2...&gt;) {
    return (0 + ... + (List1 * (1 * ... * List2)));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fGsjTMnab">https://godbolt.org/z/fGsjTMnab</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Values&gt; struct values {};

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;) {
    return ((Vl1s * (Vl2s * ...)) + ...);
}

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/71KaKc4fM">https://godbolt.org/z/71KaKc4fM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Values&gt; struct values {};

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;) {
    constexpr auto c = (Vl2s * ...);
    return ((Vl1s * c) + ...);
}

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s6r8xKEe6">https://godbolt.org/z/s6r8xKEe6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Values&gt; struct values {};

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;) {
  return (Vl1s + ...) * (Vl2s * ...);
}

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nE79Ya6z3">https://godbolt.org/z/nE79Ya6z3</a> </p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;double... Values&gt; struct values{};

template&lt;double Vl1, double... Vl2s&gt;
[[nodiscard]] consteval auto mult(){
  return  (Vl1 * ... * Vl2s);
}

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;){
  return (... + mult&lt;Vl1s, Vl2s...&gt;());
}

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KfPefTPbd">https://godbolt.org/z/KfPefTPbd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cp">template&lt;double... Values&gt; struct values {};

template&lt;double... Vl1s, double... Vl2s&gt;
[[nodiscard]] consteval auto calc(values&lt;Vl1s...&gt;, values&lt;Vl2s...&gt;){
    return (0.0 + ... + (Vl1s * (Vl2s * ... )));
}

template&lt;double Epsilon = 0.1&gt;
[[nodiscard]] consteval auto eq(double a, double b) {
    return std::fabs(a - b) &lt; Epsilon;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M5Y5dnfvY">https://godbolt.org/z/M5Y5dnfvY</a> </p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>270 - Did you know that C++23 added `std::to_underlying`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/270.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/270.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>std::to_underlying</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1682">https://wg21.link/P1682</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">enum { QL = 42 };

int main() {
    std::cout &lt;&lt; std::to_underlying(QL); // prints 42
    static_assert(typeid(std::to_underlying(QL)) == typeid(unsigned));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h8x6zYGGe">https://godbolt.org/z/h8x6zYGGe</a> </p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>sum_enums</code> which adds only underlying enum values?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Ns&gt;
constexpr auto sum_enums = /*TODO*/;

enum { _1 = 1 };
enum class Q2 { _2 = 2 };
enum class Q3 : int { _3 = 3 };

static_assert(0 == sum_enums&lt;42&gt;);
static_assert(1 == sum_enums&lt;_1&gt;);
static_assert(2 == sum_enums&lt;Q2::_2&gt;);
static_assert(3 == sum_enums&lt;Q3::_3&gt;);
static_assert(1 + 2 + 3 == sum_enums&lt;_1, Q2::_2, Q3::_3&gt;);
static_assert(3 + 2 + 1 == sum_enums&lt;Q3::_3, Q2::_2, _1&gt;);
static_assert(3 + 2 + 1 == sum_enums&lt;Q3::_3, Q2::_2, _1, 42&gt;);
static_assert(3 + 2 + 1 == sum_enums&lt;1, Q3::_3, 2, Q2::_2, 3, _1, 4&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fexYEKerY">https://godbolt.org/z/fexYEKerY</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto V&gt;
constexpr auto enum_underlying_or_zero = 0;

template &lt;auto V&gt;
requires requires { std::to_underlying(V); }
constexpr auto enum_underlying_or_zero&lt;V&gt; = std::to_underlying(V);

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (enum_underlying_or_zero&lt;Ns&gt; + ...)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jojeGMKqj">https://godbolt.org/z/jojeGMKqj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Ns&gt;
constexpr auto sum_enums = ([](auto val) { 
    if constexpr (std::is_enum_v&lt;decltype(val)&gt;)
        return std::to_underlying(val);
    else
        return 0;
} (Ns) + ...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KKEsM8cdd">https://godbolt.org/z/KKEsM8cdd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;typename T&gt;
concept CEnum = std::is_enum_v&lt;T&gt;;

[[nodiscard]] constexpr auto get_enum_value(auto&amp;&amp;) { return 0; }

[[nodiscard]] constexpr auto get_enum_value(const CEnum auto e) {
    return std::to_underlying(e);
}

}  // namespace detail

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (... + detail::get_enum_value(Ns));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ps6ojrv6v">https://godbolt.org/z/Ps6ojrv6v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    template &lt;auto v&gt;
    constexpr auto value = []{
        if constexpr (std::is_enum_v&lt;decltype(v)&gt;) {
            return std::to_underlying(v);
        } else {
            return 0;
        }
    };
}
template &lt;auto... Ns&gt;
constexpr auto sum_enums = [] {
    return (detail::value&lt;Ns&gt;() + ...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rhrrP71dP">https://godbolt.org/z/rhrrP71dP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto underlying_value = [] {
  if constexpr (requires {std::to_underlying(N);}) {
    return std::to_underlying(N);
  } else {
    return decltype(N){};
  }
};

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (underlying_value&lt;Ns&gt;() + ... + 0);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zGdGo93YM">https://godbolt.org/z/zGdGo93YM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename ValT&gt;
requires std::integral&lt;ValT&gt;
constexpr auto get_return_val(ValT const&amp; val){
    return 0;
}

template&lt;typename ValT&gt;
constexpr auto get_return_val(ValT const&amp; val){
    return std::to_underlying(val);
}

template&lt;typename... Ns&gt;
constexpr auto sum(Ns const&amp;... n){
    return ( get_return_val(n) + ...);
}

template &lt;auto... Ns&gt;
constexpr auto sum_enums = [](){
    return sum(Ns...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KPEWvjsK3">https://godbolt.org/z/KPEWvjsK3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename ValT&gt;
requires std::integral&lt;ValT&gt;
constexpr auto get_return_val(ValT const&amp; val){
    return 0;
}

template&lt;typename ValT&gt;
constexpr auto get_return_val(ValT const&amp; val){
    return std::to_underlying(val);
}

template&lt;typename... Ns&gt;
constexpr auto sum(Ns const&amp;... n){
    return ( get_return_val(n) + ...);
}

template &lt;auto... Ns&gt;
constexpr auto sum_enums = [](){
    return sum(Ns...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ExT674a9a">https://godbolt.org/z/ExT674a9a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto enum_value = [] {
    if constexpr (std::is_enum_v&lt;decltype(N)&gt;) {
        return std::to_underlying(N);
    } else {
        return 0;
    }
};

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (enum_value&lt;Ns&gt;() + ...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qMcr1Tbjr">https://godbolt.org/z/qMcr1Tbjr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Ns&gt;
constexpr auto sum_enums = (... + [] {
  if constexpr (requires { std::to_underlying(Ns); }) {
    return std::to_underlying(Ns);
  } else {
    return 0;
  }
}());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rshWcE9js">https://godbolt.org/z/rshWcE9js</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto underlying_value = []{
    if constexpr(requires{std::to_underlying(N);}){
        return std::to_underlying(N);
    }
    else{
        return 0;
    }
};

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (... + underlying_value&lt;Ns&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KcqWqGdsG">https://godbolt.org/z/KcqWqGdsG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Ns&gt;
constexpr auto sum_enums = (
    [](auto n) {
        if constexpr (requires { std::to_underlying(n); })
            return std::to_underlying(n);
        else
            return 0;
    }(Ns) + ...
);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Pxa99q4jv">https://godbolt.org/z/Pxa99q4jv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto T&gt;
[[nodiscard]] consteval auto get_enum_value() -&gt; int {
  if constexpr (std::is_enum_v&lt;decltype(T)&gt; ) {
    return std::to_underlying(T);
  }
  else {
    return 0;
  }
}

template &lt;auto... Ns&gt;
constexpr auto sum_enums = (... + get_enum_value&lt;Ns&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rTodjTzed">https://godbolt.org/z/rTodjTzed</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto n&gt;
constexpr auto to_value = [] {
  if constexpr (std::is_enum_v&lt;decltype(n)&gt;) {
    return std::to_underlying(n);
  } else {
    return 0;
  }
};

template &lt;auto... Ns&gt;
constexpr auto sum_enums = [] {
  return (to_value&lt;Ns&gt;() + ...);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fq13WWMEP">https://godbolt.org/z/fq13WWMEP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename ...Ns&gt;
constexpr auto sum_enums_impl(Ns... ns) {
    auto underlying_or_zero = [](auto ns) {
        if constexpr(  requires{std::to_underlying(ns); })
            return std::to_underlying(ns);
        else
            return 0;
    };
    return (  underlying_or_zero(ns) +...);
}

template &lt;auto... Ns&gt;
constexpr auto sum_enums = sum_enums_impl(Ns...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aoshY5Gb1">https://godbolt.org/z/aoshY5Gb1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Ns&gt;
constexpr auto sum_enums = []{
    if constexpr (sizeof...(Ns) &gt; 0){
        auto helper = []&lt;auto H, auto... Hs&gt;() {
            if constexpr (std::is_enum_v&lt;decltype(H)&gt;)
                 return std::to_underlying(H) + sum_enums&lt;Hs...&gt;;
            else
                return sum_enums&lt;Hs...&gt;;
        };
        return helper.template operator()&lt;Ns...&gt;();
    }
    else
        return 0;

}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jdcvxjf5r">https://godbolt.org/z/jdcvxjf5r</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>269 - Did you know about `boost::mp11::mp_with_index`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/269.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/269.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>boost::mp11::mp_with_index</code>?</strong></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/develop/libs/mp11/doc/html/mp11.html#mp_with_indexni_f">https://www.boost.org/doc/libs/develop/libs/mp11/doc/html/mp11.html#mp_with_indexni_f</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
    boost::mp11::mp_with_index&lt;42&gt;(17, [](auto I) {
        std::cout &lt;&lt; typeid(I).name(); // prints std::integral_constant&lt;int, 17&gt;
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ocTvG3n7n">https://godbolt.org/z/ocTvG3n7n</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>vector_to_array</code> which will convert a given vector to an array and execute given function on it?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto vector_to_array(const auto&amp; v, auto f) -&gt; void; // TODO

int main() {
    using namespace boost::ut;

    &quot;vector to array - empty&quot;_test = [] {
        auto called = 0;
        vector_to_array(std::vector&lt;int&gt;{},
                        [&amp;](const std::array&lt;int, 0&gt;&amp; a) { ++called; });
        assert(1_i == called);
    };

    &quot;vector to array - one&quot;_test = [] {
        auto called = 0;
        vector_to_array(std::vector{42}, [&amp;](const std::array&lt;int, 1&gt;&amp; a) {
            ++called;
            expect(42_i == a[0]);
        });
        assert(1_i == called);
    };

    &quot;vector to array - many&quot;_test = [] {
        auto called = 0;
        vector_to_array(std::vector{1, 5, 7}, [&amp;](const std::array&lt;int, 3&gt;&amp; a) {
            ++called;
            expect(1_i == a[0] and 5_i == a[1] and 7_i == a[2]);
        });
        assert(1_i == called);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TPxzo9Md1">https://godbolt.org/z/TPxzo9Md1</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt; struct overloaded : Ts... { using Ts::operator()...; };
template&lt;class... Ts&gt; overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;;

auto vector_to_array(const auto&amp; v, auto f) -&gt; void {
    if (v.size() &gt;= 2048)
        throw std::overflow_error(&quot;Vector size is not less than 2048&quot;);
    using type = std::decay_t&lt;decltype(v[0])&gt;;
    boost::mp11::mp_with_index&lt;2048&gt;(v.size(), 
        overloaded {
            // only generate invocable lambdas
            [&amp;](auto I) -&gt; std::enable_if_t&lt;std::is_invocable_v&lt;decltype(f), std::array&lt;type, I&gt;&gt;&gt; {
                f([&amp;v] &lt;std::size_t ...Ix&gt; (std::index_sequence&lt;Ix...&gt;) -&gt; std::array&lt;type, I&gt; {
                    return {v[Ix]...};
                } (std::make_index_sequence&lt;I&gt;()));
            }, 
            // probably not the solution :)
            [](std::size_t) {}
        });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yhb4h31jh">https://godbolt.org/z/Yhb4h31jh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename F, typename Ret, typename FirstArg, typename... Rest&gt;
FirstArg helper(Ret (F::*)(FirstArg, Rest...) const);

template&lt;typename F&gt;
struct first_argument {
    typedef decltype( helper(&amp;F::operator()) ) type;
};

auto vector_to_array(const auto&amp; v, auto f) -&gt; void
{
    using Array = typename first_argument&lt;decltype(f)&gt;::type;
    constexpr std::size_t N = Array{}.size();

    boost::mp11::mp_with_index&lt;N+1&gt;(N,
        [&amp;](auto I) {
            [&amp;]&lt;std::size_t ...Ix&gt;(std::index_sequence&lt;Ix...&gt;) {
                f({v[Ix]...});
            } (std::make_index_sequence&lt;I&gt;());
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4fM8W5f3h">https://godbolt.org/z/4fM8W5f3h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TVector&gt;
auto vector_to_array(const TVector&amp; v, auto f) -&gt; void {
    boost::mp11::mp_with_index&lt;4&gt;(std::size(v), [&amp;]&lt;typename TValue&gt;(TValue) {
        std::array&lt;typename TVector::value_type, TValue{}&gt; array{};
        std::copy(std::cbegin(v), std::cend(v), std::begin(array));
        // std::is_invocable_v&lt;decltype(f), decltype(array)&gt;
        if constexpr (requires { f(array); }) {
            f(array);
        }
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jjoT7nG95">https://godbolt.org/z/jjoT7nG95</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;typename F, typename Ret, typename FirstArg, typename... Rest&gt;
FirstArg first_arg_helper(Ret (F::*)(FirstArg, Rest...) const);

template &lt;typename F&gt;
struct first_argument {
    using type =
        std::remove_cvref_t&lt;decltype(first_arg_helper(&amp;F::operator()))&gt;;
};

template &lt;typename F&gt;
using first_argument_t = typename first_argument&lt;F&gt;::type;

}  // namespace detail

template &lt;typename TVector, typename TCallable&gt;
auto vector_to_array(const TVector&amp; v, TCallable f) -&gt; void {
    using array_t = detail::first_argument_t&lt;TCallable&gt;;
    array_t array{};
    std::copy(std::cbegin(v), std::cend(v), std::begin(array));
    if constexpr (requires { f(array); }) {
        f(array);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8fxzasEYv">https://godbolt.org/z/8fxzasEYv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename F&gt;
struct param {};

template&lt;typename F, typename Arg&gt;
struct param&lt;void(F::*)(Arg) const&gt; {
    using type = std::remove_cvref_t&lt;Arg&gt;;
};

template &lt;typename F&gt;
auto vector_to_array(const auto&amp; v, F f) -&gt; void {
    using array_type_t = typename param&lt;decltype(&amp;F::operator())&gt;::type;
    const array_type_t&amp; array = *reinterpret_cast&lt;const array_type_t*&gt;(std::data(v));
    f(array);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fn8M94o46">https://godbolt.org/z/fn8M94o46</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto vector_to_array(const auto&amp; v, auto f) -&gt; void {
  constexpr auto max_size = 64uz;
  using value_t = typename std::remove_cvref_t&lt;decltype(v)&gt;::value_type;
  boost::mp11::mp_with_index&lt;max_size&gt;(std::size(v), [&amp;] &lt;typename N&gt; (N) -&gt; void {
    [&amp;] &lt;auto... Is&gt; (std::index_sequence&lt;Is...&gt;) -&gt; void {
      using array_t = std::array&lt;value_t, N{}&gt;;
      if constexpr (requires { f(array_t{}); }) {
        f(array_t{v[Is]...});
      }
    }(std::make_index_sequence&lt;N{}&gt;{});
  });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z4Evx7fPz">https://godbolt.org/z/z4Evx7fPz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;class T, template &lt;T&gt; class F, T L = std::numeric_limits&lt;T&gt;::lowest(),
          T U = std::numeric_limits&lt;T&gt;::max()&gt;
struct lower_bound : decltype([] {
  constexpr T V = L + (U - L) / 2;

  if constexpr (L == V) {
    if constexpr (requires { typename F&lt;U&gt;; }) {
      return lower_bound&lt;T, F, L, L&gt;{};
    } else {
      return lower_bound&lt;T, F, U, U&gt;{};
    }
  } else if constexpr (requires { typename F&lt;V&gt;; }) {
    return lower_bound&lt;T, F, V, U&gt;{};
  } else {
    return lower_bound&lt;T, F, L, V&gt;{};
  }
}()) {};

template &lt;class T, template &lt;T&gt; class F, T V&gt;
struct lower_bound&lt;T, F, V, V&gt; {
  static constexpr auto value = V;
};

}  // namespace detail

template &lt;class T&gt;
struct array_of {
  template &lt;size_t N&gt;
  using fn = T[N];
};

template &lt;class Q&gt;
inline constexpr auto lower_bound_v =
    detail::lower_bound&lt;size_t, Q::template fn&gt;::value;

template &lt;class Container&gt;
auto vector_to_array(const Container&amp; v, auto f) -&gt; void {
  using value_t = typename Container::value_type;

  static_assert(576460752303423488 == lower_bound_v&lt;array_of&lt;value_t&gt;&gt;);
  // attempt at TMP to find the largest size_t that doesn't produce `error:
  // array is too large`
  // boost::mp11::mp_with_index&lt;lower_bound_v&lt;array_of&lt;value_t&gt;&gt;&gt;(
  boost::mp11::mp_with_index&lt;42&gt;(
      std::size(v), [&amp;]&lt;auto N&gt;(boost::mp11::mp_size_t&lt;N&gt;) {
        using array_t = std::array&lt;value_t, N&gt;;

        [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
          if constexpr (requires { f(array_t{v[Is]...}); }) {
            f(array_t{v[Is]...});
          }
        }
        (std::make_index_sequence&lt;N&gt;{});
      });
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8qMxMEsEc">https://godbolt.org/z/8qMxMEsEc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto vector_to_array(const auto&amp; v, auto f) -&gt; void {
    const auto func = [&amp;](const auto I) {
        using array_t = std::array&lt;int, decltype(I)::value&gt;;
        if constexpr (requires { f(array_t{}); }) {
            array_t arr{};
            std::copy(std::cbegin(v), std::cend(v), std::begin(arr));
            f(arr);
        }
    };
    boost::mp11::mp_with_index&lt;4&gt;(std::size(v), func);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G1GK17cEv">https://godbolt.org/z/G1GK17cEv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">inline constexpr std::size_t N = 30;

auto vector_to_array = [](const auto&amp; v, auto f) -&gt; void{
        boost::mp11::mp_with_index&lt;N&gt;(v.size(), [&amp;](auto I) {
            std::array&lt;int, I&gt; a;
            std::copy(std::begin(v), std::end(v), a.begin());
            constexpr bool has_func = requires(decltype(f) func) {
                func(a);
            };
            if constexpr(has_func)  {
               f(a);
            }
        });
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WazKE3YWx">https://godbolt.org/z/WazKE3YWx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename V&gt;
struct ToArray {
    explicit ToArray(const V &amp;vec) : vec{vec} {}

    template &lt;typename T, std::size_t N&gt;
    operator std::array&lt;T, N&gt;() const {
        return [this]&lt;std::size_t... Is&gt;(std::index_sequence&lt;Is...&gt;) -&gt; std::array&lt;T, N&gt; {
            return {vec[Is]...};
        } (std::make_index_sequence&lt;N&gt;());
    }

    const V &amp;vec;
};

auto vector_to_array(const auto &amp;v, auto f) -&gt; void { return f(ToArray{v}); 
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YqWcT1dv5">https://godbolt.org/z/YqWcT1dv5</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>268 - Did you know that C++20 added `std::erase_if` for std::map and std::vector?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/268.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/268.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++20 added <code>std::erase_if</code> for std::map and std::vector?</p>
</li>
<li>
<p><a href="https://wg21.link/P1209">https://wg21.link/P1209</a></p>
</li>
<li><a href="https://wg21.link/P1115">https://wg21.link/P1115</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::vector v{1, 2, 3, 4};
  assert(4 == std::size(v));
  std::erase_if(v, [](const auto&amp; e) { return e % 2;} );
  assert(2 == std::size(v));
  assert(v[0] == 2 and v[1] == 4);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/os1zzqTb6">https://godbolt.org/z/os1zzqTb6</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>Can you implement <code>erase_if</code> for <code>flat_map</code>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type; // TODO

int main() {
  using namespace boost::ut;

  &quot;empty&quot;_test = [] {
    auto map = boost::container::flat_map&lt;int, int&gt;{};
    expect(0_u == std::size(map));
    expect(0_u == erase_if(map, [](auto){ return true; }));
    expect(0_u == std::size(map));
  };

  &quot;one element&quot;_test = [] {
    auto map = boost::container::flat_map&lt;int, int&gt;{{0, 0}};
    expect(1_u == std::size(map));
    expect(1_u == erase_if(map, [](const auto&amp; el){ return el == std::pair{0, 0}; }));
    expect(0_u == std::size(map));
  };

  &quot;unique elements&quot;_test = [] {
    auto map = boost::container::flat_map&lt;int, int&gt;{{1, 2}, {2, 3}, {3, 4}};
    expect(3_u == std::size(map));
    expect(1_u == erase_if(map, [](const auto&amp; el){ return el.first == 1; }));
    expect(2_u == std::size(map));
    expect(0_u == map.count(1));
    expect(1_u == map.count(2));
    expect(1_u == map.count(3));
  };

  &quot;elements&quot;_test = [] {
    auto map = boost::container::flat_map&lt;int, int&gt;{{1, 1}, {2, 2}, {3, 3}, {4, 4}};
    expect(4_u == std::size(map));
    expect(2_u == erase_if(map, [](const auto&amp; el){ return el.first % 2 and el.second % 2; }));
    expect(2_u == std::size(map));
    expect(0_u == map.count(1));
    expect(1_u == map.count(2));
    expect(0_u == map.count(3));
    expect(1_u == map.count(4));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v1fbxh98f">https://godbolt.org/z/v1fbxh98f</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
[[nodiscard]] auto erase_if(
    boost::container::flat_map&lt;Ts...&gt; &amp;map,
    std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto
        pred) -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
    auto num_erased = 0u;
    auto it = std::begin(map);
    while (it != std::end(map)) {
        if (pred(*it)) {
            it = map.erase(it);
            ++num_erased;
        } else {
            ++it;
        }
    }
    return num_erased;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gfs6GMbKK">https://godbolt.org/z/Gfs6GMbKK</a></p>
</blockquote>
<p>```cpp<br />
 template<class... Ts><br />
[[nodiscard]] auto erase_if(boost::container::flat_map<Ts...>&amp; map,<br />
                            std::invocable<typename boost::container::flat_map\<Ts...>::value_type> auto pred)<br />
  -&gt; typename boost::container::flat_map<Ts...>::size_type {<br />
    typename boost::container::flat_map<Ts...>::size_type erasedCount{};<br />
    std::ranges::for_each(map, <a _="+" _pred_m_="(pred(m))" erasedCount="erasedCount" href="const auto &amp; m" if="if">&amp;</a> });<br />
    return erasedCount;<br />
}</p>
<pre class="codehilite"><code>&gt; [https://godbolt.org/z/TYbfM4WPz](https://godbolt.org/z/TYbfM4WPz)

```cpp
template &lt;class... Ts&gt;
[[nodiscard]] constexpr auto erase_if(
    boost::container::flat_map&lt;Ts...&gt;&amp; map,
    std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto
        pred) -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
    using map_t = std::remove_cvref_t&lt;decltype(map)&gt;;
    using const_iterator_t = typename map_t::const_iterator;

    auto iter = std::find_if(std::cbegin(map), std::cend(map), pred);
    typename map_t::size_type num_removed{};
    while (iter != std::cend(map)) {
        const const_iterator_t new_begin = map.erase(iter);
        num_removed += 1;
        iter = std::find_if(new_begin, std::cend(map), pred);
    }

    return num_removed;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/998GY8x7j">https://godbolt.org/z/998GY8x7j</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
[[nodiscard]] constexpr auto erase_if(
    boost::container::flat_map&lt;Ts...&gt;&amp; map,
    std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto
        pred) -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
    using map_t = std::remove_cvref_t&lt;decltype(map)&gt;;
    using output_t = typename map_t::size_type;

    const auto remove_begin_iter =
        std::remove_if(std::begin(map), std::end(map), pred);
    const auto num_removed =
        static_cast&lt;output_t&gt;(std::distance(remove_begin_iter, std::end(map)));
    map.erase(remove_begin_iter, std::end(map));
    return num_removed;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/77Wq77Yq6">https://godbolt.org/z/77Wq77Yq6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type{
      auto erased_items = 0;
      for(const auto&amp; item : map){
          if(pred(item)){
              map.erase(item.first);
              ++erased_items;
          }
      }
      return erased_items;
  }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G488x8Tnc">https://godbolt.org/z/G488x8Tnc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
  const auto end = std::remove_if(map.begin(), map.end(), pred);
  const auto n = map.size() - map.index_of(end);
  map.erase(end, map.end());
  return n;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bYrnMn5hY">https://godbolt.org/z/bYrnMn5hY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type
  {
      auto size0 = map.size();
      for(auto iter = map.begin(); iter &lt; map.end(); ){
          if( pred(*iter))
            iter = map.erase(iter);
          else
            iter++;
      }
      return size0 - map.size();
  }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ozPfY67Kv">https://godbolt.org/z/ozPfY67Kv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
      auto removed_count { 0 };

      for(const auto &amp;x : map){
        if(pred(x)){
          map.erase(x.first);
          ++removed_count;
        }
      }
      return removed_count;
  }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9Ead15rEW">https://godbolt.org/z/9Ead15rEW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
      const auto size = std::size(map);
      map.erase(std::remove_if(std::begin(map), std::end(map), pred), std::end(map));
      return size - std::size(map);
  }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zKqob6xP8">https://godbolt.org/z/zKqob6xP8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type{
      size_t s=0;
      auto it = map.begin();
      while(it != map.end()){
          if(pred(*it)){
              it = map.erase(it);
              s++;
          }
          else{
              it++;
          }
      }
      return s;
  }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zvYodToWG">https://godbolt.org/z/zvYodToWG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type
{
    size_t num_erased{};
    for(auto const&amp; el : map)
    {
        if( pred(el) )
        {
            num_erased += map.erase(el.first);
        }
    }
    return num_erased;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Kqfz3Wdrq">https://godbolt.org/z/Kqfz3Wdrq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
[[nodiscard]] auto erase_if(
    boost::container::flat_map&lt;Ts...&gt;&amp; c,
    std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto
        pred) -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
  // [https://en.cppreference.com/w/cpp/container/vector/erase2](https://en.cppreference.com/w/cpp/container/vector/erase2)
  auto it = std::remove_if(c.begin(), c.end(), pred);
  auto r = std::distance(it, c.end());
  c.erase(it, c.end());
  return r;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vfhd9bYz9">https://godbolt.org/z/vfhd9bYz9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] auto erase_if(boost::container::flat_map&lt;Ts...&gt;&amp; map,
                            std::invocable&lt;typename boost::container::flat_map&lt;Ts...&gt;::value_type&gt; auto pred)
  -&gt; typename boost::container::flat_map&lt;Ts...&gt;::size_type {
      auto i = std::remove_if(std::begin(map), std::end(map), pred);
      auto res = std::distance(i, std::end(map));
      map.erase(i, std::end(map));
      return res;
  }
</code></pre>

</div>]]></description>
        </item>
<item>
            <title>267 - Did you know that C++23 added `std::unreachable`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/267.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/267.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>std::unreachable</code>?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0627">https://wg21.link/P0627</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;utility&gt;

int main() {
    std::unreachable();
    return 42; // invokes undefined behavior
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z776vY8EP">https://godbolt.org/z/z776vY8EP</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>switch_id</code> which marks call with unknown id (id != Ids...) as unreachable?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto... Ids&gt;
constexpr auto switch_id(auto id); // TODO

int main(){
    using namespace boost::ut;
    expect(1_i == switch_id&lt;[] { std::unreachable(); }, 1, 2, 4&gt;(1));
    expect(2_i == switch_id&lt;[] { std::unreachable(); }, 1, 2, 4&gt;(2));
    expect(throws&lt;std::runtime_error&gt;([] { switch_id&lt;[] { throw std::runtime_error{&quot;&quot;}; }, 1, 2, 4&gt;(3); }));
    expect(4_i == switch_id&lt;[] { std::unreachable(); }, 1, 2, 4&gt;(4));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z3bP6dsPx">https://godbolt.org/z/z3bP6dsPx</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto... Ids&gt;
constexpr auto switch_id(auto id) {
  if (((id != Ids) and ...)) {
    Unreachable();
  }
  return id;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EefvGeGbz">https://godbolt.org/z/EefvGeGbz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto compare(const auto elem, const auto id, auto&amp; found_it)
{
    if(elem == id){ found_it = true; };
}

template&lt;auto Unreachable, auto...List&gt;
constexpr auto switch_id(auto id)
{
    auto found_it = false;
    auto list_tuple = std::make_tuple(List...);
    std::apply([&amp;found_it,id](auto&amp;&amp;... elem) {((compare(elem,id,found_it)), ...);}, list_tuple);
    if( !found_it ){ Unreachable(); }
    return id;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cfh6bq7Wo">https://godbolt.org/z/cfh6bq7Wo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto... Ids&gt;
constexpr auto id_does_not_exist = [](const auto id){
    return ((id != Ids) and ...);
};


template&lt;auto Unreachable, auto... Ids&gt;
constexpr auto switch_id(auto id){
    if(id_does_not_exist&lt;Ids...&gt;(id)){
        Unreachable();
    }
    return id;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/os1aTGq7b">https://godbolt.org/z/os1aTGq7b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto...Ids&gt;
constexpr auto switch_id(auto id) {
    std::vector ids{Ids...};
    if (std::find(std::begin(ids), std::end(ids), id) == std::end(ids)) {
        Unreachable();
    }

    return id;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c6q1z76je">https://godbolt.org/z/c6q1z76je</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto...IDs&gt;
constexpr auto switch_id(auto id) {
  std::array&lt;int, sizeof...(IDs)&gt; a{IDs...};
  if (std::find(std::cbegin(a), std::cend(a), id) == std::cend(a)) {
   Unreachable();
  }
  return id;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j38M17Erx">https://godbolt.org/z/j38M17Erx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable&gt;
auto switch_id(auto id)
{
    Unreachable();
    return std::declval&lt;decltype(id)&gt;();
}

template&lt;auto Unreachable, auto Car, auto... Cdr&gt;
auto switch_id(auto id)
{
    if (id == Car)
        return id;
    else
        return switch_id&lt;Unreachable, Cdr...&gt;(id);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3q7nhaGeb">https://godbolt.org/z/3q7nhaGeb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto...Ids&gt;
constexpr auto switch_id(auto id) {
    std::common_type_t&lt;decltype(Ids)...&gt; result;
    if ( ((id==Ids ? (result=id, true) : false) || ...) )
        Unreachable();
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eaKqjq74E">https://godbolt.org/z/eaKqjq74E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Unreachable, auto... Ids&gt;
constexpr auto switch_id(auto id){
    constexpr std::array&lt;decltype(id),sizeof...(Ids)&gt; ids = {{ Ids ... }};
    if (std::binary_search(ids.begin(), ids.end(), id)) return id;
    Unreachable();
    return id;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/66KWPxMxb">https://godbolt.org/z/66KWPxMxb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

[[nodiscard]] constexpr auto is_valid_id(const auto id, const auto... ids) {
    return (... and (id == ids));
}

}

template &lt;auto Unreachable, auto... Ids&gt;
constexpr auto switch_id(const auto id) {
    if (not detail::is_valid_id(id, Ids...)) {
        Unreachable();
    }

    return id;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ojsPerYTP">https://godbolt.org/z/ojsPerYTP</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>266 - Did you know wrapping an unqualified function name in parentheses suppresses argument-dependent lookup?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/266.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/266.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know wrapping an unqualified function name in parentheses suppresses argument-dependent lookup?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/basic.lookup#basic.lookup.argdep-1">http://eel.is/c++draft/basic.lookup#basic.lookup.argdep-1</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">namespace adl {
    struct foo {};
    void bar(foo) {}
}

int main() {
    adl::foo foo;
    bar(foo);   // OK,    ADL
    (bar)(foo); // error: no ADL
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ba7Pvqa75">https://godbolt.org/z/ba7Pvqa75</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement function bar which returns { 0: if it's not ADL call, 42: if it's a qualified call; ambigious error: if it's an ADL call }?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;cassert&gt;

//TODO

int main() {
    static_assert([](auto foo) { return requires { adl::bar(foo); }; }(adl::foo{}));
    assert(42 == adl::bar(adl::foo{}));

    static_assert([](auto foo) { return requires { ::bar(foo); }; }(adl::foo{}));
    assert(0 == ::bar(adl::foo{}));

    static_assert([](auto foo) { return requires { (bar)(foo); }; }(adl::foo{}));
    assert(0 == (bar)(adl::foo{}));

    static_assert(not [](auto foo) { return requires { bar(foo); }; }(adl::foo{}));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cxhxW9n8Y">https://godbolt.org/z/cxhxW9n8Y</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace adl {
    struct foo {};
    constexpr auto bar(foo) -&gt; int { return 42; }
}

constexpr auto bar(adl::foo) -&gt; int { return 0; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MPTfK7sKq">https://godbolt.org/z/MPTfK7sKq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace adl {

struct foo {};
[[nodiscard]] constexpr auto bar(const foo) noexcept -&gt; int { return 42; }

}  // namespace adl

[[nodiscard]] constexpr auto bar(const adl::foo) noexcept -&gt; int { return 0; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/73YbYorj3">https://godbolt.org/z/73YbYorj3</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>265 - Did you know that C++23 added Attributes on Lambda-Expressions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/265.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/265.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added Attributes on Lambda-Expressions?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P2173">https://wg21.link/P2173</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto foo = [] [[deprecated]] { };

int main() {
    foo(); // operator() is deprecated
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MaeTnG9eb">https://godbolt.org/z/MaeTnG9eb</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement variable template lambda expression <code>foo</code> which is marked nodiscard for integral types?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">//TODO foo

int main() {
    using namespace boost::ut;

    &quot;should be callable for non integral types&quot;_test = [] {
        foo&lt;float&gt;();
        foo&lt;double&gt;();
    };

    &quot;should verify the result for integral types&quot;_test = [] {
        expect(0_c == foo&lt;char&gt;());
        expect(not foo&lt;bool&gt;());
        expect(0_s == foo&lt;short&gt;());
        expect(0_i == foo&lt;int&gt;());
    };

    &quot;should ignore the result for integral types&quot;_test = [] {
        /*TODO*/ foo&lt;char&gt;();
        /*TODO*/ foo&lt;bool&gt;();
        /*TODO*/ foo&lt;short&gt;();
        /*TODO*/ foo&lt;int&gt;();
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fKfjsbWoh">https://godbolt.org/z/fKfjsbWoh</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
</div>]]></description>
        </item>
<item>
            <title>264 - Did you know that C++20 added `__VA_OPT__` for comma omission and comma deletion?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/264.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/264.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added <code>__VA_OPT__</code> for comma omission and comma deletion?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0306">https://wg21.link/P0306</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#define VARIADIC(...) __VA_OPT__(__LINE__)

VARIADIC()     // `empty`
VARIADIC(a)    // `line` 4
VARIADIC(a, b) // `line` 5
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rsj9ax7xY">https://godbolt.org/z/rsj9ax7xY</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement LOG1/LOG2 macros which will return formatted string and will apply <code>__VA_OPT__</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#define LOG1($fmt, ...) // TODO
#define LOG2(...) // TODO

int main() {
    using namespace boost::ut;
    using std::string_literals::operator&quot;&quot;s;

    expect(&quot;&quot;s == LOG1(&quot;&quot;));
    expect(&quot;42&quot;s == LOG1(&quot;42&quot;));
    expect(&quot;4&quot;s  == LOG1(&quot;%d&quot;, 4));

    expect(&quot;&quot;s == LOG2(&quot;&quot;));
    expect(&quot;42&quot;s == LOG2(&quot;42&quot;));
    expect(&quot;4&quot;s  == LOG2(&quot;%d&quot;, 4));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sPTqoEdMG">https://godbolt.org/z/sPTqoEdMG</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#define LOG1($fmt, ...) fmt::sprintf($fmt __VA_OPT__(,) __VA_ARGS__)
#define LOG2(...) __VA_OPT__(fmt::sprintf(__VA_ARGS__))
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5TM7WsMfx">https://godbolt.org/z/5TM7WsMfx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">#define LOG1($fmt, ...) fmt::sprintf($fmt __VA_OPT__(,) __VA_ARGS__)
#define LOG2(...) fmt::sprintf(__VA_ARGS__)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/135j8s5PP">https://godbolt.org/z/135j8s5PP</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>263 - Did you know that C++23 added std::byteswap to swap bytes?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/263.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/263.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added std::byteswap to swap bytes?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p1272">https://wg21.link/p1272</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;bit&gt;

int main() {
   constexpr auto value = std::uint16_t(0xCAFE);
   std::cout &lt;&lt; std::hex &lt;&lt; value; // pritns cafe
   std::cout &lt;&lt; std::hex &lt;&lt; std::byteswap(value); // prints feca
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6aT8GW4Yj">https://godbolt.org/z/6aT8GW4Yj</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>bytes_to_string</code> (using std::byteswap) which converts given value to its string bytes respresntation?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{
  return {}; // TODO
}

int main(){
  using namespace boost::ut;
  using std::string_literals::operator&quot;&quot;s;

  &quot;bytes to string&quot;_test = [] {
    expect(&quot;00000000 : 00 00 00 00 &quot;s == bytes_to_string(0));
    expect(&quot;00000001 : 00 00 00 01 &quot;s == bytes_to_string(1));
    expect(&quot;0000CAFE : 00 00 CA FE &quot;s == bytes_to_string(0xCAFE));
    expect(&quot;0000BABA : 00 00 BA BA &quot;s == bytes_to_string(0xBABA));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zsr91cer6">https://godbolt.org/z/zsr91cer6</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string {
  constexpr auto size = sizeof(value) * 2 + 3 + sizeof(value) * 3;
  std::array&lt;char, size&gt; output{};
  output.fill(' ');
  output[sizeof(value) * 2 + 1] = ':';

  constexpr auto to_hex = [] (const unsigned char nybble) -&gt; char {
    return &quot;0123456789ABCDEF&quot;[nybble];
  };

  const auto bs_value = std::byteswap(value);
  const auto first = reinterpret_cast&lt;const unsigned char*&gt;(std::addressof(bs_value));
  const auto last = first + sizeof(bs_value);

  auto dest1 = std::begin(output);
  auto dest2 = std::next(dest1, sizeof(bs_value) * 2 + 3);
  for (auto f = first; f != last; ++f) {
    *dest1 = to_hex(*f &gt;&gt; 4);
    *dest2++ = *dest1++;
    *dest1 = to_hex(*f &amp; 0xf);
    *dest2++ = *dest1++;
    ++dest2;
  }

  return std::string{std::data(output), size};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h9hd7v1xx">https://godbolt.org/z/h9hd7v1xx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] auto bytes_to_string(std::integral auto value) -&gt; std::string {
  std::stringstream str{};
  str &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::setfill('0')
      &lt;&lt; std::setw(sizeof(value) * 2) &lt;&lt; value &lt;&lt; &quot; : &quot;;
    value = std::byteswap(value);
    for (auto i = 0u; i != sizeof(value); ++i, value &gt;&gt;= 8) {
        str &lt;&lt; std::setw(2) &lt;&lt; (0xFFu &amp; value) &lt;&lt; ' ';
    }
    return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/36TPaevW9">https://godbolt.org/z/36TPaevW9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{
    char digits[] = &quot;0123456789ABCDEF&quot;;
    char ret[] = &quot;00000000 : 00 00 00 00 &quot;;
    for(int i=0; i&lt;8; i++) {
        ret[21-(i+i/2)] = ret[7-i] = digits[value &amp; 0xF];
        value &gt;&gt;= 4;
    }
    return ret;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jenxjsqKj">https://godbolt.org/z/jenxjsqKj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] auto convert_to_string(std::integral auto value) -&gt; std::string {
    static constexpr auto MAX_BYTES = 4;
    static_assert(sizeof(value) &lt;= MAX_BYTES,
                  &quot;This function is not setup to print 64b values&quot;);

    std::array&lt;uint8_t, MAX_BYTES&gt; bytes{};
    std::memcpy(&amp;bytes, &amp;value, sizeof(value));

    return fmt::format(&quot;{1:0{0}X} : {2:02X} {3:02X} {4:02X} {5:02X}&quot;,
                       MAX_BYTES * 2, value, bytes[3], bytes[2], bytes[1],
                       bytes[0]);
}

}  // namespace detail

[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value)
    -&gt; std::string {
    if constexpr (std::endian::native == std::endian::big) {
        return detail::convert_to_string(std::byteswap(value));
    } else {
        return detail::convert_to_string(value);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6qbG1q6f3">https://godbolt.org/z/6qbG1q6f3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{

    value = std::byteswap(value);

    const BYTE d = (value &amp; 0xFF); //extract first byte
    const BYTE c = ((value &gt;&gt; 8) &amp; 0xFF); //extract second byte
    const BYTE b = ((value &gt;&gt; 16) &amp; 0xFF); //extract third byte
    const BYTE a = ((value &gt;&gt; 24) &amp; 0xFF); //extract fourth byte

    char buffer[23];
    unsigned int len = sprintf(buffer,&quot;%02X%02X%02X%02X : %02X %02X %02X %02X&quot;, d, c, b, a, d, c, b, a);
    buffer[len] = ' ';
    std::string out_str(buffer);

  return out_str;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v371e3nPz">https://godbolt.org/z/v371e3nPz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value)
    -&gt; std::string {
  return [=]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
    constexpr auto to_hex = [](std::integral auto value) {
      return fmt::format(&quot;{:0&gt;{}X} &quot;, value, 2 * sizeof(value));
    };
    const auto array = std::bit_cast&lt;std::array&lt;std::uint8_t, sizeof(value)&gt;&gt;(
        std::byteswap(value));

    return ((to_hex(value) + &quot;: &quot;) + ... + to_hex(array[Is]));
  }
  (std::make_index_sequence&lt;sizeof(value)&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3WGsnj7xa">https://godbolt.org/z/3WGsnj7xa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{
  std::string str{&quot;00000000 : 00 00 00 00 &quot;};

  auto nibblesToChars = [](unsigned char byte) {
    byte &amp;= 0x0F;
    byte += (byte &lt; 0x0A) ? '0' : '7';
    return byte;
  };

  auto insertCharIntoOutputString = [&amp;](auto index, auto nibble_offset, char ch){
    str[(index*2)+nibble_offset   ] = ch;
    str[(index*3)+nibble_offset+11] = ch;
  };

  auto bytesToChars = [&amp;](std::integral auto value){
    for(auto ii = 0; ii &lt; 4; ii++){
      insertCharIntoOutputString(ii, 0, nibblesToChars(value&gt;&gt;4));
      insertCharIntoOutputString(ii, 1, nibblesToChars(value   ));
      value &gt;&gt;= 8;
    }
  };

  bytesToChars(std::byteswap(value));
  return str;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4oPsvdGYE">https://godbolt.org/z/4oPsvdGYE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename InputIt&gt;
std::string join(InputIt first, InputIt last, const std::string&amp; separator = &quot;,&quot;) {
    std::ostringstream result;
    if (first != last) {
        result &lt;&lt; *first;
        while (++first != last) {
            result &lt;&lt; separator &lt;&lt; *first;
        }
    }
    return result.str();
}

auto extract_byte(auto number, auto n){
    int x = (number &gt;&gt; (8*n)) &amp; 0xff;
    return x;
}

auto to_hex(auto value) {
    std::string s = fmt::format(&quot;{:02X}&quot;, value);
    return s;
}

auto swap_bytes = [](const auto x) {return std::optional{ std::byteswap(x) };};

template&lt;int size=2&gt;
auto split_bytes = [](auto x){
    std::array&lt;std::string, size&gt; bytes{};

    for( auto i = 0; i&lt;size; ++i) {
        bytes[i] = to_hex(extract_byte(x, i));
    }

    return std::optional{bytes};
};

auto make_output = [](auto x){
    std::string combined_bytes = join(std::begin(x), std::end(x), &quot;&quot;);
    std::string split_bytes = join(std::begin(x), std::end(x), &quot; &quot;);

    return std::optional{ fmt::format(&quot;{} : {}&quot;, combined_bytes, split_bytes) };
};

[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{
    return std::optional{value}
        .and_then(swap_bytes)
        .and_then(split_bytes&lt;sizeof(value)&gt;)
        .and_then(make_output).value();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5nYs6rxzr">https://godbolt.org/z/5nYs6rxzr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string{
    uint8_t bytes[sizeof(value)];
    for(int i=0; i &lt; sizeof(value); i++){
        bytes[i] = value%16 &lt;&lt; 4;
        value = value/16;
        bytes[i] |= value%16;
        value = value/16;
    }
    decltype(value) *x = reinterpret_cast&lt;decltype(value) *&gt;(bytes);
    *x = std::byteswap(*x);
    std::string s1{&quot;&quot;};
    std::string s2{&quot;&quot;};
    const char* digits = &quot;0123456789ABCDEF&quot;;
    for(int i=0; i &lt; sizeof(value); i++){
        s1 += digits[bytes[i] &amp; 0x0F];
        s1 += digits[bytes[i] &gt;&gt; 4 &amp; 0x0F];
        s2 += digits[bytes[i] &amp; 0x0F];
        s2 += digits[bytes[i] &gt;&gt; 4 &amp; 0x0F];
        s2 += &quot; &quot;;
    }
    return s1 + &quot; : &quot; + s2;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Tfs5no1f1">https://godbolt.org/z/Tfs5no1f1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] constexpr auto bytes_to_string(std::integral auto value) -&gt; std::string {
  constexpr auto n_bytes = sizeof(value);
  const auto bytes = std::bit_cast&lt;std::array&lt;std::uint8_t, n_bytes&gt;&gt;(std::byteswap(value));
  return fmt::format(&quot;{:02X} : {:02X} &quot;, fmt::join(bytes, &quot;&quot;), fmt::join(bytes, &quot; &quot;));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M5e1xxbcc">https://godbolt.org/z/M5e1xxbcc</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>262 - Did you know that type_info equality operator is constexpr in C++23?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/262.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/262.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that type_info equality operator is constexpr in C++23?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p1328">https://wg21.link/p1328</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;typeinfo&gt;
#include &lt;type_traits&gt;

static_assert(std::is_same_v&lt;int, int&gt;);
static_assert(typeid(int) == typeid(int));

static_assert(typeid(int) == typeid(const int));
static_assert(not std::is_same_v&lt;int, const int&gt;);

static_assert(typeid(int) == typeid(const int&amp;));
static_assert(not std::is_same_v&lt;int, const int&amp;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jddq7s1o4">https://godbolt.org/z/jddq7s1o4</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>compare_types</code> function which compare given types by leveraging typeid comparison?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">#include &lt;typeinfo&gt;

template&lt;class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool; // TODO

static_assert(compare_types());
static_assert(compare_types&lt;int&gt;());
static_assert(compare_types&lt;void&gt;());
static_assert(compare_types&lt;int, int&gt;());
static_assert(compare_types&lt;const int, int, int const&gt;());
static_assert(compare_types&lt;const int&amp;, int&gt;());
static_assert(compare_types&lt;int&amp;, int&amp;&amp;&gt;());
static_assert(compare_types&lt;int, int&amp;&amp;, int&amp;, const int&amp;, int const&amp;&amp;&gt;());
static_assert(compare_types&lt;int&amp;, const int&amp;&gt;());
static_assert(compare_types&lt;void, void, void&gt;());

static_assert(not compare_types&lt;int, float&gt;());
static_assert(not compare_types&lt;void*, const void*, void* const&gt;());
static_assert(not compare_types&lt;int, int*&gt;());
static_assert(not compare_types&lt;int*, int**&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8P73zn9qP">https://godbolt.org/z/8P73zn9qP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, class U&gt;
using types_equal_t = std::bool_constant&lt;typeid(T) == typeid(U)&gt;;

template&lt;class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool {
  using pairwise_equality_t = boost::mp11::mp_pairwise_fold&lt;boost::mp11::mp_list&lt;Ts...&gt;, types_equal_t&gt;;
  return boost::mp11::mp_apply&lt;boost::mp11::mp_all, pairwise_equality_t&gt;::value;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nqjrbGrzf">https://godbolt.org/z/nqjrbGrzf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto compare_types() -&gt; bool{ return true; }

template&lt;class T&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool{ return true; }

template&lt;class R, class T, class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool{
    return typeid(R) == typeid(T) &amp;&amp; compare_types&lt;T,Ts...&gt;();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o3jPvPor5">https://godbolt.org/z/o3jPvPor5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool
{
    if constexpr (sizeof...(Ts) == 0) {
        return true;
    }
    else {
        auto helper = []&lt;typename H, typename... Hs&gt;() {
            return ((typeid(H) == typeid(Hs)) &amp;&amp; ...);
        };

        return helper.template operator()&lt;Ts...&gt;();
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cGne6Y5xa">https://godbolt.org/z/cGne6Y5xa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[nodiscard]] consteval auto compare_types() -&gt; bool {
    return true;
}

template &lt;class T, class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool {
    if constexpr (sizeof...(Ts) == 0) {
        return true;
    } else {
        return (... and (typeid(T) == typeid(Ts)));
    }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/469d6oPc5">https://godbolt.org/z/469d6oPc5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] consteval bool compare_types();

template&lt;class A, class B, class... Ts&gt;
[[nodiscard]] consteval auto compare_2types_and_a_seq_of_types() -&gt; bool {
  return (typeid(A) == typeid(B)) &amp;&amp; (compare_types&lt;A, Ts...&gt;());
}

template&lt;class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool{
  if constexpr(sizeof...(Ts) &gt; 1){ return compare_2types_and_a_seq_of_types&lt;Ts...&gt;(); }
  else                           { return true; }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5ePox7vEh">https://godbolt.org/z/5ePox7vEh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
[[nodiscard]] constexpr auto compare_types() -&gt; bool {
  const std::type_info* type_ptrs[]{&amp;typeid(std::remove_cvref_t&lt;Ts&gt;)...};

  for (auto type_ptr : type_ptrs) {
    if (*type_ptr != **type_ptrs) return false;
  }

  return true;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4c6qK3aoE">https://godbolt.org/z/4c6qK3aoE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval bool compare_types() {
    return true;
}

template&lt;class T1&gt;
[[nodiscard]] consteval bool compare_types() {
    return true;
}

template&lt;class T1, class T2, class...Ts&gt;
[[nodiscard]] consteval bool compare_types() {
        return typeid(T1) == typeid(T2) and compare_types&lt;T2, Ts...&gt;();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ee8a7sKxh">https://godbolt.org/z/ee8a7sKxh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename ... Ts&gt;
struct types{};

template&lt;class... Ts&gt;
consteval bool compare_types(){
  constexpr auto n = sizeof...(Ts);
  if constexpr (n == 0 || n == 1){ return true;
  } else {
    return []&lt;typename U1, typename U2, typename ... Us&gt;(types&lt;U1, U2, Us ...&gt;){
      return typeid(U1) == typeid(U2) &amp;&amp; compare_types&lt;U2, Us ...&gt;();
    }(types&lt;Ts...&gt;{});
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K9n1erMxa">https://godbolt.org/z/K9n1erMxa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
[[nodiscard]] consteval auto compare_types() -&gt; bool {
    if constexpr( sizeof...(Ts) &lt; 1)
        return true;
    else {
        auto all_equal = []&lt;typename T1, typename...Tr&gt;() {
            return ((typeid(T1) == typeid(Tr)) &amp;&amp; ...);
        };
        return all_equal.template operator()&lt;Ts...&gt;();
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TMTEsEzxc">https://godbolt.org/z/TMTEsEzxc</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>261 - Did you know that C++23 added Monadic operations for std::optional?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/261.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/261.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added Monadic operations for std::optional?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0798">https://wg21.link/P0798</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  auto opt = std::optional{42};
  opt.and_then([](auto o)-&gt;std::optional&lt;int&gt;{ std::cout &lt;&lt; o;; return std::nullopt; });// prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aeKWEa63b">https://godbolt.org/z/aeKWEa63b</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you refactor <code>execute</code> routine with monadic Monadic operations?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct market_data{};
struct trade{};
struct order{};
struct order_with_id{};

std::optional&lt;order_with_id&gt; execute(auto&amp; ts, const market_data&amp; md) {
        auto trade = ts.parse(md);
        if (not trade) {
            return std::nullopt;
        }

        auto order = ts.model(*trade);
        if (not order) {
            return std::nullopt;
        }

        if (auto order_with_id = ts.map(*order)) {
            return order_with_id;
        } else {
            return std::nullopt;
        }
}

int main(){
    using namespace boost::ut;

    should(&quot;produce bail out on market data&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; { return {}; }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; { return {{}}; }
        } fake_ts;

        expect(not execute(fake_ts, {}).has_value());
    };

    should(&quot;produce bail out on model&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; { return {{}}; }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; { return {{}}; }
        } fake_ts;

        expect(not execute(fake_ts, {}).has_value());
    };

    should(&quot;produce bail out on map&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; { return {{}}; }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; { return {}; }
        } fake_ts;

        expect(not execute(fake_ts, {}).has_value());
    };

    should(&quot;produce an order&quot;) = [] {
        struct {
            auto parse(const market_data&amp;) -&gt; std::optional&lt;trade&gt; { return {{}}; }
            auto model(const trade&amp;) -&gt; std::optional&lt;order&gt; { return {{}}; }
            auto map(const order&amp;) -&gt; std::optional&lt;order_with_id&gt; { return {{}}; }
        } fake_ts;

        expect(execute(fake_ts, {}).has_value());
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oG4qMPxEe">https://godbolt.org/z/oG4qMPxEe</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">std::optional&lt;order_with_id&gt; execute(auto&amp; ts, const market_data&amp; md) {
    return ts.parse(md)
             .and_then([&amp;](const trade&amp; t) { return ts.model(t); })
             .and_then([&amp;](const order&amp; o) { return ts.map(o); });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z36z3f9cd">https://godbolt.org/z/z36z3f9cd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">std::optional&lt;order_with_id&gt; execute(auto&amp; ts, const market_data&amp; md) {
    auto model = [&amp;ts](const auto &amp;t){ return ts.model(t); };
    auto map = [&amp;ts](const auto &amp;o){ return ts.map(o); };

    return ts.parse(md)
        .and_then(model)
        .and_then(map);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/se6MYh11q">https://godbolt.org/z/se6MYh11q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">decltype(auto) operator|(auto&amp;&amp; x, auto&amp;&amp; p) { return x.and_then(p); }

std::optional&lt;order_with_id&gt; execute(auto&amp; ts, const market_data&amp; md) {
  return ts.parse(md) | [&amp;ts](auto o) { return ts.model(o); } |
         [&amp;ts](auto o) { return ts.map(o); };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GEf5j6zej">https://godbolt.org/z/GEf5j6zej</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>260 - Did you know that C++23 added std::move_only_function?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/260.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/260.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added std::move_only_function?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0288">https://wg21.link/P0288</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;functional&gt;

int main() {
  {
  std::function&lt;int()&gt; f{[]{return 42; }};
  auto copy = f; // okay
  auto value = f();
  }

  {
  std::move_only_function&lt;int()&gt; f{[] {return 42; }};
  auto copy = f; // error, call to deleted copy constructor
  auto value = f(); // undefined behaviour, dandling reference
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KWTx4nd3n">https://godbolt.org/z/KWTx4nd3n</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you comment out and fill <code>???</code> with appropirate function type (std::function or std::move_only_function) when applicable?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  {
    auto f = [] { return 42; };
    // TODO
    // ??? f1 = f;
    // ??? f2 = std::move(f);
  }

  {
    auto value = 42;
    auto f = [v = std::move(value)] { return v; };
    // TODO
    // ??? f1 = f;
    // ??? f2 = std::move(f);
  }

  {
    auto f = [u = std::make_unique&lt;int&gt;(42)] { return *u; };
    // TODO
    // ??? f1 = f;
    // ??? f2 = std::move(f);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hK4EGvd1q">https://godbolt.org/z/hK4EGvd1q</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
</div>]]></description>
        </item>
<item>
            <title>259 - Did you know that static reflection supports introspecting constructors?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/259.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/259.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that static reflection supports introspecting constructors?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  foo(int i) { }
};

auto main() -&gt; int {
  namespace meta = std::experimental::reflect;
  std::cout &lt;&lt; meta::get_size_v&lt;meta::get_constructors_t&lt;reflexpr(foo)&gt;&gt;; // prints 1
  std::cout &lt;&lt; meta::get_name_v&lt;meta::get_element_t&lt;0, meta::get_constructors_t&lt;reflexpr(foo)&gt;&gt;&gt;; // prints foo
  std::cout &lt;&lt; meta::get_name_v&lt;meta::get_element_t&lt;0, meta::get_parameters_t&lt;meta::get_element_t&lt;0, meta::get_constructors_t&lt;reflexpr(foo)&gt;&gt;&gt;&gt;&gt;; // prints i
}
</code></pre>

<blockquote>
<p><a href="https://compiler-explorer.com/z/xzTeWEYKc">https://compiler-explorer.com/z/xzTeWEYKc</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simple interface dependency injection framework which injects interface accodringly to given wiring?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TWirings&gt;
struct injector; // TODO

struct interface {
  virtual ~interface() noexcept = default;
  virtual auto get() const -&gt; int = 0;
};

template&lt;auto N&gt;
struct implementation : interface {
  auto get() const -&gt; int  override { return N; }
};

int main() {
  using namespace boost::ut;

  &quot;dependency injection&quot;_test = [] {
    struct dependency_injection {
      explicit(true) dependency_injection(const interface&amp; i1) : i1{i1} { }

      auto run() { return i1.get(); }

    private:
      const interface&amp; i1;
    };

    const auto wiring = injector{
      bind&lt;interface, implementation&lt;42&gt;&gt;(),
    };

    auto di = wiring.create&lt;dependency_injection&gt;();
    expect(42_i == di.run());
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bar7zax88">https://godbolt.org/z/bar7zax88</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TWirings&gt;
struct injector : TWirings... {
  explicit(true) constexpr injector(TWirings...) {}

  template &lt;class T&gt;
  constexpr auto create() const {
    return [this]&lt;class... Ts&gt;(std::tuple&lt;Ts...&gt;) {
      const auto wiring = [this]&lt;class TName, class TParam&gt;(
                              TName, TParam) -&gt; decltype(auto) {
        constexpr auto has_type_wiring = []&lt;class TWiring&gt;(TWiring) {
          return std::is_same_v&lt;std::remove_cvref_t&lt;meta::get_reflected_type_t&lt;
                                    meta::get_type_t&lt;TParam&gt;&gt;&gt;,
                                typename TWiring::if_t&gt;;
        };
        constexpr auto has_named_wiring = []&lt;class TWiring&gt;(TWiring) {
          return std::string_view{TWiring::name}.substr(
                     0, std::size(std::string_view{meta::get_name_v&lt;TName&gt;})) ==
                     meta::get_name_v&lt;TName&gt; and
                 std::string_view{TWiring::name}.substr(
                     std::size(std::string_view{meta::get_name_v&lt;TName&gt;}) +
                     1) == meta::get_name_v&lt;TParam&gt;;
        };

        static_assert(
            ((has_type_wiring(TWirings{}) or has_named_wiring(TWirings{})) or
             ...),
            &quot;Missing wiring!&quot;);
        static std::shared_ptr&lt;std::remove_cvref_t&lt;
            meta::get_reflected_type_t&lt;meta::get_type_t&lt;TParam&gt;&gt;&gt;&gt;
            param{};
        (
            [&amp;] {
              if constexpr (has_named_wiring(TWirings{})) {
                param = std::make_shared&lt;typename TWirings::impl_t&gt;();
              } else if constexpr (has_type_wiring(TWirings{})) {
                param = std::make_shared&lt;typename TWirings::impl_t&gt;();
              }
            }(),
            ...);
        return *param;
      };

      return (
          [&amp;]&lt;class TName, class... TParams&gt;(TName, std::tuple&lt;TParams...&gt;) {
            return T{wiring(TName{}, TParams{})...};
          }(Ts{},
            meta::unpack_sequence_t&lt;std::tuple, meta::get_parameters_t&lt;Ts&gt;&gt;{}),
          ...);
    }
    (meta::unpack_sequence_t&lt;std::tuple,
                             meta::get_constructors_t&lt;reflexpr(T)&gt;&gt;{});
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jMW75r7nP">https://godbolt.org/z/jMW75r7nP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TWirings&gt;
struct injector : TWirings... {
  constexpr injector(TWirings...) {}

  template &lt;class T&gt;
  auto create() const {
    using constructors_t = meta::get_constructors_t&lt;reflexpr(T)&gt;;
    using constructor_t = meta::get_element_t&lt;0, constructors_t&gt;;
    using parameters_t = meta::get_parameters_t&lt;constructor_t&gt;;

    return [&amp;] &lt;class... Params&gt; (std::tuple&lt;Params...&gt;) {
      return T([&amp;] &lt;class Param&gt; {
        using if_t = std::remove_cvref_t&lt;meta::get_reflected_type_t&lt;meta::get_type_t&lt;Param&gt;&gt;&gt;;

        return [] &lt;auto Name, class TImpl&gt; (const detail::bind&lt;Name, if_t, TImpl&gt; *) {
          return TImpl{};
        }(this);
      }.template operator()&lt;Params&gt;()...);
    }(meta::unpack_sequence_t&lt;std::tuple, parameters_t&gt;{});
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/96Tzqexr3">https://godbolt.org/z/96Tzqexr3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TWirings&gt;
struct injector : TWirings... {
  constexpr explicit(true) injector(TWirings...) noexcept {};

  template &lt;class T&gt;
  constexpr auto create() const {
    return [] &lt;class TFirstConstructor, class... TConstructors&gt; (std::tuple&lt;TFirstConstructor, TConstructors...&gt;) {
      const auto implementation_for = [] &lt;class TInterface&gt; (TInterface) {
        using interface_t = std::remove_cvref_t&lt;meta::get_reflected_type_t&lt;meta::get_type_t&lt;TInterface&gt;&gt;&gt;;
        using impl_t = decltype(lookup_impl&lt;interface_t&gt;(std::declval&lt;injector&gt;()));
        return impl_t{};
      };

      const auto make_T = [&amp;] &lt;class... TParams&gt; (std::tuple&lt;TParams...&gt;) {
        return T{implementation_for(TParams{})...};
      };
      return make_T(meta::unpack_sequence_t&lt;std::tuple, meta::get_parameters_t&lt;TFirstConstructor&gt;&gt;{});
    }(meta::unpack_sequence_t&lt;std::tuple, meta::get_constructors_t&lt;reflexpr(T)&gt;&gt;{});
  }

private:
  template &lt;class TInterface, auto TName, class TImpl&gt;
  constexpr static auto lookup_impl(const detail::bind&lt;TName, TInterface, TImpl&gt; &amp;) -&gt; TImpl;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TWrWjTaof">https://godbolt.org/z/TWrWjTaof</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>258 - Did you know that static reflection can be used to invoke functions with named parameters?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/258.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/258.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that static reflection can be used to invoke functions with named parameters?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  auto api(int i) -&gt; void { std::cout &lt;&lt; i; }
};

auto main() -&gt; int {
  namespace meta = std::experimental::reflect;
  foo f{};
  (f.*meta::get_pointer_v&lt;meta::get_element_t&lt;0, meta::get_member_functions_t&lt;reflexpr(foo)&gt;&gt;&gt;)(42); // prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sMeeo981v">https://godbolt.org/z/sMeeo981v</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement invoke which calls given by name function from reflected struct with given named parameters?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;fixed_string Name&gt; /*TODO*/ invoke{};

struct foo {
  auto bar(int value) { bar_called_with = value; }
  auto baz(int i, double d) { baz_called_with = {i, d}; }

  std::optional&lt;int&gt; bar_called_with{};
  std::optional&lt;std::pair&lt;int, double&gt;&gt; baz_called_with{};
};

int main() {
  using namespace boost::ut;

  &quot;invoke&quot;_test = [] {
    should(&quot;support single value&quot;) = [] {
      foo f{};
      invoke&lt;&quot;bar&quot;&gt;(f, &quot;value&quot;_arg = 42);
      expect(not f.baz_called_with and f.bar_called_with and *f.bar_called_with == 42_i);
    };

    should(&quot;support diff order&quot;) = [] {
      foo f{};
      invoke&lt;&quot;baz&quot;&gt;(f, &quot;i&quot;_arg = 4,  &quot;d&quot;_arg = 2.0);
      expect(not f.bar_called_with and f.baz_called_with and *f.baz_called_with == std::pair{4, 2.});
    };

    should(&quot;support diff order&quot;) = [] {
      foo f{};
      invoke&lt;&quot;baz&quot;&gt;(f, &quot;d&quot;_arg = 0., &quot;i&quot;_arg = 42);
      expect(not f.bar_called_with and f.baz_called_with and *f.baz_called_with == std::pair{42, .0});
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zTnEeaTxf">https://godbolt.org/z/zTnEeaTxf</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;fixed_string Name, class T, class... Args&gt; decltype(auto) invoke(T&amp; t, Args&amp;&amp;...args) {
  const auto get_arg = [&amp;] &lt;class P&gt; {
    return ([&amp;] -&gt; meta::get_reflected_type_t&lt;meta::get_type_t&lt;P&gt;&gt; {
              if constexpr(std::string_view{meta::get_name_v&lt;P&gt;} == Args::name) {
                return args.value;
              } else {
                return {};
              }}() + ...); // exploiting +
  };

  const auto call = [&amp;] &lt;class F&gt; -&gt; bool {
    if constexpr (std::string_view{meta::get_name_v&lt;F&gt;} == Name) {
      const auto f = meta::get_pointer_v&lt;F&gt;;
      using params_t = meta::get_parameters_t&lt;F&gt;;
      [&amp;] &lt;class TParams, auto... Ns&gt; (TParams, std::index_sequence&lt;Ns...&gt;) {
        (t.*f)(get_arg.template operator()&lt;meta::get_element_t&lt;Ns, TParams&gt;&gt;()...);
      }(params_t{}, std::make_index_sequence&lt;meta::get_size_v&lt;params_t&gt;&gt;{});
      return true;
    } else {
      return false;
    }
  };

  using type = meta::get_aliased_t&lt;reflexpr(T)&gt;;
  using member_functions_t = meta::get_member_functions_t&lt;type&gt;;
  std::apply([&amp;] &lt;class... Fs&gt; (Fs...) {
      (call.template operator()&lt;Fs&gt;() or ...);
    }, meta::unpack_sequence_t&lt;std::tuple, member_functions_t&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ka3xYYd7a">https://godbolt.org/z/Ka3xYYd7a</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>257 - Did you know that static reflection can be used to implement row polymorphism?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/257.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/257.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that static reflection can be used to implement row polymorphism?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  int a{};
  int b{};
};

struct bar {
  int a{};
};

struct missing_a {
  int b{};
};

struct row_with_member_a {
  constexpr explicit(false) row_with_member_a(const auto&amp; t)
    : a{t.a}
  { }

  int a{};
};

auto shrink(row_with_member_a r) {
  std::cout &lt;&lt; r.a;
}

int main() {
  //shrink(missing_a{.b = 42}); // error
  shrink(foo{.a = 4, .b = 2}); // prints 4
  shrink(bar{.a = 42}); // prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/arxnx1xaj">https://godbolt.org/z/arxnx1xaj</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a generic shrink function which uses row polymorphism technique to shrink input type and returns string output?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;fixed_string Name, class TValue = void*&gt;
struct row {
  static constexpr auto name = Name;
  TValue value{};
  template &lt;class T&gt;
  constexpr auto operator=(const T&amp; t) {
    return row&lt;Name, T&gt;{.value = t};
  }
};

template &lt;fixed_string Name&gt;
constexpr auto operator&quot;&quot;_row() {
  return row&lt;Name&gt;{};
}

template &lt;class... Ts&gt;
struct rows; // TODO

auto shrink(rows&lt;row&lt;&quot;a&quot;, int&gt;, row&lt;&quot;b&quot;, int&gt;&gt; t) {
  return std::to_string(t[&quot;a&quot;_row]) + &quot;, &quot; + std::to_string(t[&quot;b&quot;_row]);
}

struct empty {};

struct nope {
  int a{};
};

struct foo {
  int a{};
  int b{};
};

struct bar {
  int c{};
  int b{};
  int a{};
};

int main() {
  using namespace boost::ut;

  static_assert(not [](auto t) { return requires { shrink(t); };}(empty{}));
  static_assert(not [](auto t) { return requires { shrink(t); }; }(nope{}));
  static_assert([](auto t) { return requires { shrink(t); }; }(foo{}));
  static_assert([](auto t) { return requires { shrink(t); }; }(bar{}));

  using std::literals::string_literals::operator&quot;&quot;s;
  expect(&quot;1, 2&quot;s == shrink(foo{.a = 1, .b = 2}));
  expect(&quot;2, 4&quot;s == shrink(bar{.c = 8, .b = 4, .a = 2}));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/crGqYjfoT">https://godbolt.org/z/crGqYjfoT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, fixed_string Name&gt;
concept has_member_named = []&lt;class... Ts&gt;(type_list&lt;Ts...&gt;) {
  return ((std::string_view{meta::get_name_v&lt;Ts&gt;} == Name) or ...);
}(meta::unpack_sequence_t&lt;type_list, meta::get_data_members_t&lt;reflexpr(T)&gt;&gt;{});

template &lt;class T, fixed_string... Names&gt;
concept has_members_named = (has_member_named&lt;T, Names&gt; and ...);

template &lt;class... TRows&gt;
struct rows : TRows... {
  template &lt;has_members_named&lt;TRows::name...&gt; T&gt;
  rows(const T&amp; t) {
    for_each(get_data_members(get_aliased(mirror(T))),
      [&amp;](auto mo) {
        if constexpr (constexpr std::string_view s = std::data(get_name(mo));
                      ((s == TRows::name) or ...)) {
          constexpr fixed_string&lt;std::size(s)&gt; name = std::data(s);
          (*this)[row&lt;name&gt;{}] = get_value(mo, t);
        }
      });
  }

  template &lt;class N&gt;
  constexpr auto operator[](N) -&gt; decltype(auto) {
    return [] &lt;class T&gt; (row&lt;N::name, T&gt;&amp; t) -&gt; auto&amp; {
      return t.value;
    }(*this);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rj7Wjdxnb">https://godbolt.org/z/rj7Wjdxnb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class...&gt;
struct rows;

template &lt;class T, fixed_string Name&gt;
concept shrinkable = [] {
  using namespace std::experimental::reflect;

  return []&lt;class... Ts&gt;(std::tuple&lt;Ts...&gt;) {
    return (... or (std::string_view{get_name_v&lt;Ts&gt;} == Name));
  }
  (unpack_sequence_t&lt;std::tuple, get_data_members_t&lt;reflexpr(T)&gt;&gt;{});
}();

template &lt;class... Ts&gt;
struct rows : Ts... {
  template &lt;class T&gt;
  requires(... and shrinkable&lt;T, Ts::name&gt;) constexpr rows(const T &amp;t) {
    for_each(get_data_members(mirror(T)), [&amp;](auto member) {
      if constexpr (constexpr std::string_view name = get_name(member);
                    (... or (name == Ts::name))) {
        using key = row&lt;fixed_string&lt;size(name)&gt;{data(name)}&gt;;
        (*this)[key{}] = get_value(member, t);
      }
    });
  }

  template &lt;fixed_string V&gt;
  auto &amp;operator[](row&lt;V&gt;) {
    return []&lt;class T&gt;(row&lt;V, T&gt; &amp;self) -&gt; T &amp; { return self.value; }(*this);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xv681zY3r">https://godbolt.org/z/xv681zY3r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class TData, class... TRows&gt;
concept HasRows = []&lt;class... TMembers&gt;(std::tuple&lt;TMembers...&gt;) {
    return (... and [](std::string_view name) {
        return (... or (name == meta::get_name_v&lt;TMembers&gt;));
    }(TRows::name));
}
(meta::unpack_sequence_t&lt;std::tuple, meta::get_data_members_t&lt;reflexpr(TData)&gt;&gt;{});

template &lt;class... TRows&gt;
struct rows : TRows... {
    template &lt;HasRows&lt;TRows...&gt; TData&gt;
    rows(const TData&amp; data) {
        for_each(get_data_members(mirror(TData)), [&amp;](auto member) {
            constexpr std::string_view name = get_name(member);
            (..., [&amp;] {
                if constexpr (name == TRows::name) {
                    static_cast&lt;TRows&amp;&gt;(*this).value = data.*get_pointer(member);
                }
            }());
        });
    };

    template &lt;fixed_string Name&gt;
    constexpr auto&amp; operator[](row&lt;Name&gt;) {
        return []&lt;class TValue&gt;(row&lt;Name, TValue&gt; &amp; self) -&gt; auto&amp; { return self.value; }
        (*this);
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1fbh4z3bf">https://godbolt.org/z/1fbh4z3bf</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>256 - Did you know that static reflection proposal for C++2X has mirror/value based interface?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/256.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/256.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that static reflection proposal for C++2X has mirror/value based interface?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt; auto to_string() {
  const auto t = get_aliased(mirror(T));
  std::stringstream str{};
  str &lt;&lt; get_name(t) &lt;&lt; '{';
  for_each(get_enumerators(t),
    [&amp;str](auto o) { str &lt;&lt; get_name(o) &lt;&lt; '=' &lt;&lt; get_constant(o) &lt;&lt; ';'; }
  );
  str &lt;&lt; '}';
  return str.str();
}

enum Weekdays {
  Mon = 2,
  Tue = 3,
  Wed = 4,
  Thu = 5,
  Fri = 6,
  Sat = 1,
  Sun = 0
};

int main() {
  std::cout &lt;&lt; to_string&lt;Weekdays&gt;(); // prints Weekdays{Mon=2;Tue=3;Wed=4;Thu=5;Fri=6;Sat=1;Sun=0;}
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hvz6W6szW">https://godbolt.org/z/hvz6W6szW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_string</code> function which returns string representation for given type: <code>type_name{field_type:field_name=value,...}</code> by applying mirror/value based interface?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
auto to_string(const T&amp; t); // TODO

struct empty {};

struct foo {
  int i;
  double d;
};

struct bar {
  foo f;
  bool b;
};

int main() {
  using namespace boost::ut;
  using std::literals::string_literals::operator&quot;&quot;s;

  &quot;mirror to_string&quot;_test = [] {
    expect(&quot;empty{}&quot;s == to_string(empty{}));
    expect(&quot;foo{int:i=1,double:d=0.2}&quot;s == to_string(foo{.i = 1, .d = .2}));
    expect(&quot;foo{int:i=0,double:d=4.2}&quot;s == to_string(foo{.i = {}, .d = 4.2}));
    expect(&quot;bar{foo{int:i=2,double:d=0.2},bool:b=1}&quot;s == to_string(bar{.f = {.i = 2, .d = .2}, .b = true}));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aMh5zh51s">https://godbolt.org/z/aMh5zh51s</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
auto to_string(const T&amp; t) {
  const auto ty = get_aliased(mirror(T));
  std::stringstream str{};
  str &lt;&lt; get_name(ty) &lt;&lt; '{';
  bool first = true;
  for_each(get_data_members(ty),
    [&amp;](auto m) {
      if (not first) {
        str &lt;&lt; ',';
      } else {
        first = false;
      }
      const auto&amp; val = get_value(m, t);
      if constexpr (std::is_class_v&lt;std::remove_cvref_t&lt;decltype(val)&gt;&gt;) {
        str &lt;&lt; to_string(val);
      } else {
        str &lt;&lt; get_name(get_type(m)) &lt;&lt; ':' &lt;&lt; get_name(m) &lt;&lt; '=' &lt;&lt; val;
      }
    });
  str &lt;&lt; '}';
  return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vjn5K94sa">https://godbolt.org/z/vjn5K94sa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
[[nodiscard]] auto to_string(const T&amp; object) -&gt; std::string {
    const auto mirrored_type = get_aliased(mirror(T));
    std::stringstream member_stream{};
    for_each(get_data_members(mirrored_type), [&amp;](const auto member) -&gt; void {
        const auto value = get_value(member, object);
        using value_t = std::remove_cvref_t&lt;decltype(value)&gt;;
        if constexpr (std::is_class_v&lt;value_t&gt;) {  // Why doesn't
                                                   // is_class(member) work?
            member_stream &lt;&lt; to_string(value);
        } else {
            member_stream &lt;&lt; get_name(get_type(member)) &lt;&lt; ':'
                          &lt;&lt; get_name(member) &lt;&lt; '=' &lt;&lt; value;
        }
        member_stream &lt;&lt; ',';
    });
    auto member_string = member_stream.str();
    if (std::size(member_string) &gt; 0) {
        member_string.pop_back();
    }

    return std::string{get_name(mirrored_type)} + '{' + member_string + '}';
}
</code></pre>

<blockquote>
<p><a href="https://jonathan.godbolt.org/z/qGx1cGEGs">https://jonathan.godbolt.org/z/qGx1cGEGs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename S&gt;
auto to_string(const S&amp; x) {
  std::stringstream str{};
  str &lt;&lt; get_name(get_aliased(mirror(S)));
  str &lt;&lt; '{';
  bool first = true;
  for_each(get_data_members(get_aliased(mirror(S))),
    [&amp;](auto mo) {
        if constexpr(std::is_class_v&lt;std::remove_cvref_t&lt;decltype(get_value(mo,x))&gt;&gt;)
            str &lt;&lt; to_string(get_value(mo,x)) &lt;&lt; &quot;,&quot;;
        else {
            if (first) first = false;
            else str &lt;&lt; &quot;,&quot;;
            str &lt;&lt; get_name(get_type(mo)) &lt;&lt; &quot;:&quot; &lt;&lt; get_name(mo) &lt;&lt; &quot;=&quot; &lt;&lt; get_value(mo, x);
        }
    });
  str &lt;&lt; '}';
  return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4qaxnWo4K">https://godbolt.org/z/4qaxnWo4K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
auto to_string(const T&amp; t) {
    const auto t_mirror = get_aliased(mirror(T));
    std::stringstream str{};
    str &lt;&lt; get_name(t_mirror) &lt;&lt; &quot;{&quot;;
    std::string sep = &quot;&quot;;
    for_each(get_data_members(t_mirror),
            [&amp;] (auto member) {
                auto value = t.*get_pointer(member);
                if constexpr (requires {str &lt;&lt; value;}) {
                    str &lt;&lt; sep &lt;&lt; get_name(get_type(member)) &lt;&lt; &quot;:&quot; &lt;&lt; get_name(member)
                        &lt;&lt; &quot;=&quot; &lt;&lt; value;
                } else {
                    str &lt;&lt; to_string(value);
                }
                sep = &quot;,&quot;;
             });

    str &lt;&lt; &quot;}&quot;;
    return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bs6hhWfKd">https://godbolt.org/z/bs6hhWfKd</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>255 - Did you know that static reflection proposal for C++2X can reflect functions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/255.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/255.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that static reflection proposal for C++2X can reflect functions?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
    auto api(int i) -&gt; void;
};

auto main() -&gt; int {
    namespace meta = std::experimental::reflect;
    std::cout &lt;&lt; meta::get_size_v&lt;meta::get_member_functions_t&lt;reflexpr(foo)&gt;&gt;; // prints 1
    std::cout &lt;&lt; meta::get_name_v&lt;meta::get_element_t&lt;0, meta::get_member_functions_t&lt;reflexpr(foo)&gt;&gt;&gt;; // prints api
    std::cout &lt;&lt; meta::get_name_v&lt;meta::get_element_t&lt;0, meta::get_parameters_t&lt;meta::get_element_t&lt;0, meta::get_member_functions_t&lt;reflexpr(foo)&gt;&gt;&gt;&gt;&gt;; // prints i
}
</code></pre>

<blockquote>
<p><a href="https://compiler-explorer.com/z/ofe3Kfaas">https://compiler-explorer.com/z/ofe3Kfaas</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement to_string which reflects member functions for given type?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct empty {};

struct foo {
    auto api(int i);
    auto api(int i, double d);
};

template&lt;class T&gt; auto to_string(); // TODO

int main() {
  using namespace boost::ut;
  using std::literals::string_literals::operator&quot;&quot;s;

  &quot;reflexpr funtions&quot;_test = [] {
    expect(&quot;empty{}&quot;s == to_string&lt;empty&gt;());
    expect(&quot;foo{api(int i);api(int i, double d);}&quot;s == to_string&lt;foo&gt;());
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xx5ohz7bs">https://godbolt.org/z/xx5ohz7bs</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class...&gt;
struct stringify_parameters;

template &lt;class PList, auto... Is&gt;
struct stringify_parameters&lt;PList, std::index_sequence&lt;Is...&gt;&gt; {
  auto operator()() const {
    const auto type_and_name = [] &lt;class P&gt; {
      return std::string{meta::get_name_v&lt;meta::get_type_t&lt;P&gt;&gt;} + ' ' + meta::get_name_v&lt;P&gt; + &quot;, &quot;;
    };
    std::string s{(&quot;&quot; + ... + type_and_name.template operator()&lt;meta::get_element_t&lt;Is, PList&gt;&gt;())};
    if constexpr (sizeof...(Is) &gt; 0) {
      s.pop_back();
      s.pop_back();
    }
    return s;
  }
};

template &lt;class... Ts&gt;
struct stringify_member_funcs {
  auto operator()() const {
    const auto member_func = [] &lt;class T&gt; {
      using Ps = meta::get_parameters_t&lt;T&gt;;
      // why doesn't unpack_sequence_t work on Ps?
      return std::string{meta::get_name_v&lt;T&gt;} + '('
        + stringify_parameters&lt;Ps, std::make_index_sequence&lt;meta::get_size_v&lt;Ps&gt;&gt;&gt;{}()
        + &quot;);&quot;;
    };
    return (&quot;&quot; + ... + member_func.template operator()&lt;Ts&gt;());
  }
};

template &lt;class T&gt; auto to_string() {
    using type = meta::get_aliased_t&lt;reflexpr(T)&gt;;
    using member_functions_t = meta::get_member_functions_t&lt;type&gt;;
    return std::string{meta::get_name_v&lt;type&gt;} + '{'
      + meta::unpack_sequence_t&lt;stringify_member_funcs, member_functions_t&gt;{}() + '}';
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zYj8fdYxb">https://godbolt.org/z/zYj8fdYxb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T_&gt; auto to_string() {
    namespace meta = std::experimental::reflect;
    using T = meta::get_aliased_t&lt;reflexpr(T_)&gt;;
    std::stringstream str{};
    str &lt;&lt; meta::get_name_v&lt;T&gt; &lt;&lt; '{';
    [&amp;]&lt;class... Ts&gt;(std::tuple&lt;Ts...&gt;) {
        const auto f = [&amp;]&lt;class T&gt; {
          str &lt;&lt; std::experimental::reflect::get_name_v&lt;T&gt; &lt;&lt; '(';
          [&amp;]&lt;class TParams, auto... Ns&gt;(TParams, std::index_sequence&lt;Ns...&gt;) {
              ((str &lt;&lt; meta::get_name_v&lt;meta::get_type_t&lt;meta::get_element_t&lt;Ns, TParams&gt;&gt;&gt; &lt;&lt; ' ' &lt;&lt; meta::get_name_v&lt;meta::get_element_t&lt;Ns, TParams&gt;&gt; &lt;&lt; &quot;, &quot;), ...);
              str.seekp(-2, std::ios_base::end);
          }(meta::get_parameters_t&lt;T&gt;{}, std::make_index_sequence&lt;meta::get_size_v&lt;meta::get_parameters_t&lt;T&gt;&gt;&gt;{});
          str &lt;&lt; &quot;);&quot;;
        };
        (f.template operator()&lt;Ts&gt;(), ...);
    }(meta::unpack_sequence_t&lt;std::tuple, meta::get_member_functions_t&lt;T&gt;&gt;{});
    str &lt;&lt; '}';
    return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dvzxf4n7n">https://godbolt.org/z/dvzxf4n7n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;meta::Object T&gt;
[[nodiscard]] auto get_name() -&gt; std::string {
    return meta::get_name_v&lt;T&gt;;
}

template &lt;meta::Typed T&gt;
[[nodiscard]] auto get_type() -&gt; std::string {
    return meta::get_name_v&lt;meta::get_type_t&lt;T&gt;&gt;;
}

template &lt;meta::FunctionParameter T&gt;
[[nodiscard]] auto get_parameter_representation() -&gt; std::string {
    return get_type&lt;T&gt;() + ' ' + get_name&lt;T&gt;();
}

template &lt;meta::Function T&gt;
[[nodiscard]] auto get_parameter_representations() -&gt; std::vector&lt;std::string&gt; {
    // BUG: unpack_sequence_t doesn't work. If it did, this could be unified
    // with get_member_representations()
    using parameter_list_t = meta::get_parameters_t&lt;T&gt;;
    return
        []&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;)-&gt;std::vector&lt;std::string&gt; {
        return {get_parameter_representation&lt;
            meta::get_element_t&lt;Is, parameter_list_t&gt;&gt;()...};
    }
    (std::make_index_sequence&lt;meta::get_size_v&lt;parameter_list_t&gt;&gt;{});
}

template &lt;meta::Function T&gt;
[[nodiscard]] auto get_function_representation() -&gt; std::string {
    return get_name&lt;T&gt;() + '(' +
           boost::algorithm::join(get_parameter_representations&lt;T&gt;(), &quot;, &quot;) +
           ')';
}

template &lt;meta::Class T&gt;
[[nodiscard]] auto get_member_representations() -&gt; std::vector&lt;std::string&gt; {
    using sequence_t = meta::unpack_sequence_t&lt;boost::mp11::mp_list,
                                               meta::get_member_functions_t&lt;T&gt;&gt;;
    return []&lt;typename... Ts&gt;(boost::mp11::mp_list&lt;Ts...&gt;)
        -&gt;std::vector&lt;std::string&gt; {
        return {get_function_representation&lt;Ts&gt;()...};
    }
    (sequence_t{});  // TODO: avoid instantiation?
}

template &lt;meta::Class T&gt;
[[nodiscard]] auto get_object_representation() -&gt; std::string {
    const auto members = get_member_representations&lt;T&gt;();
    return get_name&lt;T&gt;() + '{' +
           std::accumulate(std::cbegin(members), std::cend(members),
                           std::string{},
                           [](auto acc, const auto&amp; elem) {
                               acc += elem + ';';
                               return acc;
                           }) +
           '}';
}

}  // namespace detail

template &lt;class T&gt;
auto to_string() {
    return detail::get_object_representation&lt;
        meta::get_aliased_t&lt;reflexpr(T)&gt;&gt;();
}
</code></pre>

<blockquote>
<p><a href="https://jonathan.godbolt.org/z/hbo5ncGM5">https://jonathan.godbolt.org/z/hbo5ncGM5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TParams&gt;
auto parameters_to_string() {
    return []&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
        const auto stringify = []&lt;typename TParam&gt; {
            return std::format(&quot;{} {}, &quot;,
                meta::get_name_v&lt;meta::get_type_t&lt;TParam&gt;&gt;,
                meta::get_name_v&lt;TParam&gt;);
        };

        auto s = std::string{(&quot;&quot; + ... + stringify.template operator()&lt;meta::get_element_t&lt;Is, TParams&gt;&gt;())};
        if constexpr (sizeof...(Is) &gt; 0) {
            s.erase(std::prev(std::cend(s), 2), std::cend(s));
        }
        return s;
    }(std::make_index_sequence&lt;meta::get_size_v&lt;TParams&gt;&gt;{});
};

template&lt;typename... TFuncs&gt;
struct member_functions_to_string {
    auto operator()() const {
        const auto stringify = []&lt;typename TFunc&gt; {
            return std::format(&quot;{}({});&quot;,
                meta::get_name_v&lt;TFunc&gt;,
                parameters_to_string&lt;meta::get_parameters_t&lt;TFunc&gt;&gt;());
        };
        return (&quot;&quot; + ... + stringify.template operator()&lt;TFuncs&gt;());
    }
};

template &lt;typename T&gt;
auto class_name() {
    using type = meta::get_aliased_t&lt;reflexpr(T)&gt;;
    using member_functions_t = meta::get_member_functions_t&lt;type&gt;;
    return std::format(&quot;{}{{{}}}&quot;,
        meta::get_name_v&lt;type&gt;,
        meta::unpack_sequence_t&lt;member_functions_to_string, member_functions_t&gt;{}());
}

template&lt;class T&gt; auto to_string() {
    return class_name&lt;T&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3hMTK7b8W">https://godbolt.org/z/3hMTK7b8W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
decltype(auto) unpack(auto &amp;&amp;initial, auto f) {
  return [&amp;]&lt;class... Ts&gt;(std::tuple&lt;Ts...&gt;)-&gt;decltype(auto) {
    return (initial + ... + f.template operator()&lt;Ts&gt;());
  }
  (meta::unpack_sequence_t&lt;std::tuple, T&gt;{});
}

template &lt;class T, template &lt;class&gt; class pack_t&gt;
std::string format_name_and_sequence(const auto &amp;fmt, const auto &amp;f) {
  return std::format(fmt, meta::get_name_v&lt;T&gt;, unpack&lt;pack_t&lt;T&gt;&gt;(&quot;&quot;, f));
}

template &lt;class T&gt;
auto to_string() {
  const auto parameter = [front = true]&lt;class TParameter&gt; mutable {
    return std::format(&quot;{}{} {}&quot;, front ? (front = false, &quot;&quot;) : &quot;, &quot;,
                       meta::get_name_v&lt;meta::get_type_t&lt;TParameter&gt;&gt;,
                       meta::get_name_v&lt;TParameter&gt;);
  };
  const auto member_function = [=]&lt;class TMemberFunction&gt; {
    return format_name_and_sequence&lt;TMemberFunction, meta::get_parameters_t&gt;(
        &quot;{}({});&quot;, parameter);
  };
  using class_t = meta::get_aliased_t&lt;reflexpr(T)&gt;;
  return format_name_and_sequence&lt;class_t, meta::get_member_functions_t&gt;(
      &quot;{}{{{}}}&quot;, member_function);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q6KcWGaK3">https://godbolt.org/z/q6KcWGaK3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class Param&gt; auto param_to_string() {
    return std::string{meta::get_name_v&lt;meta::get_type_t&lt;Param&gt;&gt;} + &quot; &quot; + meta::get_name_v&lt;Param&gt;;
}

template&lt;class Params&gt; auto params_to_string() {
    return []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;){
        return (((I == 0 ? &quot;&quot; : &quot;, &quot;) + param_to_string&lt;meta::get_element_t&lt;I,Params&gt;&gt;()) + ... + &quot;&quot;);
    }(std::make_index_sequence&lt;meta::get_size_v&lt;Params&gt;&gt;{});
}

template&lt;class MemFn&gt; auto memfn_to_string() {
    return std::string{meta::get_name_v&lt;MemFn&gt;} + &quot;(&quot; + params_to_string&lt;meta::get_parameters_t&lt;MemFn&gt;&gt;() + &quot;);&quot;;
}

template&lt;class MemFns&gt; auto memfns_to_string() {
    return []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;) {
        return (memfn_to_string&lt;meta::get_element_t&lt;I, MemFns&gt;&gt;() + ... + &quot;&quot;);
    }(std::make_index_sequence&lt;meta::get_size_v&lt;MemFns&gt;&gt;{});
}

template&lt;class T&gt; auto to_string() {
    using Aliased = meta::get_aliased_t&lt;reflexpr(T)&gt;;
    return std::string{meta::get_name_v&lt;Aliased&gt;} + &quot;{&quot; + memfns_to_string&lt;meta::get_member_functions_t&lt;Aliased&gt;&gt;() + &quot;}&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MjMsT5hqf">https://godbolt.org/z/MjMsT5hqf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class ...Ts&gt;
struct FunArgString {
     auto operator()() {
      std::string str = ( std::string{meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt;} + std::string{&quot; &quot;} + std::string{meta::get_name_v&lt;Ts&gt;} +&quot;, &quot; + ... + std::string{});
      if(str.size() &gt; 0)
        str = str.substr(0,str.size()-2);
      return str;
    }
};

template&lt;class ...T&gt;
struct MemFunString {
    auto operator()(char sep) {
        auto wrap = []&lt;typename P&gt;(P) { return &quot;(&quot; + meta::unpack_sequence_t&lt;FunArgString, meta::get_parameters_t&lt;P&gt;&gt;{}() +&quot;)&quot;;   };
        std::string str = ( (std::string{meta::get_name_v&lt;T&gt;}+ wrap(T{}) + std::string{sep}) + ...  +std::string{});
        return str;
    }
};

template&lt;class T&gt; auto to_string() {
    using meta_T = meta::get_aliased_t&lt;reflexpr(T)&gt;;
    using meta_T_funcs = meta::get_member_functions_t&lt;meta_T&gt;;
    std::string ret = meta::get_name_v&lt;meta_T&gt;;
    ret += &quot;{&quot;;
    ret += meta::unpack_sequence_t&lt;MemFunString, meta::get_member_functions_t&lt;meta_T&gt;&gt;{}(';');
    ret += &quot;}&quot;;
    return ret;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7ox8eWda9">https://godbolt.org/z/7ox8eWda9</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>254 - Did you know about static reflection proposal for C++2X?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/254.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/254.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about static reflection proposal for C++2X?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P0385">https://wg21.link/P0385</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct print_enum {
  void operator()() {
    ((std::cout &lt;&lt; meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt; &lt;&lt; ':' &lt;&lt; meta::get_name_v&lt;Ts&gt; &lt;&lt; std::endl), ...);
  }
};

enum class Trading { Quant, Lab };

int main() {
  std::cout &lt;&lt; meta::get_name_v&lt;reflexpr(Trading)&gt;        &lt;&lt; std::endl  // prints Trading
            &lt;&lt; meta::get_name_v&lt;reflexpr(Trading::Quant)&gt; &lt;&lt; std::endl  // prints Quant
            &lt;&lt; meta::get_name_v&lt;reflexpr(Trading::Lab)&gt;   &lt;&lt; std::endl; // prints Lab

  meta::unpack_sequence_t&lt;print_enum, meta::get_enumerators_t&lt;reflexpr(Trading)&gt;&gt;{}(); // prints Trading::Quant, Trading::Lab
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x55GPdTxE">https://godbolt.org/z/x55GPdTxE</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_string</code> function which returns string representation for given type: <code>type_name{field_type:field_name,...}</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto to_string(); // TODO

struct empty {};

struct foo {
  int i;
  double d;
};

struct bar {
  foo f;
};

int main() {
  using namespace boost::ut;
  using std::literals::string_literals::operator&quot;&quot;s;

  &quot;reflexpr to_string&quot;_test = [] {
    expect(&quot;empty{}&quot;s == to_string&lt;reflexpr(empty)&gt;());
    expect(&quot;foo{int:i,double:d}&quot;s == to_string&lt;reflexpr(foo)&gt;());
    expect(&quot;bar{foo:f}&quot;s == to_string&lt;reflexpr(bar)&gt;());
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vK9ME7nWc">https://godbolt.org/z/vK9ME7nWc</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct stringify_members {
  auto operator()() const {
    const auto type_and_name = [] &lt;class T&gt; {
      return std::string{meta::get_name_v&lt;meta::get_type_t&lt;T&gt;&gt;} + ':' + meta::get_name_v&lt;T&gt;;
    };
    std::string s{(&quot;&quot; + ... + (type_and_name.template operator()&lt;Ts&gt;() + ','))};
    if constexpr (sizeof...(Ts) &gt; 0) {
      s.pop_back();
    }
    return s;
  }
};

template &lt;class T&gt; auto to_string() {
    return std::string{meta::get_name_v&lt;T&gt;} + '{'
      + meta::unpack_sequence_t&lt;stringify_members, meta::get_data_members_t&lt;T&gt;&gt;{}() + '}';
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4xE5M3Ye1">https://godbolt.org/z/4xE5M3Ye1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct type_name {
  auto operator()(std::stringstream&amp; str) {
    auto comma = sizeof...(Ts) &gt; 1;
    ((str &lt;&lt; meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt; &lt;&lt; ':' &lt;&lt; meta::get_name_v&lt;Ts&gt; &lt;&lt; (comma ? &quot;,&quot; : &quot;&quot;), comma = false), ...);
  }
};

template&lt;class T&gt;
auto to_string() {
  std::stringstream str{};
  str &lt;&lt; meta::get_display_name_v&lt;T&gt; &lt;&lt; '{';
  meta::unpack_sequence_t&lt;type_name, meta::get_data_members_t&lt;T&gt;&gt;{}(str);
  str  &lt;&lt; '}';
  return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xc8nevqha">https://godbolt.org/z/xc8nevqha</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct type_name {
  auto operator()(std::stringstream&amp; str) {
    auto comma = sizeof...(Ts) &gt; 1;
    ((str &lt;&lt; meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt; &lt;&lt; ':' &lt;&lt; meta::get_name_v&lt;Ts&gt; &lt;&lt; (comma ? &quot;,&quot; : &quot;&quot;), comma = false), ...);
  }
};

template&lt;class T&gt;
auto to_string() {
  std::stringstream str{};
  str &lt;&lt; meta::get_display_name_v&lt;meta::get_aliased_t&lt;reflexpr(T)&gt;&gt; &lt;&lt; '{';
  meta::unpack_sequence_t&lt;type_name, meta::get_data_members_t&lt;reflexpr(T)&gt;&gt;{}(str);
  str  &lt;&lt; '}';
  return str.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7Y5f77zza">https://godbolt.org/z/7Y5f77zza</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct memString
{
  auto operator()() {
      std::string str = ( std::string{meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt;} + std::string{&quot;:&quot;} + std::string{meta::get_name_v&lt;Ts&gt;} +&quot;,&quot; + ... + std::string{});
      if(str.size() &gt; 0)
        str = str.substr(0,str.size()-1);
      return str;
    }
};
template&lt;class T&gt; auto to_string() {
    std::string res = std::experimental::reflect::get_name_v&lt;T&gt;;
    res += &quot;{&quot;;
    res += meta::unpack_sequence_t&lt;memString, meta::get_data_members_t&lt;T&gt;&gt;{}();
    res += &quot;}&quot;;
    return res;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q9vErrzeb">https://godbolt.org/z/q9vErrzeb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename... TMembers&gt;
struct to_string_helper {
    auto operator()() const {
        const auto format_member = [] &lt;typename TMember&gt; {
            return std::format(&quot;{}:{},&quot;,
                meta::get_name_v&lt;meta::get_type_t&lt;TMember&gt;&gt;,
                meta::get_name_v&lt;TMember&gt;);
        };

        if constexpr (sizeof...(TMembers) &gt; 0) {
            auto s = std::string{(&quot;&quot; + ... + (format_member.template operator()&lt;TMembers&gt;()))};
            s.pop_back();
            return s;
        } else {
            return &quot;&quot;;
        }
    }
};

template&lt;typename T&gt;
[[nodiscard]] auto to_string() {
    return std::format(&quot;{}{{{}}}&quot;,
        meta::get_name_v&lt;T&gt;,
        meta::unpack_sequence_t&lt;to_string_helper, meta::get_data_members_t&lt;T&gt;&gt;{}());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1PGbeMq69">https://godbolt.org/z/1PGbeMq69</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Expr&gt;
struct expr {
    template &lt;class... Ts&gt;
    struct fn {
        auto operator()() { return Expr.template operator()&lt;Ts...&gt;(); }
    };
};

template &lt;class T&gt;
auto to_string() {
    return std::string{std::experimental::reflect::get_name_v&lt;T&gt;} + '{' +
        meta::unpack_sequence_t&lt;
           expr&lt;[]&lt;class... Ts&gt; {
             auto str = ((std::string{meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt;} + ':' + meta::get_name_v&lt;Ts&gt; + ',') + ... + std::string{});
             str.pop_back();
             return str;
           }&gt;::template fn, meta::get_data_members_t &lt; T &gt;&gt; {}() + '}';
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3sdvq69s1">https://godbolt.org/z/3sdvq69s1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt; auto to_string() {
  return []&lt;class... Ts&gt;(boost::mp11::mp_list&lt;Ts...&gt;) {
    using std::literals::operator&quot;&quot;s;
    return meta::get_name_v&lt;T&gt; + &quot;{&quot;s +
           boost::algorithm::join(std::vector&lt;std::string&gt;{(
                                      meta::get_name_v&lt;meta::get_type_t&lt;Ts&gt;&gt; +
                                      &quot;:&quot;s + meta::get_name_v&lt;Ts&gt;)...},
                                  &quot;,&quot;) +
           &quot;}&quot;;
  }
  (meta::unpack_sequence_t&lt;boost::mp11::mp_list,
                           meta::get_data_members_t&lt;T&gt;&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xf74M918h">https://godbolt.org/z/xf74M918h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename MO, std::size_t I&gt;
void
field_to_string(std::ostream&amp; out) {
    using meta_F = meta::get_element_t&lt;I, MO&gt;;
    if(I &gt; 0) out &lt;&lt; &quot;,&quot;;
    out &lt;&lt; meta::get_name_v&lt;meta::get_type_t&lt;meta_F&gt;&gt; &lt;&lt; &quot;:&quot; &lt;&lt; meta::get_name_v&lt;meta_F&gt;;
}

template &lt;typename MO, std::size_t ... I&gt;
void
fields_to_string(std::ostream&amp; out, std::index_sequence&lt;I...&gt;) {
    out &lt;&lt; &quot;{&quot;;
    (field_to_string&lt;MO, I&gt;(out), ... );
    out &lt;&lt; &quot;}&quot;;
}

template&lt;class T&gt; auto to_string() {
    std::stringstream s{};
    s &lt;&lt; meta::get_name_v&lt;T&gt;;

    using meta_DMs = meta::get_data_members_t&lt;T&gt;;
    fields_to_string&lt;meta_DMs&gt;(
        s,
        std::make_index_sequence&lt;
            meta::get_size_v&lt;meta_DMs&gt;
        &gt;()
    );

    return s.str();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f4x48noxY">https://godbolt.org/z/f4x48noxY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename T&gt;
[[nodiscard]] auto get_type_name() -&gt; std::string {
    return meta::get_name_v&lt;meta::get_type_t&lt;T&gt;&gt;;
}

template &lt;typename T&gt;
[[nodiscard]] auto get_name() -&gt; std::string {
    return meta::get_name_v&lt;T&gt;;
}

template &lt;typename T&gt;
[[nodiscard]] auto get_member_representation() -&gt; std::string {
    return get_type_name&lt;T&gt;() + ':' + get_name&lt;T&gt;();
}

template &lt;typename... Ts&gt;
struct get_data_members_impl {
    [[nodiscard]] auto operator()() -&gt; std::vector&lt;std::string&gt; {
        return {get_member_representation&lt;Ts&gt;()...};
    }
};

template &lt;typename T&gt;
[[nodiscard]] auto get_data_members() -&gt; std::vector&lt;std::string&gt; {
    return meta::unpack_sequence_t&lt;get_data_members_impl,
                                   meta::get_data_members_t&lt;T&gt;&gt;{}();
}
}  // namespace detail

template &lt;class T&gt;
[[nodiscard]] auto to_string() {
    return detail::get_name&lt;T&gt;() + '{' +
           boost::algorithm::join(detail::get_data_members&lt;T&gt;(), &quot;,&quot;) + '}';
}
</code></pre>

<blockquote>
<p><a href="https://jonathan.godbolt.org/z/57xdeWKss">https://jonathan.godbolt.org/z/57xdeWKss</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>253 - Did you know that C++20 extends support for data time utilities?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/253.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/253.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 extends support for data time utilities?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/#time">https://eel.is/c++draft/#time</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto thanksgiving = November / 25 / 2021y;

static_assert(year(2021) == thanksgiving.year());
static_assert(month(11)  == thanksgiving.month());
static_assert(day(25)    == thanksgiving.day());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eda4d35xT">https://godbolt.org/z/eda4d35xT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you apply std::chrono data time utilities to verify Thanksgiving dates</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto thanksgiving = November / 25 / 2021y;
constexpr auto cpptipday    = 21d / 11 / 2021;

static_assert(                        /*is thanksgivng a valid date?*/);
static_assert(Thursday ==             /*what day is thanksgiving?*/);
static_assert(days(4) ==              /*how many days to thanksgivnig from cpptipday?*/);
static_assert(25d / November/ 2022 == /*when will be thankgiving next year?*/);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6h755jqPE">https://godbolt.org/z/6h755jqPE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(thanksgiving.ok() /*is thanksgiving a valid date?*/);
static_assert(Thursday == weekday{sys_days{thanksgiving}} /*what day is thanksgiving?*/);
static_assert(days(4) == sys_days{thanksgiving} - sys_days{cpptipday} /*how many days to thanksgiving from cpptipday?*/);
static_assert(24d / November/ 2022 == sys_days{Thursday[4] / November / 2022} /*when will be thanksgiving next year?*/);
</code></pre>

<blockquote>
<p><a href="https://jonathan.godbolt.org/z/G6T4zEKn1">https://jonathan.godbolt.org/z/G6T4zEKn1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(thanksgiving.ok());
static_assert(Thursday == weekday{sys_days(thanksgiving)});
static_assert(days(4) == thanksgiving.day() - cpptipday.day());
static_assert(25d / November/ 2022 == thanksgiving + years(1));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e37KPxGbv">https://godbolt.org/z/e37KPxGbv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static_assert(thanksgiving.ok() /*is thanksgivng a valid date?*/);
static_assert(Thursday == weekday{thanksgiving}  /*what day is thanksgiving?*/);
static_assert(days(4) == thanksgiving.day() - cpptipday.day() /*how many days to thanksgiving from cpptipday?*/);
static_assert(24d / November/ 2022 == sys_days{2022y / November/ Thursday[4]} /*when will be thankgiving next year?*/);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qKcE4x373">https://godbolt.org/z/qKcE4x373</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>252 - **Did you know that C++23 added basic_string::resize_and_overwrite**?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/252.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/252.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added basic_string::resize_and_overwrite</strong>?</p>
</li>
<li>
<p><a href="https://wg21.link/P1072">https://wg21.link/P1072</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">std::string resize_and_overwrite(const std::string&amp; str, std::size_t size) {
   std::string ret;
   const auto step = std::size(str);
   ret.resize_and_overwrite(step * size, [&amp;](auto* buf, auto n) {
       for (auto i = 0u; i &lt; size; i++) {
         std::memcpy(buf + i * step, std::data(str), step);
       }
       return step * size;
   });

   return ret;
}

int main(){
  std::cout &lt;&lt; resize_and_overwrite(&quot;quantlab&quot;, 4); // prints quantlabquantlabquantlabquantlab
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GEnM8jdeh">https://godbolt.org/z/GEnM8jdeh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>change</code> function which applies <code>resize_and_overwrite</code> string's routine to satisfy tests</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto change(...) -&gt; void ; // TODO

int main() {
  using namespace boost::ut;

  &quot;resize and overwrite&quot;_test = [] {
    should(&quot;not change empty string&quot;) = [] {
     std::string s;
     auto data = std::data(s);

     change(s);

     expect(std::empty(s) &gt;&gt; fatal);
     expect(s[0] == 0_c);
     expect(std::data(s) == data);
    };

    should(&quot;change trading to quantlab&quot;) = [] {
      std::string s = &quot;trading&quot;;

      change(s);

      expect(s == &quot;quantlab&quot;);
      expect((std::size(s) == 8_u) &gt;&gt; fatal);
      expect(s.capacity() &gt;= 100_i);
      expect(s[8] == 0_c);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jvaTKPvc5">https://godbolt.org/z/jvaTKPvc5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">auto change(std::string&amp; s) -&gt; void {
  if (std::empty(s)) { return; }
  s.resize_and_overwrite(100, [](char* buf, std::size_t n) -&gt; std::size_t {
    constexpr std::string_view ql{&quot;quantlab&quot;};
    auto end_ptr = std::copy(std::cbegin(ql), std::cend(ql), buf);
    *end_ptr = 0;
    return end_ptr - buf;
  });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hc6vhxqq9">https://godbolt.org/z/hc6vhxqq9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto change(std::string&amp; str) -&gt; void {
    if (std::empty(str)) {
        return;
    }

    str.resize_and_overwrite(100, [](char* data,
                                     [[maybe_unused]] std::size_t count) {
        std::ignore = std::copy(std::cbegin(configuration::desired_string),
                                std::cend(configuration::desired_string), data);
        return std::size(configuration::desired_string);
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7GEj7bd7r">https://godbolt.org/z/7GEj7bd7r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void change(std::string &amp;s) {
    if (std::empty(s)) return;
    s.resize_and_overwrite(100, [] (char *buf, size_t) {
        constexpr auto &amp;value = &quot;quantlab&quot;;
        constexpr auto size = sizeof(value) - 1;
        std::memcpy(buf, value, size);
        return size;
    });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z8YfYbs6c">https://godbolt.org/z/z8YfYbs6c</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void change(auto&amp; s){
  if(s == &quot;trading&quot;){
    s.resize_and_overwrite(100, [](char * c, std::size_t count){
      std::memcpy(c, &quot;quantlabaa&quot;, 10);
      return 8;
    });
  }
} ; // TODO
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7fx8Prd3T">https://godbolt.org/z/7fx8Prd3T</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto change(std::string&amp; s) -&gt; void
{
    if(not s.empty())
    {
        std::string q = &quot;quantlab&quot;;
        s.resize_and_overwrite(q.size()*14, [&amp;](auto* buf, auto n) {
            std::memcpy(buf, std::data(q), q.size());
            return q.size();
        });
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6eaoM84Tn">https://godbolt.org/z/6eaoM84Tn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto change = [](auto&amp; str) {
  if (std::empty(str)) {
    str.resize_and_overwrite(0, [](auto...) -&gt; std::size_t { return {}; });
  } else {
    str.resize_and_overwrite(100, [](auto* data, auto n) {
      constexpr std::string_view quantlab = &quot;quantlab&quot;;
      std::copy(std::cbegin(quantlab), std::cend(quantlab), data);
      return std::size(quantlab);
    });
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xEWTP1EeE">https://godbolt.org/z/xEWTP1EeE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>251 - Did you know that C++20 added `type_identity` which implements the identity metafunction?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/251.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/251.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added <code>type_identity</code> which implements the identity metafunction?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0887">http://wg21.link/p0887</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
void print1() {
  std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}

template &lt;class T&gt;
void print2() {
  std::cout &lt;&lt; typeid(std::type_identity&lt;T&gt;).name() &lt;&lt; std::endl;
}

int main() {
  print1&lt;int const&amp;&gt;();  // 'int'
  print2&lt;int const&amp;&gt;();  // 'type_identity&lt;int const &amp;&gt;'
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WWKh3673v">https://godbolt.org/z/WWKh3673v</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you add required changes to tests and implement <code>overload_args</code> function which returns sum of sizes of passed arguments?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt;
struct not_constructible {
  not_constructible() = delete;
};

constexpr auto overload_args_sum(...); // TODO

static_assert(0u == overload_args_sum(not_constructible{}/*TODO*/));
static_assert(sizeof(int) == overload_args_sum(not_constructible&lt;int&gt;{}/*TODO*/));
static_assert(sizeof(int) + sizeof(float) == overload_args_sum(not_constructible&lt;int, float&gt;{}/*TODO*/));
static_assert(sizeof(int) + sizeof(float) + sizeof(char) == overload_args_sum(not_constructible&lt;int, float, char&gt;{}/*TODO*/));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8Y1qPrKMj">https://godbolt.org/z/8Y1qPrKMj</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;typename ...&gt; class whatever, typename ... Ts&gt;
constexpr auto overload_args_sum(whatever&lt;not_constructible&lt;Ts ...&gt;&gt;){
  return (sizeof(Ts) + ... + 0);
}

static_assert(0u == overload_args_sum(std::type_identity&lt;not_constructible&lt;&gt;&gt;{}));
static_assert(sizeof(int) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int&gt;&gt;{}));
static_assert(sizeof(int) + sizeof(float) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int, float&gt;&gt;{}));
static_assert(sizeof(int) + sizeof(float) + sizeof(char) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int, float, char&gt;&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WWExM6Pfo">https://godbolt.org/z/WWExM6Pfo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
constexpr auto overload_args_sum(std::type_identity&lt;not_constructible&lt;Ts...&gt;&gt;) -&gt; std::size_t {
    return (0 + ... + sizeof(Ts));
}

static_assert(0u == overload_args_sum(std::type_identity&lt;not_constructible&lt;&gt;&gt;{}));
static_assert(sizeof(int) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int&gt;&gt;{}));
static_assert(sizeof(int) + sizeof(float) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int, float&gt;&gt;{}));
static_assert(sizeof(int) + sizeof(float) + sizeof(char) == overload_args_sum(std::type_identity&lt;not_constructible&lt;int, float, char&gt;&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wjnnh3n1b">https://godbolt.org/z/Wjnnh3n1b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
using type_list_t = std::type_identity&lt;not_constructible&lt;Ts...&gt;&gt;;

template &lt;class... Ts&gt;
[[nodiscard]] constexpr auto overload_args_sum(
    const type_list_t&lt;Ts...&gt;) noexcept {
    return (0 + ... + sizeof(Ts));
}

static_assert(0u ==
              overload_args_sum(std::type_identity&lt;not_constructible&lt;&gt;&gt;{}));
static_assert(sizeof(int) ==
              overload_args_sum(std::type_identity&lt;not_constructible&lt;int&gt;&gt;{}));
static_assert(
    sizeof(int) + sizeof(float) ==
    overload_args_sum(std::type_identity&lt;not_constructible&lt;int, float&gt;&gt;{}));
static_assert(sizeof(int) + sizeof(float) + sizeof(char) ==
              overload_args_sum(
                  std::type_identity&lt;not_constructible&lt;int, float, char&gt;&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sdhrEqKf6">https://godbolt.org/z/sdhrEqKf6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;typename ... Args&gt; class C, typename ... Args&gt;
constexpr auto overload_args_sum(C&lt;Args...&gt;* c) { return (sizeof(Args)+...+0);  }

static_assert(0u == overload_args_sum((not_constructible&lt;&gt;*)(nullptr) ));
static_assert(sizeof(int) == overload_args_sum((not_constructible&lt;int&gt;*)(nullptr) ));
static_assert(sizeof(int) + sizeof(float) == overload_args_sum((not_constructible&lt;int, float&gt;*)(nullptr)));
static_assert(sizeof(int) + sizeof(float) + sizeof(char) == overload_args_sum((not_constructible&lt;int, float, char&gt;*)(nullptr)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oqaMf7fxa">https://godbolt.org/z/oqaMf7fxa</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>250 - Did you know about methods to access the last element of variadic pack...?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/250.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/250.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li><strong>Did you know about methods to access the last element of variadic pack...?</strong></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class, std::size_t&gt; concept Any = true;

constexpr auto last1 = [](auto... args) {
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](Any&lt;Ns&gt; auto..., auto last) {
      return last;
    }(args...);
  }
  (std::make_index_sequence&lt;sizeof...(args) - 1&gt;{});
};

auto last2 = [](auto... args) {
  return (args, ...);
};

static_assert(1 == last1(1));
static_assert(2 == last1(1, 2));
static_assert(3 == last1(1, 2, 3));

static_assert(1 == last2(1));
static_assert(2 == last2(1, 2));
static_assert(3 == last2(1, 2, 3));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/599K9eah8">https://godbolt.org/z/599K9eah8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement nth_element which returns Nth element of variadic pack...?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_element; // TODO

static_assert(1 == nth_element&lt;0&gt;(1));
static_assert(1 == nth_element&lt;0&gt;(1, 2));
static_assert(2 == nth_element&lt;1&gt;(1, 2));
static_assert(1 == nth_element&lt;0&gt;(1, 2, 3));
static_assert(2 == nth_element&lt;1&gt;(1, 2, 3));
static_assert(3 == nth_element&lt;2&gt;(1, 2, 3));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1aPcePYPE">https://godbolt.org/z/1aPcePYPE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_element = [](auto...args){
    return std::get&lt;N&gt;(std::tuple{args...});
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vqKfzevbK">https://godbolt.org/z/vqKfzevbK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename, std::size_t&gt; concept prefix = true;

template &lt;auto N&gt;
constexpr auto nth_element(auto... args) {
  return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
    return [] (prefix&lt;Is&gt; auto..., auto arg, auto...) {
      return arg;
    }(args...);
  }(std::make_index_sequence&lt;N&gt;());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WPhe5MerW">https://godbolt.org/z/WPhe5MerW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t N&gt; struct any { T value{}; };

template&lt;std::size_t N, class T&gt;
constexpr decltype(auto) get(any&lt;T, N&gt;&amp; t) { return t.value; }

template&lt;auto N&gt;
constexpr auto nth_element = [](auto... args) {
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    struct : any&lt;decltype(args), Ns&gt;... { } _{args...};
    return get&lt;N&gt;(_);
  }
  (std::make_index_sequence&lt;sizeof...(args)&gt;{});
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aEM31WE8b">https://godbolt.org/z/aEM31WE8b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_element = [](auto... args) {
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](decltype((void*)Ns)..., auto* nth, auto*...) {
      return *nth;
    }(&amp;args...);
  }
  (std::make_index_sequence&lt;N&gt;{});
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a8vsqM848">https://godbolt.org/z/a8vsqM848</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t N&gt; struct any { T value{}; };

template&lt;auto N&gt;
constexpr auto nth_element = [](auto... args) {
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    struct : any&lt;decltype(args), Ns&gt;... { } _{args...};
    return static_cast&lt;__type_pack_element&lt;N, any&lt;decltype(args), Ns&gt;...&gt;&amp;&gt;(_).value;
  }
  (std::make_index_sequence&lt;sizeof...(args)&gt;{});
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GMGnWfvnE">https://godbolt.org/z/GMGnWfvnE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_element = [](auto arg, auto... args)
  requires (std::is_same_v&lt;decltype(arg), decltype(args)&gt; and ...) {
  return std::array{arg, args...}[N];
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1G7Gj16nx">https://godbolt.org/z/1G7Gj16nx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, auto I = 0&gt;
constexpr auto nth_element(auto arg, auto... args) {
    if constexpr (I == N) {
        return arg;
    } else if constexpr (sizeof...(args) &gt; 0u) {
        return nth_element&lt;N, I + 1&gt;(args...);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vGh1nTnaq">https://godbolt.org/z/vGh1nTnaq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, std::size_t N&gt; struct any { T value{}; };

template&lt;auto N&gt;
constexpr auto nth_element = [](auto... args) {
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    struct : any&lt;decltype(args), Ns&gt;... { } _{args...};
    return static_cast&lt;boost::mp11::mp_at_c&lt;boost::mp11::mp_inherit&lt;any&lt;decltype(args), Ns&gt;...&gt;, N&gt;&amp;&gt;(_).value;
  }
  (std::make_index_sequence&lt;sizeof...(args)&gt;{});
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rKjzPf9zK">https://godbolt.org/z/rKjzPf9zK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class, std::size_t&gt; concept Any = true;

template&lt;auto N&gt;
constexpr auto nth_element(auto... pack) {
    return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
        return [](Any&lt;Is&gt; auto..., auto arg, auto...) {
            return arg;
        }(pack...);
    }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bao1dsY5q">https://godbolt.org/z/bao1dsY5q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class, std::size_t&gt; concept Any = true;
template&lt;auto N&gt;
constexpr auto nth_element( auto ...  args )
{
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](Any&lt;Ns&gt; auto ..., auto nth, auto ... ) {
      return nth;
    }(args...);
  }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/78b1qd3cE">https://godbolt.org/z/78b1qd3cE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

#define NTH_ARG(Z, N, TYPE) TYPE arg##N,
#define NTH_ELEMENT(Z, N, TYPE)                                                \
  template &lt;auto I&gt;                                                            \
  requires(I == N) constexpr decltype(auto) nth_element(                       \
      BOOST_PP_REPEAT(BOOST_PP_INC(N), NTH_ARG, TYPE) TYPE...) {               \
    return arg##N;                                                             \
  }

BOOST_PP_REPEAT(BOOST_PP_DEC(BOOST_PP_LIMIT_REPEAT), NTH_ELEMENT, auto &amp;&amp;)

#undef NTH_ELEMENT
#undef NTH_ARG

} // namespace detail

template &lt;auto N&gt; constexpr decltype(auto) nth_element(auto &amp;&amp;...args) {
  return detail::nth_element&lt;N&gt;(args...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ervdav89b">https://godbolt.org/z/ervdav89b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class, std::size_t&gt;
concept Any = true;

template &lt;auto N&gt; constexpr decltype(auto) nth_element(auto &amp;&amp;...args) {
  return [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) -&gt; decltype(auto) {
    return [](Any&lt;Is&gt; auto &amp;&amp;..., auto &amp;&amp;arg, auto &amp;&amp;...) -&gt; decltype(auto) {
      return arg;
    }(args...);
  }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/515fP7WbW">https://godbolt.org/z/515fP7WbW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;std::size_t N&gt;
requires (N == 0)
constexpr auto nth_element(auto&amp;&amp; arg0, auto&amp;&amp;...) {
    return arg0;
}

template &lt;std::size_t N&gt;
requires (N &gt; 0) constexpr auto nth_element(auto&amp;&amp; arg0, auto&amp;&amp;... rest) {
    return nth_element&lt;N-1&gt;(std::forward&lt;decltype(rest)&gt;(rest)...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5WqMc5bjo">https://godbolt.org/z/5WqMc5bjo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto nth_element = [](auto... args) {
    static_assert(N &lt; sizeof...(args));
    return std::array{args...}[N];
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vGnM4GnE4">https://godbolt.org/z/vGnM4GnE4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr decltype(auto) nth_element(auto &amp;&amp;... args) {
    using namespace boost::mp11;
    return [&amp;] &lt;class... Ts&gt; (mp_list&lt;Ts...&gt;) -&gt; decltype(auto) {
        return [] (Ts &amp;&amp;..., auto &amp;&amp;arg, auto &amp;&amp;...) -&gt; decltype(auto) {
            return arg;
        }(std::forward&lt;decltype(args)&gt;(args)...);
    }(mp_take_c&lt;mp_list&lt;decltype(args)...&gt;, N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zEM1eGqxK">https://godbolt.org/z/zEM1eGqxK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;std::size_t&gt; struct  Any
{
    template&lt;typename T &gt; constexpr Any(T){}
};
template&lt;auto N&gt;
constexpr auto nth_element( auto ...  args )
{
  return [&amp;]&lt;std::size_t... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return [](Any&lt;Ns&gt; ..., auto nth, auto ... ) {
      return nth;
    }(args...);
  }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3471fcrqG">https://godbolt.org/z/3471fcrqG</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>249 - Did you know that C++23 allows extended init-statement with alias-declaration in the for loop?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/249.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/249.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 allows extended init-statement with alias-declaration in the for loop?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2360">http://wg21.link/p2360</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;initializer_list&gt;
#include &lt;iostream&gt;

int main() {
  for (using T = int; T e : {1, 2}) {
    std::cout &lt;&lt; e; // prints 1,2
  }

  for (struct T { int x; int y; }; T e : {T{1,2}, T{3,4}}) {
    std::cout &lt;&lt; &quot;{&quot; &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}'; // prints {1,2}{3,4}
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y3nvPafec">https://godbolt.org/z/Y3nvPafec</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement an init-statement for the for loop which will add an anonymous struct {x,y} and an alias declaration T to it?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (/*TODO*/ : {T{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}

int main() {
  using namespace boost::ut;

  &quot;print&quot;_test = [] {
    &quot;empty&quot;_test = [] {
      std::stringstream str{};
      print(str);
      expect(std::string_view{&quot;&quot;} == str.str());
    };

    &quot;single pair&quot;_test = [] {
      std::stringstream str{};
      print(str, std::pair{1,2});
      expect(std::string_view{&quot;{1,2}&quot;} == str.str());
    };

    &quot;multiple pairs&quot;_test = [] {
      std::stringstream str{};
      print(str, std::pair{1,3}, std::pair{2, 4});
      expect(std::string_view{&quot;{1,3}{2,4}&quot;} == str.str());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zjWGhnGnf">https://godbolt.org/z/zjWGhnGnf</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (using T = struct { int x; int y; }; const T&amp; e : std::initializer_list&lt;T&gt;{T{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xzd398z3n">https://godbolt.org/z/xzd398z3n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os) -&gt; std::ostream&amp; { return os; }
auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (using T = struct { int x; int y; }; const T&amp; e : {T{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cehWYKz5a">https://godbolt.org/z/cehWYKz5a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (using T = struct {int x; int y;}; const T &amp; e : std::vector&lt;T&gt;{T{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3WaPGeG5b">https://godbolt.org/z/3WaPGeG5b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (struct T { int x; int y; }; const auto &amp;e : std::initializer_list&lt;T&gt;{{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YdYsfTW1a">https://godbolt.org/z/YdYsfTW1a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    if constexpr (sizeof...(args) &gt; 0) {
        for (using T = struct { int x; int y; }; auto const&amp; e : {T{args.first, args.second}...}) {
        os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
        }
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n9reaY7hE">https://godbolt.org/z/n9reaY7hE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto print(std::ostream&amp; os, auto... args) -&gt; std::ostream&amp; {
    for (using T = struct { int x; int y;}; T const &amp; e : std::array&lt;T, sizeof ...( args)&gt;{T{args.first, args.second}...}) {
      os &lt;&lt; '{' &lt;&lt; e.x &lt;&lt; ',' &lt;&lt; e.y &lt;&lt; '}';
    }
    return os;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aKT6ocr6c">https://godbolt.org/z/aKT6ocr6c</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>248 - Did you know that CRTP can be implemented with C++23 `Deducing this`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/248.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/248.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that CRTP can be implemented with C++23 <code>Deducing this</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0847">http://wg21.link/p0847</a></p>
</li>
<li><a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
struct interface {
    auto get() const {
        return static_cast&lt;const T*&gt;(this)-&gt;get_impl();
    }
};

struct impl1 : interface&lt;impl1&gt; {
    auto get_impl() const { return 1; }
};

struct impl2 : interface&lt;impl2&gt; {
    auto get_impl() const { return 2; }
};

template&lt;class T&gt;
auto get(const interface&lt;T&gt;&amp; b) {
  return b.get();
}

int main() {
    return get(impl1{}) + get(impl2{}); // returns 3
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/7s7xWxj5T">https://circle.godbolt.org/z/7s7xWxj5T</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement the CRTP example with <code>Deducing this</code> instead?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct interface;             // TODO
template&lt;auto N&gt; struct impl; // TODO
auto get(...);                // TODO

static_assert(0 == get(impl&lt;0&gt;{}));
static_assert(1 == get(impl&lt;1&gt;{}));
static_assert(3 == get(impl&lt;1&gt;{}) + get(impl&lt;2&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/e8P9oj9rW">https://circle.godbolt.org/z/e8P9oj9rW</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct interface {
  auto get(this const auto&amp; impl) {
    return impl.get_impl();
  }
};

template&lt;auto N&gt; struct impl : interface {
  auto get_impl() const { return N; }
};

auto get(const /*std::derived_from&lt;interface&gt;*/ auto&amp; iface) {
  return iface.get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/ro5576xW4">https://circle.godbolt.org/z/ro5576xW4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class interface {
public:
    template&lt;typename T&gt;
    [[nodiscard]] constexpr auto get(this const T&amp;) {
        return T::get_impl();
    }
};

template&lt;auto N&gt;
class impl : interface {
private:
    [[nodiscard]] static constexpr auto get_impl() {
        return N;
    }
};

[[nodiscard]] constexpr auto get(const auto &amp;object) {
    return object.get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/rraT8d55r">https://circle.godbolt.org/z/rraT8d55r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface {
  auto get(this const auto&amp; impl) requires requires { impl.get_impl(); } {
    return impl.get_impl();
  }
};

template&lt;class T&gt; concept Interface = requires (T t) { t.get(); };

template&lt;auto N&gt; struct impl : interface {
  auto get_impl() const { return N; }
};

auto get(const Interface auto&amp; i) {
  return i.get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/5PjsW7Tvx">https://circle.godbolt.org/z/5PjsW7Tvx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface {
    constexpr auto get(this const auto&amp; self) {
        return decltype(self)::value;
    }
};

template&lt;auto N&gt; struct impl : interface {
    static constexpr auto value = N;
};

auto get(const auto&amp; i) {
    return i.get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/M1xK6dxEG">https://circle.godbolt.org/z/M1xK6dxEG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface
{
    template &lt;typename Self&gt;
    auto get(this Self &amp;&amp; self)
    {
        return std::forward&lt;Self&gt;(self).get_impl();
    }
};

template&lt;auto N&gt;
struct impl : interface
{
    auto get_impl() const
    {
        return N;
    }
};

template &lt;typename T&gt;
auto get(T &amp;&amp; val) {
    return std::forward&lt;T&gt;(val).get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/asMxKE738">https://circle.godbolt.org/z/asMxKE738</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface{
    auto get( this auto &amp;&amp;  self )
    {
        return self();
    }
};

template&lt;auto N&gt; struct impl:public interface {
    auto operator()()
    {
        return N;
    }
};

auto get(auto &amp;&amp; f){
    return f.get();
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/a5xec5KfK">https://circle.godbolt.org/z/a5xec5KfK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface {
    auto get(this auto const &amp;self) {
        return self.get_impl();
    }
};

template&lt;auto N&gt; struct impl : interface {
    auto get_impl() const { return N; }
};

auto get(const auto &amp;self) { return self.get(); }
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/c7jejfKex">https://circle.godbolt.org/z/c7jejfKex</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct interface {
    auto get(this auto const &amp;self) {
        return self.get_impl();
    }
};

template&lt;auto N&gt; struct impl : interface {
    auto get_impl() const { return N; }
};

auto get(const auto &amp;self) { return self.get(); }
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/c7jejfKex">https://circle.godbolt.org/z/c7jejfKex</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>247 - Did you know that `Deducing this` proposal has been voted out into C++23?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/247.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/247.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>Deducing this</code> proposal has been voted out into C++23?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0847">http://wg21.link/p0847</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  auto bar(bool b) { return b; }

  // deducing this
  auto baz(this foo const &amp; self, bool b) { return not b; }
};

static_assert(foo{}.bar(true));
static_assert(not foo{}.baz(true));

static_assert(not foo{}.bar(false));
static_assert(foo{}.baz(false));
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/TMc63G5Tf">https://circle.godbolt.org/z/TMc63G5Tf</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement sum which adds args... by using a recursive lambda with deduced this?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](...); // TODO

static_assert(0 == sum());
static_assert(1 == sum(1));
static_assert(3 == sum(1, 2));
static_assert(6 == sum(1, 2, 3));
static_assert(6 == sum(2, 3, 1));
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/j8a7oc8nT">https://circle.godbolt.org/z/j8a7oc8nT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this const auto&amp; self, auto... args) {
  if constexpr (sizeof...(args) == 0) {
    return 0;
  } else {
    return [&amp;](auto arg, auto... args) { return arg + self(args...); }(args...);
  }
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/Gf7PdP64G">https://circle.godbolt.org/z/Gf7PdP64G</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this auto self, auto ... args)
{
    auto peelArg = [&amp;](auto arg, auto ...args) {
        return arg + self(args...);
    };

    if constexpr (sizeof...(args) == 0)
        return 0;
    else
        return peelArg(args...);
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/vnrTEnGcr">https://circle.godbolt.org/z/vnrTEnGcr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this const auto&amp; self, const auto&amp;... args) {
    if constexpr(sizeof...(args) == 0) {
        return 0;
    } else {
        return [self](const auto&amp; first_arg, const auto&amp;... remaining_args) {
            return first_arg + self(remaining_args...);
        }(args...);
    }
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/7cz5WbTd3">https://circle.godbolt.org/z/7cz5WbTd3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this auto &amp; self, auto ... Is ){
    if constexpr ( (sizeof ...( Is) ) == 0 )
        return 0;
    else
        return [&amp;]( auto I , auto ... Iss ) { return I + self.operator()( Iss ... ) ; }( Is...);
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/7d8acTPWE">https://circle.godbolt.org/z/7d8acTPWE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [] (this const auto &amp;self, auto... args) {
    if constexpr (sizeof...(args) &gt;= 1) {
        return [=] (auto first, auto... rest) {
            return first + self(rest...);
        }(args...);
    }

    return 0;
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/c4Pjb51cc">https://circle.godbolt.org/z/c4Pjb51cc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this const auto&amp; self, auto... args) {
    if constexpr (sizeof...(args) &gt; 0) {
        return [self](const auto head, const auto... tail) {
            return head + self(tail...);
        }(args...);
    }
    return 0;
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/PzzEKs14q">https://circle.godbolt.org/z/PzzEKs14q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum = [](this auto const &amp;self, auto ...args){
    if constexpr ( sizeof...(args) == 0 ){
        return 0;
    } else {
        return [=](const auto arg, auto ... rest_of_args){
            return arg + self(rest_of_args...);
        }(args...);
    }
};
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/zas389zWT">https://circle.godbolt.org/z/zas389zWT</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>246 - Did you know that C++11 added a numeric literal operator template?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/246.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/246.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p>Did you know that C++11 added a numeric literal operator template?</p>
</li>
<li>
<p><a href="http://eel.is/c++draft/over.literal">http://eel.is/c++draft/over.literal</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto operator&quot;&quot;_i(int) -&gt; int;                     // error: invalid literal operator parameter type 'int', did you mean 'unsigned long long'?
// numeric literal operator template
template &lt;char... Cs&gt; constexpr auto operator&quot;&quot;_i()  -&gt; int; // ok
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Tj1MEdd17">https://godbolt.org/z/Tj1MEdd17</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a numeric literal operator template <code>_c</code> which returns a proper type depending on the given value?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c(); // TODO

static_assert(0 == 0_c);
static_assert(42 == 42_c);
static_assert(1234 == 1234_c);
static_assert(9223372036854775807l == 9223372036854775807_c);
static_assert(18446744073709551615ull == 18446744073709551615_c);
static_assert(std::is_same_v&lt;decltype(0_c), int&gt;);
static_assert(std::is_same_v&lt;decltype(1000000000_c), int&gt;);
static_assert(std::is_same_v&lt;decltype(01000000000_c), int&gt;);
static_assert(std::is_same_v&lt;decltype(00000000001000000000_c), int&gt;);
static_assert(std::is_same_v&lt;decltype(2147483647_c), int&gt;);
static_assert(std::is_same_v&lt;decltype(2147483648_c), long&gt;);
static_assert(std::is_same_v&lt;decltype(9999999999_c), long&gt;);
static_assert(std::is_same_v&lt;decltype(1000000000000000000_c), long&gt;);
static_assert(std::is_same_v&lt;decltype(01000000000000000000_c), long&gt;);
static_assert(std::is_same_v&lt;decltype(9223372036854775807_c), long&gt;);
static_assert(std::is_same_v&lt;decltype(9223372036854775808_c), unsigned long long&gt;);
static_assert(std::is_same_v&lt;decltype(9999999999999999999_c), unsigned long long&gt;);
static_assert(std::is_same_v&lt;decltype(10000000000000000000_c), unsigned long long&gt;);
static_assert(std::is_same_v&lt;decltype(18446744073709551615_c), unsigned long long&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d5P81rjjE">https://godbolt.org/z/d5P81rjjE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] consteval auto operator&quot;&quot;_c() {
  constexpr auto value = [] {
    constexpr char chars[]{Cs...};
    unsigned long long i = 0;
    for (auto c : chars) {
      i *= 10;
      i += c - '0';
    }
    return i;
  }();

  if constexpr (value &lt;= std::numeric_limits&lt;int&gt;::max()) {
    return static_cast&lt;int&gt;(value);
  } else if constexpr (value &lt;= std::numeric_limits&lt;long&gt;::max()) {
    return static_cast&lt;long&gt;(value);
  } else {
    return value;
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jfY741or5">https://godbolt.org/z/jfY741or5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_ull(const auto &amp;str) {
    return std::accumulate(
        std::cbegin(str), std::cend(str), 0ull, [](const auto n, const auto c) {
        return n * 10 + c - '0';
    });
}

template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c() {
    constexpr auto n = to_ull(std::array{Cs...});
    if constexpr (n &lt;= std::numeric_limits&lt;int&gt;::max()) {
        return static_cast&lt;int&gt;(n);
    } else if constexpr (n &lt;= std::numeric_limits&lt;long&gt;::max()) {
        return static_cast&lt;long&gt;(n);
    } else {
        return n;
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x57rPa9dE">https://godbolt.org/z/x57rPa9dE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c() {
    using ull = unsigned long long;
    constexpr std::array&lt;int, sizeof...(Cs)&gt; digits = {Cs-'0'...};
    constexpr ull num = std::accumulate(digits.begin(), digits.end(), 0ull,
        [](ull sum, int digit) { return 10*sum + digit;});
    if constexpr (num &lt;= std::numeric_limits&lt;int&gt;::max())
        return static_cast&lt;int&gt;(num);
    else if constexpr (num &lt;= std::numeric_limits&lt;long&gt;::max())
        return static_cast&lt;long&gt;(num);
    else
        return static_cast&lt;ull&gt; (num);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sKWP7arMr">https://godbolt.org/z/sKWP7arMr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr int char_to_digit(char x){
  return x-'0';
};

template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c() {
    constexpr std::array chars{Cs...};

    constexpr auto value = std::accumulate(std::begin(chars), std::end(chars), 0ull, [=](auto agg, auto c){
        const auto base = chars[0] == '0' ? 8 : 10;
        return agg * base + char_to_digit(c);
    });

    if constexpr( value &lt;= std::numeric_limits&lt;int&gt;::max()){
        return int(value);
    }
    else if constexpr( value &lt;= std::numeric_limits&lt;long&gt;::max()){
        return long(value);
    }
    else
    {
        return value;
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/b3vbYM9nz">https://godbolt.org/z/b3vbYM9nz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char ... Cs&gt;
struct parse_integer{
  static constexpr std::array&lt;unsigned long long, sizeof...(Cs)&gt; chars = {Cs ...};
  static constexpr unsigned long long N = std::accumulate(begin(chars), end(chars), 0ULL,
    [](unsigned long long accum, char x){ return 10*accum + x-'0';});

  static constexpr auto u = [](auto f, auto ... xs){ return f(f, xs ...); };

  template&lt;typename ... Ts&gt; struct types{};

  static constexpr auto value =
    u([]&lt;typename T, typename ... Ts&gt;(auto recur, types&lt;T, Ts ...&gt;){
      if constexpr(N &lt;= std::numeric_limits&lt;T&gt;::max()){
        return T(N);
      } else {
        return recur(recur, types&lt;Ts...&gt;{});
      }
    },
    types&lt;int, long, long long, unsigned long long&gt;{});

};

template &lt;char C, char... Cs&gt;
constexpr auto operator&quot;&quot;_c(){
  return parse_integer&lt;C, Cs ...&gt;::value;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WvPs6z3cx">https://godbolt.org/z/WvPs6z3cx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c() noexcept {
    constexpr auto base = [] (auto digit, char specifier = '0', auto...) {
        if (sizeof...(Cs) == 1 || digit != '0') return 10;
        switch (specifier) {
            default:
                return 8;
            case 'B':
            case 'b':
                return 2;
            case 'X':
            case 'x':
                return 16;
        }
    }(Cs...);
    constexpr auto non_digits = [] (auto digit, char specifier = '0', auto...) {
        if (sizeof...(Cs) == 1 || digit != '0') return 0;
        switch (specifier) {
            default:
                return 1;
            case 'B':
            case 'X':
            case 'b':
            case 'x':
                return 2;
        }
    }(Cs...);
    constexpr auto value = [] (auto acc, auto non_digits) {
        const auto digit = [&amp;] (auto c) {
            if (--non_digits &gt;= 0)    return 0;
            if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') return c - 'A' + 0xA;
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') return c - 'a' + 0xa;
                                      return c - '0';
        };
        return (..., (acc *= base, acc += digit(Cs)));
    }(0ull, non_digits);

    if constexpr (value &lt;= std::numeric_limits&lt;int&gt;::max()) {
        return static_cast&lt;int&gt;(value);
    } else if constexpr (value &lt;= std::numeric_limits&lt;long&gt;::max()) {
        return static_cast&lt;long&gt;(value);
    } else if constexpr (value &lt;= std::numeric_limits&lt;long long&gt;::max()) {
        return static_cast&lt;long long&gt;(value);
    } else {
        return value;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dMGrsjEeq">https://godbolt.org/z/dMGrsjEeq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr unsigned long long pow10(std::size_t to) {
    return to == 0 ? 1 : pow10(to/2) * pow10(to/2) * (to % 2 == 0 ? 1 : 10);
}

template &lt;char... Cs, std::size_t ...Ix&gt;
constexpr auto calculate(std::index_sequence&lt;Ix...&gt;) {
    enum Type { MAKE_SIGNED = -1, Value = (((Cs - '0') * pow10(sizeof...(Ix) - 1 - Ix)) + ...) };
    using U = std::underlying_type_t&lt;Type&gt;;
    if constexpr (sizeof(U) &gt; 8 || Value &lt; 0)
        return (unsigned long long)Value;
    else 
        return (U)Value;
}

template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_c() {
    return calculate&lt;Cs...&gt;(std::make_index_sequence&lt;sizeof...(Cs)&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xG9rEhEbf">https://godbolt.org/z/xG9rEhEbf</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>245 - Did you know about C++2X proposal to add Multidimensional subscript operator?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/245.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/245.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++2X proposal to add Multidimensional subscript operator?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2128">http://wg21.link/p2128</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, auto Dimensions&gt; class mdarray2 {
public:
  template &lt;class I1, class I2&gt; constexpr T &amp;operator[](I1 i1, I2 i2) {
    return vs_[i1][i2];
  }

private:
  std::array&lt;std::array&lt;T, 2&gt;, Dimensions&gt; vs_{};
};

int main() {
  mdarray2&lt;int, 2&gt; a{};
  a[1, 1] = 42;
  assert(0 == (a[0, 0]));
  assert(42 == (a[1, 1]));
}
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/j9zh7YMz5">https://gcc.godbolt.org/z/j9zh7YMz5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a generic multidimensional array with multidimensional subscript operator?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray; // TODO

int main() {
  using namespace boost::ut;

  &quot;mdarray&quot;_test = [] {
      &quot;support multiple dimenions&quot;_test = [] {
        mdarray&lt;int, 2&gt; a{2, 2};
        a[1, 1] = 42;
        expect(42_i == a[1, 1]);
      };

      &quot;support multiple dimenions with different sizes&quot;_test = [] {
        mdarray&lt;int, 3&gt; a{1, 3, 2};
        a[0, 1, 1] = 42;
        a[0, 2, 0] = 84;

        expect(0_i == a[0,0,0]);
        expect(0_i == a[0,2,1]);

        expect(42_i == a[0,1,1]);
        expect(84_i == a[0,2,0]);
      };
  };
}
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/TP7reYK3b">https://gcc.godbolt.org/z/TP7reYK3b</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray {
public:
    template&lt;typename ... D&gt;
    mdarray(D ... args) requires(sizeof...(D) ==N): dims{args...} {
        std::size_t storage = std::accumulate(dims.begin(), dims.end(), 1, std::multiplies&lt;int&gt;());
        vals.resize(storage);
    }

    template&lt;typename ...D&gt;
    T&amp; operator[](D... args) requires(sizeof...(D) == N) {
        std::array&lt;int, N&gt; idx{args...};
        std::size_t offset = idx[0];
        for(std::size_t d=1; d&lt;N; offset= offset*dims[d]+idx[d], d++);
        return vals[offset];
    }
private:
    std::array&lt;int, N&gt; dims;
    std::vector&lt;T&gt; vals;
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/Ka7oo4r36">https://gcc.godbolt.org/z/Ka7oo4r36</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray {
    std::array&lt;std::size_t, N&gt; dims_{};
    std::vector&lt;T&gt; data_{};

public:
    mdarray(const auto&amp;... dims)
        : dims_{static_cast&lt;std::size_t&gt;(dims)...}
        , data_((dims * ...))
    {}

    template &lt;class... Is&gt;
    requires (sizeof...(Is) == N)
    [[nodiscard]] constexpr T&amp; operator[](const Is&amp;... is) {
        const std::array indexes{static_cast&lt;std::size_t&gt;(is)...};

        const auto offset = ranges::accumulate(
            ranges::views::zip(dims_, indexes),
            std::size_t{0},
            [](const auto offset, const auto zipped) {
                const auto [dim, idx] = zipped;
                return offset * dim + idx;
            });

        return data_[offset];
    }
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/n5hxGoabP">https://gcc.godbolt.org/z/n5hxGoabP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray {
public:
  mdarray(const auto... es) requires (sizeof...(es) == N) {
    const auto extent = (1 * ... * es);
    storage.reset(new T[extent]);
    if constexpr (std::is_trivially_constructible_v&lt;T&gt;) {
      std::fill_n(storage.get(), extent, T{});
    }
    const auto a = std::array{es..., 1};
    std::inclusive_scan(std::crbegin(a), std::prev(std::crend(a)),
                        std::rbegin(extents),
                        std::multiplies{});
  }

  auto operator[](const auto... is) -&gt; T&amp; requires (sizeof...(is) == N) {
    const auto indices = std::array{is...};
    return storage[std::transform_reduce(std::cbegin(indices), std::cend(indices),
                                         std::cbegin(extents), 0)];
  }

private:
  std::array&lt;std::size_t, N&gt; extents{};
  std::unique_ptr&lt;T[]&gt; storage{};
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/6zhWvfcsP">https://gcc.godbolt.org/z/6zhWvfcsP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray: public std::vector&lt;T&gt;
{
    using Base = std::vector&lt;T&gt;;
    public:
    mdarray( auto ... ns ) requires (sizeof...( ns) == N  )
    : dim{ std::size_t( ns) ... }
    {
        assert( ( ( ns &gt;=0 ) &amp;&amp; ...) );
        Base::resize( (ns * ... * 1) );
        for ( int i = 1; i &lt;N ; ++i )
            dim[i] *= dim[i-1];
        for ( int i = N-1 ; i &gt;0; --i )
            dim[i] = dim[i-1];
        dim[0] = 1;
    }
    T &amp; operator [] (  auto ... ns  ) requires (sizeof...( ns) == N)
    {
        assert( ( ( ns &gt;=0 ) &amp;&amp; ...) );
        auto indexes = std::forward_as_tuple(ns...);
        auto index = [&amp;]&lt;typename TT, auto ... Is&gt;( std::integer_sequence&lt;TT, Is... &gt; const &amp; ) {
            return ((std::get&lt;Is&gt;(indexes) * dim[Is]) + ...);
        }( std::make_index_sequence&lt;N&gt;());
        return Base::operator[](index);
    }
    private:
    std::array&lt;std::size_t, N &gt; dim;
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/s8zqWsM31">https://gcc.godbolt.org/z/s8zqWsM31</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray {
public:
    template&lt;class ...Dim&gt;
    mdarray(Dim &amp;&amp; ...dim) requires (sizeof...(dim) == N) : data((dim * ...)) {}

    T &amp; operator[](auto &amp;&amp;...n) requires (sizeof...(n) == N) {
        auto inc = [i = 1] mutable { return i++; };
        return data[(((n * inc()) + ...))];
    }

private:
    std::vector&lt;T&gt; data;
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/6ha3Y9c47">https://gcc.godbolt.org/z/6ha3Y9c47</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray {
    std::array&lt;std::size_t, N&gt; dimensions;
    std::vector&lt;T&gt; values;

public:
    constexpr mdarray(std::convertible_to&lt;std::size_t&gt; auto... dimensions)
    requires (sizeof...(dimensions) == N) :
        dimensions{static_cast&lt;std::size_t&gt;(dimensions)...},
        values((1 * ... * dimensions)) {};

    constexpr auto &amp;operator[](std::convertible_to&lt;std::size_t&gt; auto... indices)
    requires (sizeof...(indices) == N) {
        return [=]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) -&gt; auto &amp; {
            return values[(0 + ... + [=]&lt;auto... Js&gt;(std::index_sequence&lt;Js...&gt;, auto index) {
                return index * (1 * ... * dimensions[Js]);
            }(std::make_index_sequence&lt;Is&gt;{}, indices))];
        }(std::make_index_sequence&lt;N&gt;{});
    }
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/YEqxbTPx5">https://gcc.godbolt.org/z/YEqxbTPx5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, std::size_t N&gt;
class mdarray{
    private:
        std::array&lt;int, N&gt; dims_;
        std::vector&lt;T&gt; data_;

        auto getSize(auto ... dims)
        {
            return (1 * ... * dims);
        }

        auto getIndex(auto ... locs)
        {
            std::array&lt;int, N&gt; locations{locs...};

            auto index = locations[0];
            for(int i =1; i &lt;N; ++i)
            {
                index += locations[i] * dims_[i-1];
            }
            return index;
        }

    public:
        mdarray(auto ... dims)
            : dims_{dims...},
              data_(getSize(dims...))
        {
        }

        T &amp;operator[](auto ... locs) {
            return data_[getIndex(locs...)];
        }
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/MMrdYeYsf">https://gcc.godbolt.org/z/MMrdYeYsf</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>244 - Did you know about compiler predefined macros assosicated with the compilation date/time?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/244.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/244.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about compiler predefined macros assosicated with the compilation date/time?</strong></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(std::string_view{&quot;07:36::22&quot;} == std::string_view{__TIME__}); // will only pass at certin time
static_assert(std::string_view{&quot;Sep 19 2021&quot;} == std::string_view{__DATE__}); // will only pass at certin date
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KWvxdhzd8">https://godbolt.org/z/KWvxdhzd8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement consteval function <code>year</code> which will use <strong>DATE</strong> macro to return current year as integer?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto year() -&gt; int; // TODO
static_assert(2021 == year());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ohqdon8zW">https://godbolt.org/z/ohqdon8zW</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto from_chars(const char* first, const char* last, int&amp; value) {
  value = 0;
  while (first != last) {
    value *= 10;
    value += *first++ - '0';
  }
}

[[nodiscard]] consteval auto year() -&gt; int {
  constexpr auto today = __DATE__;
  int year{};
  from_chars(&amp;today[7], &amp;today[11], year);
  return year;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zPv7Kbcj6">https://godbolt.org/z/zPv7Kbcj6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] consteval auto stoi(std::string_view str) {
  return [&amp;str]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return (((str[Ns] - '0') * std::pow(10, N - Ns - 1)) + ...);
  }(std::make_index_sequence&lt;N&gt;{});
}

[[nodiscard]] consteval auto year() -&gt; int {
  return stoi&lt;4&gt;(std::string_view{__DATE__}.substr(7));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jP3cs3vbz">https://godbolt.org/z/jP3cs3vbz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct integer
{
    static constexpr auto rule = lexy::dsl::integer&lt;int&gt;(lexy::dsl::digits&lt;&gt;);
    static constexpr auto value = lexy::forward&lt;int&gt;;
};


[[nodiscard]] consteval auto year() -&gt; int {
    constexpr auto date = std::string_view{__DATE__};

    constexpr auto input = lexy::string_input(date.substr(7));
    constexpr auto result = lexy::parse&lt;integer&gt;(input, lexy::noop);
    static_assert(result);

    return result.value();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G4MradvsM">https://godbolt.org/z/G4MradvsM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr int char_to_digit(char x){
  return x-'0';
};

consteval auto year_string() {
    const auto date = std::string_view{__DATE__};
    return date.substr(date.size() - 4);
};

constexpr int stringview_to_int(auto str, int index, int accum){
  return index == 4
    ? accum
    : stringview_to_int(str, index+1, accum*10 + char_to_digit(str[index]));
}

consteval auto year() {
  return stringview_to_int(year_string(), 0, 0 );
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mjs5ss9ro">https://godbolt.org/z/Mjs5ss9ro</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr int
ipow10(int b){ return b ? (10*ipow10(b-1)) : 1; }

constexpr int char_to_digit(char x){ return x-'0'; };

consteval auto year_string() {
    const auto date = std::string_view{__DATE__};
    return date.substr(date.size() - 4);
};

template&lt;auto ... indices&gt;
constexpr int
stringview_to_int(std::index_sequence&lt; indices ...&gt;, auto str){
  return ((char_to_digit(str[indices])*ipow10(3-indices)) + ...);
}

consteval auto year() {
  return stringview_to_int(std::make_index_sequence&lt;4&gt;(), year_string());
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G64ndYbee">https://godbolt.org/z/G64ndYbee</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto year() -&gt; int {
    int yr = 0;
    for(int i=7; i&lt;11; i++)
        yr = 10*yr + __DATE__[i] - '0';
    return yr;
}
</code></pre>

<blockquote>
<p><a href="http://godbolt.org/z/j3zc8bz79">http://godbolt.org/z/j3zc8bz79</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto year() -&gt; int
{
    auto dateStr = std::string_view{__DATE__};
    int y = 0;
    for ( int i = dateStr.size() - 1, j = 1; j &lt;= 1000 ; i--, j*=10)
        y += int(dateStr[i] - '0') * j ;
    return y;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8oEoTcnjq">https://godbolt.org/z/8oEoTcnjq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
consteval auto strparse( T arg) -&gt; int
{
    return (arg[0]- '0') *1000 + (arg[1] - '0') * 100 + (arg[2] - '0') * 10 + (arg[3] - '0');
}

[[nodiscard]] consteval auto year() -&gt; int
{
    constexpr auto date = std::string_view(__DATE__);
    constexpr auto year = std::string_view(date.data() + 7);
    return strparse(year);

}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ajWKa5dcG">https://godbolt.org/z/ajWKa5dcG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">[[nodiscard]] consteval auto year() -&gt; int {
    return [] (auto acc, auto size, auto... is) {
        return (..., (acc *= 10, acc += __DATE__[size - is] - '0'));
    }(0, sizeof __DATE__, 5, 4, 3, 2);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eWWvdd74n">https://godbolt.org/z/eWWvdd74n</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>243 - Did you know about C++2X `Pattern matching using is and as` proposal?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/243.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/243.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++2X <code>Pattern matching using is and as</code> proposal?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2392">http://wg21.link/p2392</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">void f(auto const&amp; x) {
  inspect (x) {
    i as int           =&gt; std::cout &lt;&lt; &quot;int &quot; &lt;&lt; i;
    [_,y] is [0,even]  =&gt; std::cout &lt;&lt; &quot;point on y-axis and even y &quot; &lt;&lt; y;
    [a,b] is [int,int] =&gt; std::cout &lt;&lt; &quot;2-int tuple &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b;
    s as std::string   =&gt; std::cout &lt;&lt; &quot;string \&quot;&quot; + s + &quot;\&quot;&quot;;
    is _               =&gt; std::cout &lt;&lt; &quot;((no matching value))&quot;;
  }
}

int main() {
  f(42);
  f(std::pair{0, 2});
  f(std::tuple{1, 2});
  f(&quot;str&quot;);
  struct {} foo;
  f(foo);
}
</code></pre>

<pre class="codehilite"><code class="language-sh">int 42
point on y-axis and even y 2
2-int tuple 1 2
istring &quot;str&quot;
((no matching value))
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/64E99s3qq">https://circle.godbolt.org/z/64E99s3qq</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>inspect</code> function which will applly a pattern matching proposal to output values/types into a given ostream?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os); // TODO

int main() {
  &quot;inspect&quot;_test = [] {
    &quot;empty&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{}, str);
      expect(&quot;(...)&quot;sv == str.str());
    };

    &quot;int, double&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{1, 2.}, str);
      expect(&quot;(1, 2)&quot;sv == str.str());
    };

    &quot;int, double, string&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{1, 2., &quot;str&quot;}, str);
      expect(&quot;(int, double, _)&quot;sv == str.str());
    };

    &quot;int, double, long&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{1, 2., 3l}, str);
      expect(&quot;(int, double, _)&quot;sv == str.str());
    };

    &quot;int, int, int&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{4, 2, 3}, str);
      expect(&quot;(int, ...)&quot;sv == str.str());
    };

    &quot;int&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{42}, str);
      expect(&quot;(int, ...)&quot;sv == str.str());
    };

    &quot;double&quot;_test = [] {
      std::stringstream str{};
      inspect(std::tuple{42.0}, str);
      expect(&quot;(...)&quot;sv == str.str());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/bf8M7461K">https://circle.godbolt.org/z/bf8M7461K</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os) {
  inspect(value) {
    [x, y] is [int, double] =&gt; os &lt;&lt; '(' &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; ')';
    is [int, double, _]     =&gt; os &lt;&lt; &quot;(int, double, _)&quot;;
    is [int, ...]           =&gt; os &lt;&lt; &quot;(int, ...)&quot;;
    is _                    =&gt; os &lt;&lt; &quot;(...)&quot;;
  }
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/ea8zMEres">https://circle.godbolt.org/z/ea8zMEres</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os) {
    inspect(value) {
        [a, b] as [int, double] =&gt; os &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot;;
        is [int, double, _] =&gt; os &lt;&lt; &quot;(int, double, _)&quot;;
        is [int, ...] =&gt; os &lt;&lt; &quot;(int, ...)&quot; ;
        is [...] =&gt; os &lt;&lt; &quot;(...)&quot;;
    }
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/qExzx3ddr">https://circle.godbolt.org/z/qExzx3ddr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os) {
    inspect(value) {
        [a, b] =&gt; os &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot;;
        is [int, double, _] =&gt; os &lt;&lt; &quot;(int, double, _)&quot;;
        is [int, ...] =&gt; os &lt;&lt; &quot;(int, ...)&quot;;
        _ =&gt; os &lt;&lt; &quot;(...)&quot;;
    }
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/x48qxdWo5">https://circle.godbolt.org/z/x48qxdWo5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os) {
    inspect (value) {
        is [1, 2.] =&gt; os &lt;&lt; &quot;(1, 2)&quot;;
        is [1, 2., _] =&gt; os &lt;&lt; &quot;(int, double, _)&quot;;
        is [int, ...] =&gt; os &lt;&lt; &quot;(int, ...)&quot;;
        is _ =&gt; os &lt;&lt; &quot;(...)&quot;;
    }
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/5Tqq3qahh">https://circle.godbolt.org/z/5Tqq3qahh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">void inspect(const auto&amp; value, std::ostream&amp; os) {
    inspect(value) {
        [a,b] is [int, double]       =&gt; os &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; ;
        [a,b,c] is [int, double, _]  =&gt; os &lt;&lt; &quot;(int, double, _)&quot;;
        [a,b,c] is [int, int, int]   =&gt; os &lt;&lt; &quot;(int, ...)&quot;;
        [i] is [int]                 =&gt; os &lt;&lt; &quot;(int, ...)&quot;;
        is _                         =&gt; os &lt;&lt; &quot;(...)&quot;;
    }
}
</code></pre>

<blockquote>
<p><a href="https://circle.godbolt.org/z/KG51jjTaE">https://circle.godbolt.org/z/KG51jjTaE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>242 - Did you know that ANSI/ISO C++ conforming programs must not rely on a maximum template depth greater than 17 (changed to 1024 in C++11)?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/242.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/242.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that ANSI/ISO C++ conforming programs must not rely on a maximum template depth greater than 17 (changed to 1024 in C++11)?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/temp.inst">http://eel.is/c++draft/temp.inst</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt; struct type { static constexpr auto id = N; };

template &lt;class T, class... Ts&gt; [[nodiscard]] constexpr auto get(auto&amp; t, const auto id) -&gt; void* {
  if (id == T::id) {
    return std::addressof(std::get&lt;T&gt;(t));
  } else if constexpr(sizeof...(Ts) &gt; 0) {
    return get&lt;Ts...&gt;(t, id);
  } else {
    return nullptr;
  }
}

int main (){
  std::tuple t{&quot;foo&quot;, type&lt;0&gt;{}, 42, type&lt;1&gt;{}, type&lt;99&gt;{}, type&lt;42&gt;{}};
  assert((get&lt;type&lt;0&gt;, type&lt;1&gt;&gt;(t, 0)));
  assert((get&lt;type&lt;0&gt;, type&lt;1&gt;&gt;(t, 1)));
  assert(not (get&lt;type&lt;0&gt;, type&lt;1&gt;&gt;(t, 42)));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/16f6qefrh">https://godbolt.org/z/16f6qefrh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement function <code>get</code> which returns a void pointer to an object from unique list of inherited types based on run-time id and avoids template depth recursion?</strong></p>
</li>
<li>
<p>Double points for the solution fastest to compile</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt; struct type { static constexpr auto id = N; };

template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr auto get(const auto id) -&gt; void *; // TODO
};

int main() {
  data d{
    type&lt;0&gt;{},
    type&lt;1&gt;{},
    type&lt;2&gt;{},
    type&lt;3&gt;{},
    ...
    type&lt;1025&gt;{}
  };

  assert(nullptr != d.get(0));
  assert(nullptr != d.get(1));
  assert(nullptr != d.get(2));
  assert(nullptr != d.get(3));

  ...

  assert(nullptr == d.get(1001));
  assert(nullptr != d.get(10010));

  ...

  assert(nullptr == d.get(1020));
  assert(nullptr != d.get(10200));
  ...
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5x9ndn9nY">https://godbolt.org/z/5x9ndn9nY</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr auto get(const auto id) -&gt; void * {
    void* p = nullptr;
    (... or (p = TArgs::id == id ? static_cast&lt;TArgs*&gt;(this) : nullptr));
    return p;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PcKzoKs64">https://godbolt.org/z/PcKzoKs64</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr auto get(const auto id) -&gt; void * {
    void* addressofs[]{static_cast&lt;void*&gt;(static_cast&lt;TArgs *&gt;(this))...};
    decltype(id) ids[]{TArgs::id...};
    const auto it = std::find(std::cbegin(ids), std::cend(ids), id);
    return it != std::cend(ids) ? addressofs [ std::size_t(std::distance(std::cbegin(ids), it)) ] : nullptr;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/68KoM6j97">https://godbolt.org/z/68KoM6j97</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr void * get(const int id) {
    constexpr int ids[]{ TArgs::id... };

    for (std::size_t i = 0; i &lt; sizeof...(TArgs); ++i) {
      if (ids[i] == id) return this;
    }

    return nullptr;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7T5qMn9fj">https://godbolt.org/z/7T5qMn9fj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {

  static constexpr int ids[]{ TArgs::id... };

  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr auto get(const auto id) -&gt; void * {
      auto it = std::find(std::begin(ids), std::end(ids), id );
      if(it == std::end(ids))
      {
          return nullptr;
      }
      return this;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/15YzGPG9b">https://godbolt.org/z/15YzGPG9b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  static constexpr int ids[] = { TArgs::id... };
  [[nodiscard]] constexpr auto get(const auto id) -&gt; void * {
      const auto it = std::ranges::find(ids, id);
      return it != std::cend(ids) ? this : nullptr;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5579683hs">https://godbolt.org/z/5579683hs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }

  [[nodiscard]] constexpr auto get(const auto id) -&gt; void * {
      int ids[] = {TArgs::id...};
      for(int i=0; i&lt;sizeof...(TArgs); i++)
        if( id == ids[i])
            return (void*)this;
      return nullptr;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4b1nzca3P">https://godbolt.org/z/4b1nzca3P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TArgs&gt;
struct data : TArgs... {
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }
  [[nodiscard]] constexpr auto get(const auto id) -&gt; void *
  {
      constexpr int N = sizeof ...(TArgs) ;
      int ids[N] = { TArgs::id... };
      void* ptrs[N] = { (dynamic_cast&lt;TArgs*&gt;(this)) ... };
      for( int i = 0; i &lt; N ; ++i )
        if( id == ids[i])
            return ptrs[i];
      return nullptr;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/16bnhre8K">https://godbolt.org/z/16bnhre8K</a></p>
</blockquote>
<p>```cpp<br />
template<class... TArgs><br />
struct data : TArgs... {<br />
  constexpr explicit(false) data(TArgs... args) : TArgs{args}... { }</p>
<p>[[nodiscard]] constexpr auto get(const auto id) -&gt; void * {<br />
    return (void*)((TArgs::id == id ? (std::size_t)static_cast<TArgs*>(this) : 0) + ...);<br />
  }<br />
};<br />
````</p>
<blockquote>
<p><a href="https://godbolt.org/z/hsKx6K17s">https://godbolt.org/z/hsKx6K17s</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>241 - Did you know about different ways of accessing C-style arrays by index?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/241.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/241.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about different ways of accessing C-style arrays by index?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/dcl.array#def:array">http://eel.is/c++draft/dcl.array#def:array</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  constexpr int array[] = {1, 2, 3};
  assert(2[array] == array[2]);
  assert(*(array+1) == array[1]);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5PnPzWvW8">https://godbolt.org/z/5PnPzWvW8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>sum_n</code> which sums the first N numbers from the array using an altenative access syntax?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
/*TODO*/ auto sum_n(auto);

int main() {
  using namespace boost::ut;

  &quot;sum_n&quot;_test = [] {
    should(&quot;return 0 for empty array&quot;) = [] {
      constexpr int array[] = {};
      expect(constant&lt;0 == sum_n&lt;0&gt;(array)&gt;);
    };

    should(&quot;sum N first parameters&quot;) = [] {
      constexpr int array[] = {1, 2, 3};
      expect(constant&lt;0 == sum_n&lt;0&gt;(array)&gt;);
      expect(constant&lt;1 == sum_n&lt;1&gt;(array)&gt;);
      expect(constant&lt;3 == sum_n&lt;2&gt;(array)&gt;);
      expect(constant&lt;6 == sum_n&lt;3&gt;(array)&gt;);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5dMrTzGo7">https://godbolt.org/z/5dMrTzGo7</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt; constexpr auto sum_n(auto a) {
  std::decay_t&lt;decltype(0 [a])&gt; sum{};
  for (auto i = 0; i &lt; N; ++i) {
    sum += i[a];
  }
  return sum;
}
</code></pre>

<blockquote>
<p><a href="https://cpp-tip-of-the-week.godbolt.org/z/51fY56zdc">https://cpp-tip-of-the-week.godbolt.org/z/51fY56zdc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
constexpr auto sum_n(auto arr) {
  return [&amp;] &lt;auto... Nth_of&gt; (std::integer_sequence&lt;int, Nth_of...&gt;) {
    return (0 + ... + Nth_of[arr]);
  }(std::make_integer_sequence&lt;int, N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K9rcenjME">https://godbolt.org/z/K9rcenjME</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] constexpr auto sum_n(const auto array) {
    return [array]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
        return (Is[array] + ... + 0);
    }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cjo8MovY8">https://godbolt.org/z/cjo8MovY8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
auto constexpr sum_n(auto arr) {
    double sum = 0;
    for(uint32_t i=0; i&lt;N; i++)
        sum += *(arr+i);
    return sum;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y6GxMMjx6">https://godbolt.org/z/Y6GxMMjx6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto I &gt;
auto constexpr get_i(auto const &amp; array)
{
    if constexpr (I % 3 == 0 )
        return array[I];
    else if constexpr (I % 3 == 1)
        return I[array];
    else
        return *(array + I );
}
template&lt;auto N&gt;
auto constexpr sum_n(auto const &amp; array)
{
    return [&amp;]&lt;std::size_t ... Is&gt;( std::index_sequence &lt;Is...&gt; const &amp; )
    {
        return (get_i&lt;Is&gt;(array) + ... + 0 );
    }(std::make_index_sequence&lt;N&gt;());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cx4nfGhvz">https://godbolt.org/z/cx4nfGhvz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N&gt;
constexpr auto sum_n(const auto&amp; array) {
    return [&amp;]&lt;auto... Ith_index_of&gt;(std::index_sequence&lt;Ith_index_of...&gt;) {
        return (0 + ... + Ith_index_of[array]);
    }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d3Gcaq7Pn">https://godbolt.org/z/d3Gcaq7Pn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
[[nodiscard]] constexpr auto sum_n(const auto array) {
    return [array]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
        return (Is[array] + ... + 0);
    }(std::make_index_sequence&lt;N&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3nf6aKM4r">https://godbolt.org/z/3nf6aKM4r</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>240 - Did you know that `using-declarator` can be used to manipulate the overload set?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/240.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/240.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>using-declarator</code> can be used to manipulate the overload set?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/namespace.udecl#:name_hiding,using-declaration_and">http://eel.is/c++draft/namespace.udecl#:name_hiding,using-declaration_and</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct trade {};
struct add_order {};
struct transaction_end {};

struct i {
    constexpr virtual ~i() noexcept = default;
    constexpr virtual void on(const trade&amp;) {}
    constexpr virtual void on(const add_order&amp;) {}
    constexpr virtual void on(const transaction_end&amp;) {}
};

struct impl1 : i {
  void on(const trade&amp;) override {}
};

struct impl2 : i {
  using i::on;
  void on(const trade&amp;) override {}
};

int main() {
    impl1 i1{};
    impl2 i2{};

    // via interface
    static_assert([](i&amp; t) { return requires { t.on(trade{}); }; }(i1));
    static_assert([](i&amp; t) { return requires { t.on(add_order{}); }; }(i1));
    static_assert([](i&amp; t) { return requires { t.on(transaction_end{}); }; }(i1));

    // via concrete
    static_assert([](auto&amp; t) { return requires { t.on(trade{}); }; }(i1));
    static_assert(not [](auto&amp; t) { return requires { t.on(add_order{}); }; }(i1));
    static_assert(not [](auto&amp; t) { return requires { t.on(transaction_end{}); }; }(i1));

    // via concrete with using::on
    static_assert([](auto&amp; t) { return requires { t.on(trade{}); }; }(i2));
    static_assert([](auto&amp; t) { return requires { t.on(add_order{}); }; }(i2));
    static_assert([](auto&amp; t) { return requires { t.on(transaction_end{}); }; }(i2));
}
</code></pre>

<blockquote>
<p><a href="https://cpp.godbolt.org/z/1cWzP3cvM">https://cpp.godbolt.org/z/1cWzP3cvM</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>sum_prices</code> which sums prices from given objects and messages?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct trade {
  int price{};
};
struct order {
  int price{};
};

struct i {
  constexpr virtual ~i() noexcept = default;
  constexpr virtual auto price(const trade&amp;) const -&gt; int { return 1; }
  constexpr virtual auto price(const order&amp;) const -&gt; int { return 2; }
};

struct impl1 : i {
  constexpr auto price(const trade&amp; t) const -&gt; int override {
    return t.price;
  }
};

struct impl2 : i {
  using i::price;
  constexpr auto price(const trade&amp; t) const -&gt; int override { return t.price; }
};

auto sum_prices(...); // TODO

int main() {
  using namespace boost::ut;

  &quot;sum prices&quot;_test = [] {
    impl1 impl1{};
    i&amp; i1 = impl1;
    impl2 impl2{};
    i&amp; i2 = impl2;

    expect(0_i == sum_prices(impl1)());
    expect(0_i == sum_prices(impl1, i1)());
    expect(0_i == sum_prices(impl1, i1, impl2)());
    expect(0_i == sum_prices(impl1, i1, impl2, i2)());

    expect(42_i == sum_prices(impl1)(trade{.price = 42}));
    expect(84_i == sum_prices(impl1, i1)(trade{.price = 42}));
    expect(126_i == sum_prices(impl1, i1, impl2)(trade{.price = 42}));
    expect(168_i == sum_prices(impl1, i1, impl2, i2)(trade{.price = 42}));

    expect(42_i == sum_prices(impl1)(trade{.price = 42}, order{.price = 100}));
    expect(86_i == sum_prices(impl1, i1)(trade{.price = 42}, order{.price = 100}));
    expect(130_i == sum_prices(impl1, i1, impl2)(trade{.price = 42}, order{.price = 100}));
    expect(174_i == sum_prices(impl1, i1, impl2, i2)(trade{.price = 42}, order{.price = 100}));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zj7a4EvGx">https://godbolt.org/z/zj7a4EvGx</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_prices(auto&amp;&amp;... is) {
    return [&amp;] (auto&amp;&amp;... ts) {
        return ([&amp;] (auto&amp;&amp; i) {
            return ([&amp;] (auto&amp;&amp; t) {
                if constexpr (requires { i.price(t); }) {
                    return i.price(t);
                } else {
                    return 0;
                }
            }(ts) + ... + 0);
        }(is) + ...);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G7fdrT9v1">https://godbolt.org/z/G7fdrT9v1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_prices(const auto&amp;... interfaces) {
  constexpr auto get_price = [](const auto&amp; interface, const auto&amp; arg) {
    if constexpr (requires { interface.price(arg); }) {
      return interface.price(arg);
    } else {
      return 0;
    }
  };
  return [&amp;](const auto&amp;... args) {
    auto sum = [&amp;](const auto&amp; interface) {
      return (0 + ... + decltype(get_price){}(interface, args));
    };
    return (0 + ... + sum(interfaces));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oW1Gz8a5W">https://godbolt.org/z/oW1Gz8a5W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto sum_prices(const auto&amp;... interfaces) {
    return [&amp;](const auto&amp;... messages) {
        const auto apply_interface = [&amp;](const auto&amp; interface) {
            const auto message_price = [&amp;](const auto&amp; message) {
                if constexpr (requires { interface.price(message); }) {
                    return interface.price(message);
                } else {
                    return 0;
                }
            };

            return (message_price(messages) + ... + 0);
        };

        return (apply_interface(interfaces) + ...);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8dcvK5vEM">https://godbolt.org/z/8dcvK5vEM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

[[nodiscard]] constexpr auto extract_price_if_available(const auto&amp; impl, const auto value) {
    if constexpr (requires { impl.price(value); }) {
        return impl.price(value);
    } else {
        return 0;
    }
}

[[nodiscard]] constexpr auto sum_for_impl(const auto&amp; impl, const auto&amp;... vals) {
    return (0 + ... + extract_price_if_available(impl, vals));
}

}

auto sum_prices(const auto &amp;... impls) {
    return [&amp;](const auto&amp;... values) {
        return (detail::sum_for_impl(impls, values...) + ...); };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r5ns3b53E">https://godbolt.org/z/r5ns3b53E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class ... Proc&gt;
auto sum_prices(Proc&amp;&amp; ... proc) {
    auto callPrice = [](auto&amp;&amp; pr, auto obj) {
        if constexpr (requires { pr.price(obj); }) return pr.price(obj); else return 0;
    };
    auto sumProcPrice = [callPrice, &amp;proc...](auto obj) { return ( callPrice(proc, obj) + ...);};
    return [sumProcPrice](auto ... objs) { return (sumProcPrice(objs) + ...+ 0);};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dTP3ahjMs">https://godbolt.org/z/dTP3ahjMs</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>239 - Did you know that Circle Meta-model allows to convert string to a type?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/239.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/239.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Circle Meta-model allows to convert string to a type?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2062">http://wg21.link/p2062</a></p>
</li>
<li><a href="https://github.com/seanbaxter/circle/blob/master/reflection/README.md">https://github.com/seanbaxter/circle/blob/master/reflection/README.md</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  @meta std::string type = &quot;int&quot;;
  @type_id(type) i = 42; // string -&gt; type
  return i;              // returns int = 4
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/138zW9PvT">https://godbolt.org/z/138zW9PvT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>strings_to_tuple</code> function which converts given strings into a <code>std::tuple</code> of them?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto strings_to_tuple(Ts...); // TODO

struct foo {
  int id{};
};

int main() {
  using namespace boost::ut;

  &quot;string types to tuple&quot;_test = [] {
    &quot;empty&quot;_test = [] {
      auto ts = strings_to_tuple();
      expect(std::is_same_v&lt;std::tuple&lt;&gt;, decltype(ts)&gt;);
    };

    &quot;simple types&quot;_test = [] {
      auto ts = strings_to_tuple([]{return &quot;int&quot;;}, []{return &quot;double&quot;;});
      std::get&lt;0&gt;(ts) = 4;
      std::get&lt;1&gt;(ts) = 2.;
      expect(4_i == std::get&lt;0&gt;(ts) and 2._d == std::get&lt;1&gt;(ts));
    };

    &quot;mix types&quot;_test = [] {
      auto ts = strings_to_tuple([]{return &quot;unsigned&quot;;}, []{return &quot;foo&quot;;},[]{return &quot;int&quot;;});
      std::get&lt;0&gt;(ts) = 1.;
      std::get&lt;1&gt;(ts).id = 2;
      std::get&lt;2&gt;(ts) = 3;
      expect(1_u == std::get&lt;0&gt;(ts) and 2_i == std::get&lt;1&gt;(ts).id and 3_i == std::get&lt;2&gt;(ts));
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PsEjEKfvd">https://godbolt.org/z/PsEjEKfvd</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto strings_to_tuple(Ts...) {
    return std::tuple&lt;(@type_id(Ts{}()))...&gt;{};
}
</code></pre>

<blockquote>
<p><a href="https://cpp-tip-of-the-week.godbolt.org/z/xzjP1fWbx">https://cpp-tip-of-the-week.godbolt.org/z/xzjP1fWbx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto strings_to_tuple(Ts...args )
{
    auto toTypedObj = []( auto arg ){
        constexpr const char * tName = arg();
        return @type_id(tName){};
    };
    return std::make_tuple(toTypedObj(args)...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hhcT76vTh">https://godbolt.org/z/hhcT76vTh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto strings_to_tuple(Ts...) {
  return std::tuple&lt;@type_id(Ts{}())...&gt;{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rej46v8a9">https://godbolt.org/z/rej46v8a9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constexpr auto strings_to_tuple(Ts ...) {
    return std::make_tuple(@type_id(Ts{}()){}...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4M3M7c5Mz">https://godbolt.org/z/4M3M7c5Mz</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>238 - Did you know that Circle Meta-model allows for applying `normal` STL for operations on @meta types?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/238.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/238.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Circle Meta-model allows for applying <code>normal</code> STL for operations on @meta types?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2062">http://wg21.link/p2062</a></p>
</li>
<li><a href="https://github.com/seanbaxter/circle/blob/master/reflection/README.md">https://github.com/seanbaxter/circle/blob/master/reflection/README.md</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  @meta std::array types{@dynamic_type(int), @dynamic_type(bool)};
  ((std::cout &lt;&lt; @type_string(@pack_type(types)) &lt;&lt; ' '), ...); // int bool
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1chKfEdTh">https://godbolt.org/z/1chKfEdTh</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>rotate_types</code> and <code>calls_verify_types</code> by applying STL with @meta types?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt;
constexpr auto rotate_types(); // TODO

constexpr auto calls_verify_types(auto expected, auto given); // TODO

int main() {
  using namespace boost::ut;

  &quot;rotate types&quot;_test = [] {
    should(&quot;not change the input on empty list&quot;) = [] {
      expect(std::is_same_v&lt;list&lt;&gt;, decltype(rotate_types&lt;0&gt;())&gt;);
      static_assert(not []&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value&gt;(); }; }(std::integral_constant&lt;int, 1&gt;{}));
    };

    should(&quot;return the same input with 1 element&quot;) = [] {
      expect(std::is_same_v&lt;list&lt;int&gt;, decltype(rotate_types&lt;0, int&gt;())&gt;);
      expect(std::is_same_v&lt;list&lt;int&gt;, decltype(rotate_types&lt;1, int&gt;())&gt;);
      static_assert(not []&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value, int&gt;(); }; }(std::integral_constant&lt;int, 2&gt;{}));
    };

    should(&quot;rotate rigth input with multiple elements&quot;) = [] {
      expect(std::is_same_v&lt;list&lt;double, int, float&gt;, decltype(rotate_types&lt;0, double, int, float&gt;())&gt;);
      expect(std::is_same_v&lt;list&lt;int, float, double&gt;, decltype(rotate_types&lt;1, double, int, float&gt;())&gt;);
      expect(std::is_same_v&lt;list&lt;float, double, int&gt;, decltype(rotate_types&lt;2, double, int, float&gt;())&gt;);
      expect(std::is_same_v&lt;list&lt;double, int, float&gt;, decltype(rotate_types&lt;3, double, int, float&gt;())&gt;);

      static_assert([]&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value, double, int, float&gt;(); }; }(std::integral_constant&lt;int, 0&gt;{}));
      static_assert([]&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value, double, int, float&gt;(); }; }(std::integral_constant&lt;int, 1&gt;{}));
      static_assert(not []&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value, double, int, float&gt;(); }; }(std::integral_constant&lt;int, 4&gt;{}));
      static_assert(not []&lt;class T&gt;(T) { return requires { rotate_types&lt;T::value, double, int, float&gt;(); }; }(std::integral_constant&lt;int, 5&gt;{}));
    };

    should(&quot;allow to unpack rotated types&quot;) = [] {
      constexpr auto expected = []&lt;class T&gt;(T){static_assert(std::is_same_v&lt;list&lt;float, double, int&gt;, T&gt;);};
      constexpr auto given = rotate_types&lt;2, double, int, float&gt;();

      calls_verify_types(expected, given);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r3K5hMbso">https://godbolt.org/z/r3K5hMbso</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt; requires ( N &lt;= sizeof...(Ts))
constexpr auto rotate_types()
{
    if constexpr ( sizeof...(Ts) &lt;= 1)
        return list&lt;Ts...&gt;{};
    else
    {
        @meta std::array types{@dynamic_type(Ts)...};
        @meta std::rotate(types.begin(), types.begin() + N, types.end());
        return list&lt;@pack_type(types)...&gt;{};
    }
}

constexpr auto calls_verify_types(auto expected, auto given)
{
    expected(given);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G9rqf7jT1">https://godbolt.org/z/G9rqf7jT1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto N, class... Ts&gt; requires (N &lt;= sizeof...(Ts))
constexpr auto rotate_types() {
  if constexpr (sizeof...(Ts) &lt;= 1) {
    return list&lt;Ts...&gt;{};
  } else {
    @meta std::array types{@dynamic_type(Ts)...};
    @meta std::rotate(std::begin(types), std::next(std::begin(types), N), std::end(types));
    return list&lt;@pack_type(types)...&gt;{};
  }
}

constexpr auto calls_verify_types(auto expected, auto given) -&gt; decltype(auto) {
  return expected(given);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/f3K7vTbT6">https://godbolt.org/z/f3K7vTbT6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt;
requires (N &lt;= sizeof...(Ts))
constexpr auto rotate_types() {
    if constexpr (sizeof...(Ts) &lt;= 1) {
        return list&lt;Ts...&gt;{};
    } else {
        @meta auto types = std::array{@dynamic_type(Ts)...};
        @meta std::rotate(std::begin(types), std::next(std::begin(types), N), std::end(types));
        return list&lt;@pack_type(types)...&gt;{};
    }
}

constexpr auto calls_verify_types(auto expected, auto given) {
    return expected(given);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eGsG6ff1P">https://godbolt.org/z/eGsG6ff1P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt;
requires (N &lt;= sizeof...(Ts))
constexpr auto rotate_types() {
    if constexpr (sizeof...(Ts) &lt;= 1) {
        return list&lt;Ts...&gt;{};
    } else {
        @meta auto types = std::array{@dynamic_type(Ts)...};
        @meta std::rotate(std::begin(types), std::next(std::begin(types), N), std::end(types));
        return list&lt;@pack_type(types)...&gt;{};
    }
}

constexpr auto calls_verify_types(auto expected, auto given) {
    return expected(given);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y6ffnb4ex">https://godbolt.org/z/Y6ffnb4ex</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt;
constexpr auto rotate_types() requires (N &lt;= sizeof...(Ts)) {
    if constexpr (sizeof...(Ts) == 0) {
        return list{};
    } else {
        @meta std::array types{@dynamic_type(Ts)...};
        @meta std::rotate(types.begin(), types.begin() + N, types.end());
        return list&lt;@pack_type(types)...&gt;{};
    }
}

template &lt;class... Ts&gt;
constexpr auto calls_verify_types(auto expected, list&lt;Ts...&gt; given) {
    return verify_types&lt;Ts...&gt;(expected);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r3fohYcad">https://godbolt.org/z/r3fohYcad</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N, class... Ts&gt;
constexpr auto rotate_types() requires (N &lt;= sizeof...(Ts)) {
  if constexpr (sizeof...(Ts) &gt; 0) {
    @meta std::array types{@dynamic_type(@member_types(list&lt;Ts...&gt;))...};
    @meta std::rotate(std::begin(types), std::begin(types) + N, std::end(types));
    return list&lt;@pack_type(types)...&gt;{};
  } else {
    return list{};
  }
}

constexpr auto calls_verify_types(auto expected, auto given) {
  verify_types&lt;@member_types(decltype(given))...&gt;(expected);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9jj9r6Ghn">https://godbolt.org/z/9jj9r6Ghn</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>237 - Did you know about C++2X proposal for the Circle Meta-model for compilation-time meta-programming?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/237.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/237.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++2X proposal for the Circle Meta-model for compilation-time meta-programming?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2062">http://wg21.link/p2062</a></p>
</li>
<li><a href="https://github.com/seanbaxter/circle/blob/master/reflection/README.md">https://github.com/seanbaxter/circle/blob/master/reflection/README.md</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;cstdio&gt;

auto main() -&gt; int {
  std::puts(&quot;Hello world&quot;);        // during run-time
  @meta std::puts(&quot;Hello circle&quot;); // during compilation-time
}
</code></pre>

<pre class="codehilite"><code class="language-sh">Hello circle
ASM generation compiler returned: 0
Hello circle
Execution build compiler returned: 0
Program returned: 0
Hello world
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bo48q1oWW">https://godbolt.org/z/bo48q1oWW</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_tuple_with_names</code> which returns <code>named</code> fields based on Circle Meta-model?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct named {
  T value{};
  std::string_view name{};
};

template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t); // TODO

int main() {
    {
      struct empty { };

      const auto &amp; t = to_tuple_with_names(empty{});

      expect(0 == std::tuple_size_v&lt;std::remove_reference_t&lt;decltype(t)&gt;&gt;);
    }

    {
      struct trade {
        std::int32_t price{42};
      };

      const auto &amp; t = to_tuple_with_names(trade{});

      expect(1 == std::tuple_size_v&lt;std::remove_reference_t&lt;decltype(t)&gt;&gt;);
      expect(42 == std::get&lt;0&gt;(t).value and &quot;price&quot; == std::get&lt;0&gt;(t).name);
    }

    {
      struct trade {
        std::int32_t price{42};
        std::uint32_t quantity{1'000u};
      };

      const auto &amp; t = to_tuple_with_names(trade{});

      expect(2 == std::tuple_size_v&lt;std::remove_reference_t&lt;decltype(t)&gt;&gt;);
      expect(42 == std::get&lt;0&gt;(t).value and &quot;price&quot; == std::get&lt;0&gt;(t).name);
      expect(1'000u == std::get&lt;1&gt;(t).value and &quot;quantity&quot; == std::get&lt;1&gt;(t).name);
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sEhYvas7o">https://godbolt.org/z/sEhYvas7o</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t) {
    std::tuple&lt;named&lt;@member_types(T)&gt;...&gt; result;
    result...[:] = { t...[:], @member_names(T) } ...;
    return result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cbdofa9MY">https://godbolt.org/z/cbdofa9MY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; [[nodiscard]] auto to_tuple_with_names(const T&amp; t) {
  constexpr auto to_tuple_with_names = []&lt;class... TNames, class... TValues&gt;(const TValues&amp;... values) {
    return [&amp;](const auto&amp;... names) {
      return std::make_tuple(named&lt;TValues&gt;{values, names}...);
    };
  };
  return to_tuple_with_names(t.@member_values()...)(@member_names(T)...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EzhbT9q8P">https://godbolt.org/z/EzhbT9q8P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t) {
    std::tuple&lt;named&lt;@member_types(T)&gt;...&gt; result;
    @meta for(int i = 0; i &lt; @member_count(T); ++i) {
        std::get&lt;i&gt;(result) = { @member_value(t, i), @member_name(T, i) };
    }
    return result;
}
</code></pre>

<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t) {
  return std::make_tuple(named&lt;@member_types(T)&gt;{@member_values(t), @member_names(T)}...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x9nWbWaEv">https://godbolt.org/z/x9nWbWaEv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
[[nodiscard]] constexpr auto to_tuple_with_names(const T &amp;t) {
  return std::make_tuple(
      named&lt;@member_types(T)&gt;{t.@member_values(), @member_names(T)}...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a1GK46e6n">https://godbolt.org/z/a1GK46e6n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T, int I&gt; auto get_member( T const &amp; obj)
{
    return named{ obj.@member_value(I), @member_name(T, I) };
}
template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t){
    const int N = @member_count(T);
    return [&amp;]&lt;int ... Is &gt;( std::integer_sequence&lt;int, Is ... &gt; const &amp; )
    {
        return std::make_tuple(get_member&lt;T,Is&gt;(t)...);
    }(std::make_integer_sequence&lt;int,N&gt;{} );
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8rch9eTaW">https://godbolt.org/z/8rch9eTaW</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>236 - Did you know about `__builtin_dump_struct` clang-extension which can nicely print a struct?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/236.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/236.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>__builtin_dump_struct</code> clang-extension which can nicely print a struct?</strong></p>
</li>
<li>
<p><a href="https://clang.llvm.org/docs/LanguageExtensions.html">https://clang.llvm.org/docs/LanguageExtensions.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;utility&gt;

struct trade {
  [[no_unique_address]] double price{42.};
  [[no_unique_address]] std::size_t size{1'000};
};

int main() {
  constexpr auto t = trade{};
  __builtin_dump_struct(std::addressof(t), std::addressof(std::printf));
}
</code></pre>

<pre class="codehilite"><code class="language-sh">const struct trade {
double price : 42.000000
std::size_t size : 1000
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GThTK3T46">https://godbolt.org/z/GThTK3T46</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_tuple_with_names</code> which returns <code>named</code> fields based on <code>__builtin_dump_struct</code> input?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct named {
  T value{};
  std::string_view name{};
};

template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t); // TODO

int main() {
  using namespace boost::ut;

  &quot;to tuple with names&quot;_test = [] {
    using std::literals::string_view_literals::operator&quot;&quot;sv;

    should(&quot;be empty for empty struct&quot;) = [] {
      struct empty { };

      const auto &amp; t = to_tuple_with_names(empty{});

      expect(0_u == std::tuple_size_v&lt;std::remove_cvref_t&lt;decltype(t)&gt;&gt;);
    };

    should(&quot;get value and names for struct with single field&quot;) = [] {
      struct trade {
        std::int32_t price{42};
      };

      const auto &amp; t = to_tuple_with_names(trade{});

      expect(1_u == std::tuple_size_v&lt;std::remove_cvref_t&lt;decltype(t)&gt;&gt;);
      expect(42_i == std::get&lt;0&gt;(t).value and &quot;price&quot; == std::get&lt;0&gt;(t).name);
    };

    should(&quot;get value and names for struct with multiple fields&quot;) = [] {
      struct trade {
        std::int32_t price{42};
        std::uint32_t quantity{1'000u};
      };

      const auto &amp; t = to_tuple_with_names(trade{});

      expect(2_u == std::tuple_size_v&lt;std::remove_cvref_t&lt;decltype(t)&gt;&gt;);
      expect(42_i == std::get&lt;0&gt;(t).value and &quot;price&quot; == std::get&lt;0&gt;(t).name);
      expect(1'000_u == std::get&lt;1&gt;(t).value and &quot;quantity&quot; == std::get&lt;1&gt;(t).name);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7Ej67n513">https://godbolt.org/z/7Ej67n513</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct any_type {
    template&lt;typename T&gt; constexpr operator T() const;
};

template&lt;class T, class ... Args&gt;
constexpr bool is_braces_constructible = requires { T{std::declval&lt;Args&gt;()...};};

char buffer[100];
std::stringstream desc;
int printf_toStream(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    int count = vsprintf(buffer, fmt, args);
    va_end(args);
    desc &lt;&lt; buffer;
    return count;
}

template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t) {
    desc = std::stringstream();
    __builtin_dump_struct(std::addressof(t), std::addressof(printf_toStream));

    std::vector&lt;std::string&gt; lines;
    boost::split(lines, desc.str(), boost::is_any_of(&quot;\n&quot;));
    std::vector&lt;std::string&gt; names;
    for(uint32_t i=0; i&lt;lines.size()-3; i++)
    {
        std::vector&lt;std::string&gt; fields;
        boost::split(fields, lines[i+1], boost::is_any_of(&quot; &quot;));
        names.push_back(fields[1]);
    }

    if constexpr( is_braces_constructible&lt;T, any_type, any_type&gt; ) {
        auto&amp;&amp; [p0, p1] = t;
        return std::make_tuple( named&lt;decltype(p0)&gt;{p0, names[0]}, named&lt;decltype(p1)&gt;{p1, names[1]});
    } else if constexpr( is_braces_constructible&lt;T, any_type&gt; ) {
        auto&amp;&amp; [p1] = t;
        return std::make_tuple( named&lt;decltype(p1)&gt;{p1, names[0]});
    } else {
        return std::make_tuple();
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Tdx8j6hxq">https://godbolt.org/z/Tdx8j6hxq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct any_type { template&lt;class T&gt; constexpr operator T(); };

template&lt;class T&gt;
auto to_tuple_with_names(const T&amp; t) {
  static std::vector&lt;std::string&gt; names{};
  names = {};

  struct set {
    static auto ns(const char* str, ...) -&gt; int {
      std::string type_name{str};
      if (type_name.contains(&quot; : &quot;)) {
        type_name = type_name.substr(type_name.find(' ') + 1);
        names.push_back(type_name.substr(0, type_name.find(':') - 1));
      }
      return {};
    }
  };

  __builtin_dump_struct(std::addressof(t), std::addressof(set::ns));

  if constexpr(requires { T{any_type{}, any_type{}}; }) {
    auto [p1, p2] = t;
    assert(2 == std::size(names));
    return std::tuple(named&lt;decltype(p1)&gt;{.value = p1, .name = names[0]}, named&lt;decltype(p2)&gt;{.value = p2, .name = names[1]});
  } else if constexpr(requires { T{any_type{}}; }) {
    auto [p1] = t;
    assert(1 == std::size(names));
    return std::tuple(named&lt;decltype(p1)&gt;{.value = p1, .name = names[0]});
  } else {
    assert(std::empty(names));
    return std::tuple{};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gd6PbvTdW">https://godbolt.org/z/Gd6PbvTdW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct universal_arg { template&lt;typename T&gt; constexpr operator T() const; };
template &lt;class T&gt;
concept one_field = requires { T{universal_arg{}}; };
template &lt;class T&gt;
concept two_fields = requires { T{universal_arg{}, universal_arg{}}; };

static std::vector&lt;std::string&gt; names;

int printf_to_buffer(const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  char buffer[256];
  const auto ret = vsprintf(buffer, fmt, args);
  va_end(args);

  if (const auto v = std::string_view{buffer}; v.contains(':')) {
    if (const auto name_start = v.find(' '); name_start != std::string_view::npos) {
      const auto name_end = v.find(' ', name_start + 1);
      names.emplace_back(&amp;v[name_start + 1], &amp;v[name_end]);
    }
  }

  return ret;
}

template &lt;class T&gt; auto to_tuple_with_names(const T&amp; t) {
  names.clear();
  __builtin_dump_struct(std::addressof(t), &amp;printf_to_buffer);

  if constexpr (two_fields&lt;T&gt;) {
    auto &amp;[f0, f1] = t;
    return std::tuple{named{f0, names[0]}, named{f1, names[1]}};
  } else if constexpr (one_field&lt;T&gt;) {
    auto &amp;[f0] = t;
    return std::tuple{named{f0, names[0]}};
  } else {
    return std::tuple{};
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dj84eThqn">https://godbolt.org/z/dj84eThqn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
struct Reflector
{
    #define MAX_NUM_FIELDS 255
    struct Any{
        Any(int){}
        template&lt;typename MT&gt; constexpr operator MT(){return MT{};}
    };
    template&lt;int N&gt;
    static consteval bool Initializeable( )
    {
        return []&lt;int ... Is &gt; ( std::integer_sequence&lt;int, Is...&gt; const &amp; )
        {
            return (requires{ T { Any(Is) ... };});
        }( std::make_integer_sequence&lt;int,N&gt;());
    }
    template&lt;int N = MAX_NUM_FIELDS &gt; //search down from MAX_NUM_FIELDS
    static consteval int NumFields()
    {
        if constexpr ( Initializeable&lt;N&gt;())
        {
            return N;
        } else
            return NumFields&lt;N-1&gt;();
    }
    template&lt;int N = NumFields()&gt;
    static auto ToTuple( auto &amp;&amp; t )
    {
        #define ELEMENTS(z,n,text) BOOST_PP_COMMA_IF( n ) BOOST_PP_CAT(text,n)
        #define OP(r, I) BOOST_PP_DEC(I)
        #define PRED(r, I) BOOST_PP_NOT_EQUAL(I, 0)
        #define TUPLE_N( r,I ) \
        if constexpr ( N == I ) { auto [BOOST_PP_REPEAT(I, ELEMENTS, a)] = t;return std::make_tuple(BOOST_PP_REPEAT(I, ELEMENTS, a));}
        BOOST_PP_FOR(MAX_NUM_FIELDS, PRED, OP, TUPLE_N)
        if constexpr( N == 0 ) return std::make_tuple();
    }
};

template&lt; typename T &gt;
struct NameParser{
    static std::vector&lt;std::string&gt; names;
    static int parse(const char* format,... )
    {
        int n = 0;
        int p1= 0;
        int p2= 0;
        while (format[n]!='\0' &amp;&amp; format[n+1]!='\0')
        {
            if( format[n] == ' ')
            {
                if( p1 == 0 )
                    p1 = n;
                else
                    p2 = n ;
            }
            if( format[n] ==':' &amp;&amp; format[n+1] ==' ' )
            {
                auto &amp; name = names.emplace_back(p2-p1-1,'0');
                for( int i = p1 + 1 ; i &lt; p2; ++i )
                    name[i-p1 - 1] = format[i];
            }
            ++n;
        }
        return 0;
    }
};
template &lt;typename T&gt; std::vector&lt;std::string&gt; NameParser&lt;T&gt;::names = {};
template&lt;typename T&gt;
struct NamedValue
{
    NamedValue(std::string const &amp; name, T const &amp; value ): name(name),value(value){}
    std::string name;
    T value;
};
template&lt;class T&gt; auto to_tuple_with_names(const T&amp; t)
{
    __builtin_dump_struct(std::addressof(t), &amp;NameParser&lt;T&gt;::parse);
    auto tp = Reflector&lt;T&gt;::ToTuple(t);
    return [&amp;]&lt;int ... IS&gt;( std::integer_sequence&lt;int, IS...&gt; const &amp;  )
    {
        return std::make_tuple( NamedValue( NameParser&lt;T&gt;::names[IS], std::get&lt;IS&gt;(tp)) ... );
    }( std::make_integer_sequence&lt;int,std::tuple_size_v&lt;std::remove_cvref_t&lt;decltype(tp)&gt;&gt;&gt;() );
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xodvvjc3f">https://godbolt.org/z/xodvvjc3f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;typename...&gt;
struct always_false : std::false_type {};

template &lt;auto&gt;
struct any_type {
    template&lt;typename T&gt; constexpr operator T() const;
};

template &lt;class T, std::size_t... Ns&gt;
constexpr bool has_n_members_impl(std::index_sequence&lt;Ns...&gt;) {
    return requires { T{any_type&lt;Ns&gt;{}...}; };
}

template &lt;class T, std::size_t N&gt;
constexpr bool has_n_members = has_n_members_impl&lt;T&gt;(std::make_index_sequence&lt;N&gt;{});

} // namespace detail

struct to_tuple_with_names_impl {
    inline static std::vector&lt;std::string&gt; names{};

    static int dump_struct_helper(const char* fmt, ...) {
        if (const std::string_view dump{fmt}; dump.contains(':')) {
            const auto name_begin = dump.find(' ') + 1;
            const auto name_end = dump.find(' ', name_begin);
            names.emplace_back(&amp;dump[name_begin], &amp;dump[name_end]);
        }
        return {};
    }

    template &lt;typename T&gt;
    auto operator()(const T&amp; t) const {
        names.clear();
        __builtin_dump_struct(std::addressof(t), &amp;dump_struct_helper);

        if constexpr (detail::has_n_members&lt;T, 2&gt;) {
            const auto&amp; [a, b] = t;
            return std::tuple {
                named {a, names[0]},
                named {b, names[1]}
            };
        } else if constexpr (detail::has_n_members&lt;T, 1&gt;) {
            const auto&amp; [a] = t;
            return std::tuple {
                named {a, names[0]}
            };
        } else if constexpr (detail::has_n_members&lt;T, 0&gt;) {
            return std::tuple{};
        } else {
            static_assert(detail::always_false&lt;T&gt;::value, &quot;struct is too large&quot;);
        }
    }
};

template&lt;class T&gt; [[nodiscard]] auto to_tuple_with_names(const T&amp; t) {
    return to_tuple_with_names_impl{}(t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bP4116dh4">https://godbolt.org/z/bP4116dh4</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>235 - Did you know that C++20 `[[no_unique_address]]` can be used to implement lazy/fast/memory efficient views?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/235.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/235.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 <code>[[no_unique_address]]</code> can be used to implement lazy/fast/memory efficient views?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/dcl.attr.nouniqueaddr">https://eel.is/c++draft/dcl.attr.nouniqueaddr</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, fixed_string Str, auto Offset = 0&gt;
struct field {
  constexpr const auto&amp; get() const { return *reinterpret_cast&lt;const T*&gt;(reinterpret_cast&lt;const char*&gt;(this) + Offset); }
  constexpr operator const T&amp;() const { return get(); }
};

enum class side : std::uint8_t { buy, sell };
struct trade {
  [[no_unique_address]] field&lt;::std::int32_t, &quot;price&quot;&gt; price;
  [[no_unique_address]] field&lt;::std::uint32_t, &quot;size&quot;, sizeof(std::int32_t)&gt; quantity;
  [[no_unique_address]] field&lt;::side, &quot;side&quot;, sizeof(std::int32_t) + sizeof(std::uint32_t)&gt; side;
};
static_assert(1 == sizeof(trade));

auto parse(const void* msg) {
  const auto&amp; trade = *reinterpret_cast&lt;const ::trade*&gt;(msg);
  assert(42 == trade.price);
  assert(100 == trade.quantity);
  assert(side::sell == trade.side);
}

int main() {
  struct [[gnu::packed]] {
    ::std::int32_t price{42};
    ::std::uint32_t quantity{100};
    ::side side{side::sell};
  } trade{};

  parse(std::addressof(trade));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3r8hq5sxe">https://godbolt.org/z/3r8hq5sxe</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>buffer_cast</code> and extend <code>field</code> to support dynamic arrays?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, fixed_string Name, auto Offset = 0&gt;
struct field; // TODO
template&lt;class T&gt; const T&amp; buffer_cast(const void* msg); // TODO

enum class side : std::uint8_t { buy, sell };
struct trade final {
  [[no_unique_address]] field&lt;::std::int32_t, &quot;price&quot;&gt; price;
  [[no_unique_address]] field&lt;::std::uint32_t, &quot;size&quot;, sizeof(std::int32_t)&gt; quantity;
  [[no_unique_address]] field&lt;::side, &quot;side&quot;, sizeof(std::int32_t) + sizeof(std::uint32_t)&gt; side;
};
static_assert(1 == sizeof(trade));

struct order final {
  [[no_unique_address]] field&lt;::std::int32_t, &quot;price&quot;&gt; price;
  [[no_unique_address]] field&lt;::std::uint32_t, &quot;size&quot;, sizeof(std::int32_t)&gt; quantity;
  [[no_unique_address]] field&lt;::side, &quot;side&quot;, sizeof(std::int32_t) + sizeof(std::uint32_t)&gt; side;
  [[no_unique_address]] field&lt;::std::uint32_t, &quot;len&quot;, sizeof(std::int32_t) + sizeof(std::uint32_t) + sizeof(::side)&gt; len;
  [[no_unique_address]] field&lt;double[], &quot;prices&quot;, sizeof(std::int32_t) + sizeof(std::uint32_t) + sizeof(::side) + sizeof(::std::uint32_t)&gt; prices;
};
static_assert(1 == sizeof(order));

int main() {
  using namespace boost::ut;

  &quot;buffer cast&quot;_test = [] {
    struct [[gnu::packed]] {
      ::std::int32_t price{1};
      ::std::uint32_t quantity{2};
      ::side side{side::buy};
    } trade{};

    const auto&amp; msg = buffer_cast&lt;::trade&gt;(std::addressof(trade));

    expect(1 == msg.price);
    expect(2 == msg.quantity);
    expect(side::buy == msg.side);
  };

  &quot;buffer cast with dynamic array at the end&quot;_test = [] {
    struct [[gnu::packed]] {
      ::std::int32_t price{42};
      ::std::uint32_t quantity{100};
      ::side side{side::sell};
      ::std::uint32_t len{4};
      std::array&lt;double, 4&gt; prices{.4, .3, .2, .1};
    } order{};

    const auto&amp; msg = buffer_cast&lt;::order&gt;(std::addressof(order));

    expect(42 == msg.price);
    expect(100 == msg.quantity);
    expect(side::sell == msg.side);
    expect(4 == msg.len);
    expect(.4 == msg.prices[0]);
    expect(.3 == msg.prices[1]);
    expect(.2 == msg.prices[2]);
    expect(.1 == msg.prices[3]);
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ca8d565TE">https://godbolt.org/z/ca8d565TE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, fixed_string Name, auto Offset = 0&gt;
struct field {
  [[nodiscard]] constexpr operator const T&amp;() const noexcept {
    return *std::launder(reinterpret_cast&lt;const T*&gt;(reinterpret_cast&lt;const char*&gt;(this) + Offset));
  }
};
template&lt;class T&gt; [[nodiscard]] constexpr const T&amp; buffer_cast(const void* msg) noexcept {
  return *(::new (const_cast&lt;void*&gt;(msg)) const T);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1T96och5x">https://godbolt.org/z/1T96och5x</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, fixed_string Name, auto Offset = 0&gt;
struct field {
  constexpr const auto&amp; get() const { return *reinterpret_cast&lt;const T*&gt;(reinterpret_cast&lt;const char*&gt;(this) + Offset); }
  constexpr operator const T&amp;() const { return get(); }
};
template&lt;class T&gt; const T&amp; buffer_cast(const void* msg) {
  return *reinterpret_cast&lt;const T*&gt;(msg);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K9E8Kd73x">https://godbolt.org/z/K9E8Kd73x</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, fixed_string Name, auto Offset = 0&gt;
struct field {
    [[nodiscard]] constexpr const T&amp; get() const noexcept {
        // I'm pretty sure this is UB... since the struct is packed so the
        // values are not aligned... :(
        const auto addr = reinterpret_cast&lt;const std::byte*&gt;(this) + Offset;
        return *std::launder(reinterpret_cast&lt;const T*&gt;(addr));
    }

    constexpr operator const T&amp;() const noexcept { return get(); }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/49vnv9Pz8">https://godbolt.org/z/49vnv9Pz8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, fixed_string Name, auto Offset = 0&gt;
struct field {
  [[nodiscard]] constexpr const auto&amp; get() const {
    return *reinterpret_cast&lt;const T*&gt;(reinterpret_cast&lt;const char*&gt;(this) +
                                       Offset);
  }
  [[nodiscard]] constexpr operator const T&amp;() const { return get(); }
};
template &lt;class T&gt;
[[nodiscard]] const T&amp; buffer_cast(const void* msg) {
  return *reinterpret_cast&lt;const T*&gt;(msg);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1T61fKoM8">https://godbolt.org/z/1T61fKoM8</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>234 - Did you know about function-try-block and that exceptions caught inside that block are implicitly rethrown?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/234.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/234.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about function-try-block and that exceptions caught inside that block are implicitly rethrown?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/except.pre#nt:function-try-block">http://eel.is/c++draft/except.pre#nt:function-try-block</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  foo() { throw 0; }
};

struct bar {
  bar() try : foo_{} {
    // constructor body
  }
  catch (...)
  {
    // exceptions from the initializer list are caught here
    // but also re-thrown after this block (unless the program is aborted)
  }

private:
  foo foo_;
};

int main() try {
  bar b{};
}
catch(...) {
  // okay, exception cought here!
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y4efK573f">https://godbolt.org/z/Y4efK573f</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>foo</code>'s constructor which initializes <code>Ts...</code> and sets <code>exception</code> to true if any exception is thrown and rethrows it?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class TException&gt;
struct ctor_except {
  ctor_except() { throw TException{}; }
};

template&lt;class... Ts&gt;
struct foo : Ts... {
  explicit(true) foo(bool&amp; exception); // TODO
};

int main() {
  using namespace boost::ut;

  &quot;function-try-block&quot;_test = [] {
    bool exception{false};
    struct bar { };

    should(&quot;not set exception with empty list&quot;) = [=] {
      expect(nothrow([&amp;]{ foo&lt;&gt;{mut(exception)}; }) and not exception);
    };

    should(&quot;not set exception with non-throwing types&quot;) = [=] {
      expect(nothrow([&amp;]{ foo&lt;bar&gt;{mut(exception)}; }) and not exception);
    };

    should(&quot;catch exception if thrown from within the constructor&quot;) = [=] {
      expect(throws&lt;int&gt;([&amp;]{ foo&lt;ctor_except&lt;int&gt;&gt;{mut(exception)}; }) and exception);
    };

    should(&quot;catch exception if thrown from within the constructor with muliple types&quot;) = [=] {
      expect(throws&lt;int&gt;([&amp;]{ foo&lt;bar, ctor_except&lt;int&gt;&gt;{mut(exception)}; }) and exception);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s3MzE8xM9">https://godbolt.org/z/s3MzE8xM9</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct foo : Ts... {
  explicit(true) foo (bool&amp; exception) try : Ts{}... {
  } catch (...) {
    exception = true;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8Yxr7WbsM">https://godbolt.org/z/8Yxr7WbsM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct foo : Ts... {
  explicit(true) foo(bool&amp; exception) try : Ts()... {
      exception = false;
  } catch(...) {
      exception = true;
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dnhcjsYjK">https://godbolt.org/z/dnhcjsYjK</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>233 - Did you know that C++20 made `typename` more optional?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/233.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/233.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 made <code>typename</code> more optional?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0634">http://wg21.link/p0634</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; /*typename*/T::type return_type();   // okay
template&lt;class T&gt; void void_parameter(/*typename*/T::type); // error: variable or field 'parameter' declared void
template&lt;class T&gt; auto auto_parameter(/*typename*/T::type); // okay

template&lt;class T&gt;
struct traits {
  using type = /*typename*/ T::type; // okay
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oMMzfjeKv">https://godbolt.org/z/oMMzfjeKv</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you add/remove required/unnecessary <code>typename's</code></strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct traits {
  using type = typename T::type;
};

template&lt;class T&gt;
struct s : typename T::type {};

template&lt;class T&gt; typename T::type f1();
template&lt;class T&gt; auto f2() -&gt; typename T::type;
auto f3(auto t) -&gt; typename decltype(t)::type;

template&lt;class T&gt; auto f4(typename T::type);
template&lt;class T&gt; bool f5(typename T::type);
template&lt;class T&gt; void f6(T::type);
template&lt;class T&gt; auto f7(T::type) -&gt; void;
auto f8(auto t) -&gt; typename decltype(t)::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EEeTh5TWP">https://godbolt.org/z/EEeTh5TWP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct traits {
  using type = T::type;
};

template&lt;class T&gt;
struct s : T::type {};

template&lt;class T&gt; T::type f1();
template&lt;class T&gt; auto f2() -&gt; T::type;
auto f3(auto t) -&gt; decltype(t)::type;

template&lt;class T&gt; auto f4(T::type);
template&lt;class T&gt; bool f5(T::type);
template&lt;class T&gt; void f6(typename T::type);
template&lt;class T&gt; auto f7(typename T::type) -&gt; void;
auto f8(auto t) -&gt; decltype(t)::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nMsqeaev8">https://godbolt.org/z/nMsqeaev8</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>232 - Did you know that different overloads can have different specifiers?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/232.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/232.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that different overloads can have different specifiers?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/dcl.spec.general">http://eel.is/c++draft/dcl.spec.general</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto foo(auto) { return 42; }
consteval auto foo(auto f) requires requires { f.value; } { return f.value; }

int main(int argc, char**) {
  std::cout &lt;&lt; foo(argc); // prints 42

  constexpr struct {
    int value{88};
  } v;

  std::cout &lt;&lt; foo(v); // prints 88
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a9sKb177j">https://godbolt.org/z/a9sKb177j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a function f which for { 0 args: is run-time - returns 42; 1 arg: is run/compile-time, returns arg; &gt;1 args: is compile-time, returns sum of args... }</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto f(...); // TODO

template&lt;auto&gt; auto is_compile_time() {}

int main() {
  using namespace boost::ut;

  &quot;run-time call&quot;_test = [] {
    expect(42_i == f());
    expect(not [](auto... ts) { return requires { is_compile_time&lt;f(ts...)&gt;(); }; }());
  };

  &quot;constexpr call&quot;_test = [] {
    &quot;compile-time call&quot;_test = [] {
      expect(constant&lt;42_i == f(42)&gt;);
      expect(requires { is_compile_time&lt;f(42)&gt;(); });

      constexpr auto i = 43;
      expect(constant&lt;43_i == f(43)&gt;);
    };

    &quot;run-time call&quot;_test = [] {
      auto i = 44;
      expect(44_i == f(i));
    };
  };

  &quot;consteval call&quot;_test = [] {
    expect(constant&lt;3_i == f(1, 2)&gt;);
    expect(constant&lt;6_i == f(1, 2, 3)&gt;);
    auto i = 1;
    //f(42, i); // should not compile
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EWK873qfv">https://godbolt.org/z/EWK873qfv</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">auto f() { return 42; }
constexpr auto f(auto v) { return v; }
template&lt;typename ... Args&gt; consteval auto f(Args... args) { return (0 + ... + args); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6hM3nbabv">https://godbolt.org/z/6hM3nbabv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto f() { return 42; }
constexpr auto f(auto arg) { return arg; }
consteval auto f(auto... args) { return (... + args); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qdf3z1Khr">https://godbolt.org/z/qdf3z1Khr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto f() { return 42; }
constexpr auto f(auto value) { return value; }
consteval auto f(auto... values) requires (sizeof...(values) &gt; 1) { return (... + values); }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8o3WYG8ze">https://godbolt.org/z/8o3WYG8ze</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>231 - Did you know about C++17 variadic using declaration?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/231.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/231.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++17 variadic using declaration?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/namespace.udecl#nt:using-declarator-list">http://eel.is/c++draft/namespace.udecl#nt:using-declarator-list</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TEvents&gt;
struct ihandler : ihandler&lt;TEvents&gt;... {
  virtual ~ihandler() noexcept = default;
  using ihandler&lt;TEvents&gt;::on...;
};

template&lt;class TEvent&gt; struct ihandler&lt;TEvent&gt; {
  virtual ~ihandler() noexcept = default;
  virtual auto on(const TEvent&amp;) -&gt; bool = 0;
};

int main() {
  struct foo {};
  struct bar {};

  struct handler : ihandler&lt;foo, bar&gt; {
    auto on(const foo&amp;) -&gt; bool override { return true; }
    auto on(const bar&amp;) -&gt; bool override { return false; }
  };

  std::unique_ptr&lt;ihandler&lt;foo, bar&gt;&gt; h = std::make_unique&lt;handler&gt;();
  assert(h-&gt;on(foo{}));
  assert(not h-&gt;on(bar{}));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ffr1TaGhq">https://godbolt.org/z/ffr1TaGhq</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>handler</code> which will implement an interface <code>T</code> for given <code>Ts...</code> and returns <code>Ts::value</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TEvents&gt;
struct ihandler : ihandler&lt;TEvents&gt;... {
  virtual ~ihandler() noexcept = default;
  using ihandler&lt;TEvents&gt;::on...;
};

template&lt;class TEvent&gt; struct ihandler&lt;TEvent&gt; {
  virtual ~ihandler() noexcept = default;
  virtual auto on(const TEvent&amp;) -&gt; bool = 0;
};

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
struct handler final; // TODO

int main() {
  using namespace boost::ut;

  &quot;handler&quot;_test = [] {
    struct foo { bool value{}; };
    struct bar { bool value{}; };

    auto h = std::make_unique&lt;handler&lt;ihandler, foo, bar&gt;&gt;();

    expect(h-&gt;on(foo{.value = true}) and
           static_cast&lt;ihandler&lt;foo&gt;*&gt;(h.get())-&gt;on(foo{.value = true})
    );

    expect(not h-&gt;on(bar{.value = false}) and
           not static_cast&lt;ihandler&lt;bar&gt;*&gt;(h.get())-&gt;on(bar{.value = false})
    );
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hez4KvcnM">https://godbolt.org/z/hez4KvcnM</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, template&lt;class...&gt; class  U&gt;
struct handler_helper:U&lt;T&gt;
{
    auto on(const T&amp; t) -&gt; bool override{
        return t.value;
    }
};

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
struct handler final : handler_helper&lt;Ts,T&gt; ...
{
    using handler_helper&lt;Ts,T&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bhqMdMj5E">https://godbolt.org/z/bhqMdMj5E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template&lt;template&lt;class...&gt; class I, class T&gt;
struct handler : I&lt;T&gt; {
  auto on(const T&amp; t) -&gt; bool override {
    return t.value;
  }
};
} // namespace detail

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
struct handler final : detail::handler&lt;T, Ts&gt;... {
  using detail::handler&lt;T, Ts&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vfvee6bP1">https://godbolt.org/z/vfvee6bP1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;template&lt;class&gt; class Interface, class TEvent&gt;
struct handler_impl : Interface&lt;TEvent&gt; {
  auto on(const TEvent&amp; event) -&gt; bool override { return event.value; }
};
}

template &lt;template&lt;class&gt; class Interface, class... TEvents&gt;
struct handler final : detail::handler_impl&lt;Interface, TEvents&gt;... {
  using detail::handler_impl&lt;Interface, TEvents&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7xEsM16jM">https://godbolt.org/z/7xEsM16jM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;class...&gt; class T, class... Ts&gt;
struct handler final : handler&lt;T, Ts&gt;... {
    using handler&lt;T, Ts&gt;::on...;
};

template&lt;template&lt;class...&gt; class T, class TEvent&gt;
struct handler&lt;T, TEvent&gt; : T&lt;TEvent&gt; {
    auto on(const TEvent&amp; event) -&gt; bool final {
        return event.value;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Pe491e6E1">https://godbolt.org/z/Pe491e6E1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;template &lt;class...&gt; class TContainer, class T&gt;
struct handler_impl : TContainer&lt;T&gt; {
  [[nodiscard]] constexpr auto on(const T&amp; t) -&gt; bool override {
    return t.value;
  }
};
}  // namespace detail

template &lt;template &lt;class...&gt; class T, class... Ts&gt;
struct handler final : detail::handler_impl&lt;T, Ts&gt;... {
  using detail::handler_impl&lt;T, Ts&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W1xavY13r">https://godbolt.org/z/W1xavY13r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct on_method : ihandler&lt;T&gt; {
    bool on(T const&amp; t) { return t.value; }
};

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
struct handler final : on_method&lt;Ts&gt;... {
    using on_method&lt;Ts&gt;::on...;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8vG89YY11">https://godbolt.org/z/8vG89YY11</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>230 - Did you know that C++23 added `if consteval`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/230.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/230.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>if consteval</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1938">http://wg21.link/p1938</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;cassert&gt;

consteval int f(int i) { return i; }

constexpr int g(int i) {
    if consteval {
        return f(i) + 1; // ok: immediate function context
    } else {
        return 42;
    }
}

consteval int h(int i) {
    return f(i) + 1; // ok: immediate function context
}

static_assert(42 + 1 == h(42));

int main() {
  int i = 42;
  //h(i); // error: the value of 'i' is not usable in a constant expression
  assert(42 == g(i));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rjeodeMoP">https://godbolt.org/z/rjeodeMoP</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a <code>add_or_sub</code> algorithm which adds <code>args</code> to <code>N</code> in consteval context and subs <code>args...</code> from <code>N</code> otherwise?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N = 0&gt;
constexpr auto add_or_sub = [](const auto... args); // TODO

int main() {
  using namespace boost::ut;

  &quot;add or sub test&quot;_test = [] {
    should(&quot;add in consteval context&quot;) = [] {
      expect(constant&lt;0_i == add_or_sub&lt;0&gt;()&gt;);
      expect(constant&lt;1_i == add_or_sub&lt;0&gt;(1)&gt;);
      expect(constant&lt;2_i == add_or_sub&lt;1&gt;(1)&gt;);
      expect(constant&lt;4_i == add_or_sub&lt;1&gt;(1, 2)&gt;);
      expect(constant&lt;16_i == add_or_sub&lt;2&gt;(3, 4, 7)&gt;);
    };

    should(&quot;sub in non-consteval context&quot;) = [] {
      expect(0_i == add_or_sub&lt;0&gt;());
      expect(-1_i == add_or_sub&lt;0&gt;(1));
      expect(0_i == add_or_sub&lt;1&gt;(1));
      expect(-2_i == add_or_sub&lt;1&gt;(1, 2));
      expect(-12_i == add_or_sub&lt;2&gt;(3, 4, 7));

      const auto i = 42;
      expect(-44_i == add_or_sub&lt;&gt;(2, i));

      auto x = 7;
      expect(-51_i == add_or_sub&lt;1&gt;(1, x, 2, i));
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xssv8MY4W">https://godbolt.org/z/xssv8MY4W</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N = 0&gt;
constexpr auto add_or_sub = [](const auto... args) {
  if consteval {
    return (N + ... + args);
  } else {
    return (N - ... - args);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8vqoPb5dT">https://godbolt.org/z/8vqoPb5dT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N = 0&gt;
constexpr auto add_or_sub = [](const auto... args) {
    const auto sum_of_args = (args + ... + 0);
    if consteval {
        return N + sum_of_args;
    } else {
        return N - sum_of_args;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5xerzMjq3">https://godbolt.org/z/5xerzMjq3</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>229 - Did you know about python's named tuples?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/229.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/229.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about python's named tuples?</strong></p>
</li>
<li>
<p><a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">https://docs.python.org/3/library/collections.html#collections.namedtuple</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-python">from collections import namedtuple

nt = namedtuple(&quot;price&quot;, &quot;size&quot;)

nt.price = 42;
nt.size = 100;

assert 42 == nt.price and 100 == nt.size
</code></pre>

</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a C++ version of named tuples?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct namedtuple; // TODO

int main() {
  using namespace boost::ut;

  &quot;named tuple&quot;_test = [] {
    should(&quot;allow empty&quot;) = [] {
      const auto nt = namedtuple{};
      expect(not [](auto t) { return requires { t[&quot;&quot;_t]; }; }(nt));
    };

    should(&quot;support direct initialization&quot;) = [] {
      const auto nt = namedtuple{&quot;price&quot;_t = 42, &quot;size&quot;_t = 100};
      expect([](auto t) { return requires { t[&quot;price&quot;_t]; }; }(nt));
      expect([](auto t) { return requires { t[&quot;size&quot;_t]; }; }(nt));
      expect(not [](auto t) { return requires { t[&quot;quantity&quot;_t]; }; }(nt));
      expect(42_i == nt[&quot;price&quot;_t] and 100_i == nt[&quot;size&quot;_t]);
    };

    should(&quot;support modification&quot;) = [] {
      auto nt = namedtuple{&quot;price&quot;_t = int{}, &quot;size&quot;_t = std::size_t{}};
      nt[&quot;price&quot;_t] = 12;
      nt[&quot;size&quot;_t] = 34u;
      expect(12_i == nt[&quot;price&quot;_t] and 34_u == nt[&quot;size&quot;_t]);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c918qhjWP">https://godbolt.org/z/c918qhjWP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;char... Cs&gt;
struct named_field {
private:
  static constexpr char name_storage[] = {Cs...};

  template &lt;class T&gt;
  struct value_wrapper {
    static constexpr auto name() { return named_field::name; }
    T value{};
  };

public:
  static constexpr auto name = std::string_view{std::data(name_storage), std::size(name_storage)};

  template &lt;class T&gt;
  constexpr auto operator=(const T&amp; t) { return value_wrapper&lt;T&gt;{.value = t}; }
};

template &lt;class TChar, TChar... Cs&gt; constexpr auto operator&quot;&quot;_t () {
  return named_field&lt;Cs...&gt;{};
}

template &lt;class... Ts&gt;
struct namedtuple : Ts... {
private:
  struct no_value {};
  friend constexpr auto operator,(no_value v, no_value) { return v; }
  template &lt;class T&gt; friend constexpr auto operator,(no_value, T&amp;&amp; t) -&gt; decltype(auto) { return std::forward&lt;T&gt;(t); }
  template &lt;class T&gt; friend constexpr auto operator,(T&amp;&amp;t, no_value) -&gt; decltype(auto) { return std::forward&lt;T&gt;(t); }

  // need P0847 &quot;deducing this&quot;
  template &lt;class... Us, char... Cs&gt;
  constexpr auto lookup(const named_field&lt;Cs...&gt;&amp;) const -&gt; decltype(auto) {
    return ([&amp;] &lt;class U&gt; () -&gt; decltype(auto) {
      if constexpr (U::name() == named_field&lt;Cs...&gt;::name) {
        return (static_cast&lt;U&amp;&gt;(const_cast&lt;namedtuple&amp;&gt;(*this)).value);
      } else {
        return no_value{};
      }
    }.template operator()&lt;Us&gt;(), ... , no_value{});
  }

public:
  constexpr auto operator[](const auto&amp; f) const -&gt; decltype(auto)
    requires (not std::is_same_v&lt;decltype(lookup&lt;std::add_const_t&lt;Ts&gt;...&gt;(f)), no_value&gt;)
  {
    return lookup&lt;std::add_const_t&lt;Ts&gt;...&gt;(f);
  }

  constexpr auto operator[](const auto&amp; f) -&gt; decltype(auto)
    requires (not std::is_same_v&lt;decltype(lookup&lt;Ts...&gt;(f)), no_value&gt;)
  {
    return lookup&lt;Ts...&gt;(f);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6bYhx8EPo">https://godbolt.org/z/6bYhx8EPo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size&gt;
struct fixed_string {
  char data[Size + 1]{};
  static constexpr auto size = Size;
  constexpr explicit(false) fixed_string(char const* str) { std::copy_n(str, Size + 1, data); }
  constexpr explicit(false) operator std::string_view() const { return {data, Size}; }
};
template&lt;auto Size&gt; fixed_string(char const (&amp;)[Size]) -&gt; fixed_string&lt;Size - 1&gt;;

template&lt;auto...&gt;
struct arg {
  template&lt;class T&gt; constexpr auto operator=(const T&amp; t) const { return std::pair&lt;arg, T&gt;{*this, t}; }
};

template&lt;fixed_string Str&gt; constexpr auto operator&quot;&quot;_t() {
  return []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return arg&lt;Str.data[Ns]...&gt;{};
  }(std::make_index_sequence&lt;Str.size&gt;{});
}

template&lt;class... Ts&gt;
struct namedtuple : std::tuple&lt;Ts...&gt; {
  using std::tuple&lt;Ts...&gt;::tuple;

  template&lt;class T&gt; constexpr decltype(auto) operator[](const T) const
    requires(not std::is_void_v&lt;boost::mp11::mp_map_find&lt;boost::mp11::mp_list&lt;Ts...&gt;, T&gt;&gt;)
  {
    using type = boost::mp11::mp_map_find&lt;boost::mp11::mp_list&lt;Ts...&gt;, T&gt;;
    return std::get&lt;type&gt;(*this).second;
  }

  template&lt;class T&gt; constexpr auto&amp; operator[](const T)
    requires(not std::is_void_v&lt;boost::mp11::mp_map_find&lt;boost::mp11::mp_list&lt;Ts...&gt;, T&gt;&gt;)
  {
    using type = boost::mp11::mp_map_find&lt;boost::mp11::mp_list&lt;Ts...&gt;, T&gt;;
    return std::get&lt;type&gt;(*this).second;
  }
};
template&lt;class... Ts&gt; namedtuple(Ts&amp;&amp;...) -&gt; namedtuple&lt;Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q6EPsnY4P">https://godbolt.org/z/q6EPsnY4P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class CharT, CharT... s&gt;
struct field : private boost::mp11::mp_list_c&lt;CharT, s...&gt;
{
    template &lt;class T&gt;
    struct mapped_type {
        using key_type = field;

        constexpr mapped_type(T&amp;&amp; value) : value{value} {}

        constexpr operator auto() { return value; }
        constexpr operator auto() const { return value; }
    private:
        T value;
    };

    auto operator=(auto&amp;&amp; rhs) { return mapped_type{std::forward&lt;decltype(rhs)&gt;(rhs)}; }
};

template &lt;class CharT, CharT... s&gt;
constexpr auto operator&quot;&quot;_t() { return field&lt;CharT, s...&gt;{}; }

template &lt;class... Ts&gt;
concept is_set = boost::mp11::mp_is_set&lt;boost::mp11::mp_list&lt;Ts...&gt;&gt;::value;

template &lt;class K, class M&gt;
concept map_contains = boost::mp11::mp_map_contains&lt;M, K&gt;::value;

template &lt;class M, class K&gt;
using map_find = boost::mp11::mp_second&lt;boost::mp11::mp_map_find&lt;M, std::remove_cvref_t&lt;K&gt;&gt;&gt;;

template&lt;class... Ts&gt; requires is_set&lt;Ts...&gt;
class namedtuple : Ts...
{
    using map_type = boost::mp11::mp_list&lt;boost::mp11::mp_list&lt;typename Ts::key_type, Ts&gt;...&gt;;
public:
    constexpr namedtuple(Ts&amp;&amp;... pairs) : Ts{pairs}... {}

    constexpr auto&amp; operator[](const map_contains&lt;map_type&gt; auto&amp; k) {
        return *static_cast&lt;map_find&lt;map_type, decltype(k)&gt;*&gt;(this);
    }
    constexpr auto operator[](const map_contains&lt;map_type&gt; auto&amp; k) const {
        return *static_cast&lt;const map_find&lt;map_type, decltype(k)&gt;*&gt;(this);
    }
};

template&lt;class... Ts&gt; explicit namedtuple(Ts&amp;&amp;...) -&gt; namedtuple&lt;Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6rq354Yn1">https://godbolt.org/z/6rq354Yn1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char ... Cs&gt;
struct KeyType
{
    template&lt; typename T&gt;
    constexpr auto operator = ( T const &amp; v )
    {
        return std::make_pair( *this, v );
    }
};

template&lt;class T, T ... Cs  &gt;
constexpr auto operator&quot;&quot; _t()
{
    return KeyType&lt;Cs ... &gt;{};
}

template&lt;class... Ts&gt;
struct namedtuple{
    using M = boost::mp11::mp_list&lt;Ts...&gt;;
    static_assert( boost::mp11::mp_is_map&lt;M&gt;::value );//unique keys
    namedtuple( Ts ... args ):data{args...}{}
    template &lt;char ... Cs &gt;
    static constexpr bool Contain( KeyType&lt;Cs...&gt; const &amp; )
    {
        if(sizeof ... (Cs) == 0 || sizeof...(Ts) == 0 ) return false;
        using V= boost::mp11::mp_map_find&lt;M,KeyType&lt;Cs...&gt;&gt;;
        return !std::is_void_v&lt;V&gt;;
    }
    template&lt;char ... Cs &gt; requires ( Contain( KeyType&lt;Cs...&gt;{} ) )
    constexpr auto const &amp; operator[]( KeyType&lt;Cs...&gt; const &amp; ) const
    {
        using V= boost::mp11::mp_map_find&lt;M,KeyType&lt;Cs...&gt; &gt;;
        return std::get&lt;V&gt;(data).second;
    }
    template&lt;char ... Cs &gt; requires  ( Contain( KeyType&lt;Cs...&gt;{} ) )
    constexpr auto &amp; operator[]( KeyType&lt;Cs...&gt; const &amp; )
    {
        using V= boost::mp11::mp_map_find&lt;M,KeyType&lt;Cs...&gt; &gt;;
        return std::get&lt;V&gt;(data).second;
    }
    std::tuple&lt; Ts ... &gt; data;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v4Kb3K47j">https://godbolt.org/z/v4Kb3K47j</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>228 - Did you know that C++ allows accessing private members with friend injection?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/228.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/228.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++ allows accessing private members with friend injection?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/class.friend#:access_control,friend_function">http://eel.is/c++draft/class.friend#:access_control,friend_function</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class foo {
 private:
  int data;
};

template&lt;int foo::*Ptr&gt;
int&amp; get_data(foo&amp; f) {
  return f.*Ptr;
}

template&lt;int foo::*Ptr&gt;
struct foo_access {
  friend int&amp; get_data(foo&amp; f) {
    return f.*Ptr;
  }
};

template struct foo_access&lt;&amp;foo::data&gt;;
int&amp; get_data(foo&amp;);

int main() {
  foo f{};
  get_data(f) = 42; // access private data member
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/65zee7exf">https://godbolt.org/z/65zee7exf</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>get_token</code> which gives access to the private trade token?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">class trade {
 public:
  int price{};
  int size{};

  constexpr auto token() const { return token_; }

 private:
  std::string_view token_{};
};

 // TODO
std::string_view&amp; get_token(trade&amp;);

int main() {
  using namespace boost::ut;

  &quot;access private token&quot;_test = [] {
    trade t{};
    expect(&quot;&quot; == t.token());
    get_token(t) = &quot;Quantlab&quot;;
    expect(&quot;Quantlab&quot; == t.token());
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/83dsMcErT">https://godbolt.org/z/83dsMcErT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">class trade {
 friend std::string_view&amp; get_token(trade&amp;);

 public:
  int price{};
  int size{};

  constexpr auto token() const { return token_; }

 private:
  std::string_view token_{};
};

std::string_view&amp; get_token(trade&amp; t) {
    return t.token_;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hvesa79n8">https://godbolt.org/z/hvesa79n8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class trade {
 public:
  int price{};
  int size{};

  constexpr auto token() const { return token_; }

 private:
  std::string_view token_{};
};

template &lt;std::string_view trade::*Ptr&gt;
struct trade_access {
  friend auto get_token(trade&amp; t) -&gt; std::string_view&amp; {
    return t.*Ptr;
  }
};

template struct trade_access&lt;&amp;trade::token_&gt;;
auto get_token(trade&amp; t) -&gt; std::string_view&amp;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/37aerxdEs">https://godbolt.org/z/37aerxdEs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class V, V T::*Ptr, class Token&gt;
struct BadFriend {
    friend V&amp; get_data(T&amp; f , Token const &amp;  ) {
        return f.*Ptr;
    }
};
#define ACCESS( TYPE, MEMBER_TYPE, MEMBER )                              \
    struct MEMBER{                                                       \
        MEMBER( TYPE &amp; t ):t(t){}                                        \
        auto &amp; operator()();                                             \
        TYPE &amp; t;                                                        \
    };                                                                   \
    template struct BadFriend&lt;TYPE, MEMBER_TYPE, &amp;TYPE::MEMBER, MEMBER&gt;; \
    MEMBER_TYPE &amp; get_data(TYPE&amp;,MEMBER const &amp; );                       \
    auto &amp; MEMBER::operator()(){                                         \
        return get_data( t, *this );                                     \
    }

ACCESS(trade,std::string_view,token1_)
ACCESS(trade,std::string_view,token2_)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7TdcE5zGf">https://godbolt.org/z/7TdcE5zGf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace steal {
template &lt;class&gt;
struct trait;
template &lt;class T, class U&gt;
struct trait&lt;T U::*&gt; { using type = U; };
template&lt;auto ptr, class tag&gt;
struct member_pointer {
    friend constexpr auto&amp; get_member_pointer(
        typename trait&lt;decltype(ptr)&gt;::type&amp; f, const tag*) noexcept
    { return f.*ptr; }
};
}

// Must not be pasted inside any namespace
#define EXPOSE_MEMBER_AND_THEN_GO_THINK_ABOUT_WHAT_YOU_HAVE_DONE(NS, BASE, MEMBER) \
namespace NS {                                                                     \
class BASE##_##MEMBER {                                                            \
    BASE&amp; base;                                                                    \
public:                                                                            \
    constexpr BASE##_##MEMBER(BASE&amp; base) : base(base) {}                          \
    constexpr auto&amp; operator()() const noexcept;                                   \
};                                                                                 \
}                                                                                  \
namespace steal {                                                                  \
template class member_pointer&lt;&amp;::NS::BASE::MEMBER, ::NS::BASE##_##MEMBER&gt;;         \
constexpr auto&amp; get_member_pointer(                                                \
    ::NS::BASE&amp;, const ::NS::BASE##_##MEMBER*) noexcept;                           \
}                                                                                  \
constexpr auto&amp; ::NS::BASE##_##MEMBER::operator()() const noexcept {               \
    return ::steal::get_member_pointer(base, this);                                \
}

namespace business::messages {
class trade {
public:
    int price{};
    int size{};

    constexpr auto token1() const { return token1_; }
    constexpr auto token2() const { return token2_; }
private:
    std::string_view token1_{};
    std::string_view token2_{};
};
}

EXPOSE_MEMBER_AND_THEN_GO_THINK_ABOUT_WHAT_YOU_HAVE_DONE(business::messages, trade, token1_)
EXPOSE_MEMBER_AND_THEN_GO_THINK_ABOUT_WHAT_YOU_HAVE_DONE(business::messages, trade, token2_)
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YWY4bv6dn">https://godbolt.org/z/YWY4bv6dn</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>227 - Did you know that `std::variant` become valueless by exception?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/227.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/227.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>std::variant</code> become valueless by exception?</strong></p>
</li>
<li>
<p>(guaranteed) an exception is thrown during the move initialization of the contained value from the temporary in copy assignment</p>
</li>
<li>(guaranteed) an exception is thrown during the move initialization of the contained value during move assignment</li>
<li>(optionally) an exception is thrown when initializing the contained value during a type-changing assignment</li>
<li>
<p>(optionally) an exception is thrown when initializing the contained value during a type-changing emplace</p>
</li>
<li>
<p><a href="https://eel.is/c++draft/variant">https://eel.is/c++draft/variant</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  foo() = default;
  foo(const foo&amp;) { throw 42; }
};

int main() {
  std::variant&lt;int, foo&gt; v{42};
  assert(not v.valueless_by_exception());

  try {
    v = foo{}; // throws
  } catch(...) { }

  assert(v.valueless_by_exception());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PnKaY4Kq5">https://godbolt.org/z/PnKaY4Kq5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>throws</code> class in order to satisfy guaranteed variant valueless by exception tests?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  using namespace boost::ut;
  using namespace boost::ut::spec;

  describe(&quot;variant - valuless by exception&quot;) = [] {
      it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
        struct throws; // TODO
        std::variant&lt;std::monostate, throws&gt; v{};
        expect(not v.valueless_by_exception() and 0_i == v.index());

        try {
          // TODO
        } catch(...) { }

        expect(v.valueless_by_exception());
        expect(std::variant_npos == v.index());
      };

      it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
        struct throws; // TODO
        std::variant&lt;std::monostate, throws&gt; v{};
        expect(not v.valueless_by_exception() and 0_i == v.index());

        try {
          // TODO
        } catch(...) { }

        expect(v.valueless_by_exception());
        expect(std::variant_npos == v.index());
      };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z6G7jEEno">https://godbolt.org/z/z6G7jEEno</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valuless by exception&quot;) = [] {
    it(&quot;should valueless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
      struct throws {
        throws() = default;
        throws(const throws&amp;) { throw 42; }
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        throws t{};
        v = t;
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };

    it(&quot;should valueless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
      struct throws {
        throws() = default;
        throws(throws&amp;&amp;) { throw 42; }
        throws&amp; operator=(throws&amp;&amp;) = default;
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        v = throws{};
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/avvG5ob1W">https://godbolt.org/z/avvG5ob1W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valuless by exception&quot;) = [] {
    it(&quot;should valueless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
      struct throws {
        throws() = default;
        throws(const throws&amp;) { throw std::exception{}; }
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        v = throws{};
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };

    it(&quot;should valueless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
      struct throws {
        throws() = default;
        throws(throws&amp;&amp;) { throw std::exception{}; }
        throws&amp; operator=(throws&amp;&amp;) = default;
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        v = throws{};
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/47Y389jcf">https://godbolt.org/z/47Y389jcf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valuless by exception&quot;) = [] {
    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
        struct throws {
            constexpr throws() = default;
            throws(throws const&amp;) { throw &quot;an error&quot;; }
        };

        std::variant&lt;std::monostate, throws&gt; v{};
        expect(not v.valueless_by_exception() and 0_i == v.index());

        try {
            auto const t = throws{};
            v = t;
        } catch(...) { }

        expect(v.valueless_by_exception());
        expect(std::variant_npos == v.index());
    };

    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
        struct throws {
            constexpr throws() = default;
            throws(throws&amp;&amp;) { throw &quot;an error&quot;; }
            constexpr throws&amp; operator=(throws&amp;&amp;) = default;
        };

        std::variant&lt;std::monostate, throws&gt; v{};
        expect(not v.valueless_by_exception() and 0_i == v.index());

        try {
            v = throws{};
        } catch(...) { }

        expect(v.valueless_by_exception());
        expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6Gqx3Edvr">https://godbolt.org/z/6Gqx3Edvr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valueless by exception&quot;) = [] {
    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {

      struct throws
      {
          throws() = default;
          throws(const throws&amp; t) {throw 123;}
      };

      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
          throws tmp{};
          v = tmp;
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };

    it(&quot;should valueless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
      struct throws
      {
          throws() {}
          throws(throws&amp;&amp;) {throw 123;}
          throws&amp; operator=(throws&amp;&amp;) = default;
      };

      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        v = throws{};
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KvW8jeoGz">https://godbolt.org/z/KvW8jeoGz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valuless by exception&quot;) = [] {
    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
      struct throws{
          throws() = default;
          throws( throws const &amp; ) {throw 0;}
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
          throws a;
          v = a;
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };

    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
      struct throws{
          throws() = default;
          throws( throws &amp;&amp; ) {
              throw 0;
          }
          throws &amp; operator=( throws &amp;&amp; )
          {
              throw 1;
              return *this;
          }
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
          throws a;
          v = std::move(a);
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M7hGndsrM">https://godbolt.org/z/M7hGndsrM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">describe(&quot;variant - valuless by exception&quot;) = [] {
    it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value from the temporary in copy assignment&quot;) = [] {
      struct throws {
          throws() = default;
          throws(throws const&amp;) {  throw 42; }
      };
      std::variant&lt;std::monostate, throws&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
          v = throws{};
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };

   it(&quot;should valuless by exception when an exception is thrown during the move initialization of the contained value during move assignment&quot;) = [] {
      struct throws {
          throws() = default;
          throws(throws&amp;&amp;) { throw 42; }
          throws&amp; operator=(throws&amp;&amp;) = default;
      };
      std::variant&lt;std::monostate, throws, int&gt; v{};
      expect(not v.valueless_by_exception() and 0_i == v.index());

      try {
        v = std::move(throws{});
      } catch(...) { }

      expect(v.valueless_by_exception());
      expect(std::variant_npos == v.index());
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eff6Wdd7P">https://godbolt.org/z/eff6Wdd7P</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>226 - Did you know about C++23 feature which adds support for inheriting from std::variant?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/226.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/226.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++23 feature which adds support for inheriting from std::variant?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2162">http://wg21.link/p2162</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct value : std::variant&lt;int, double&gt; {
  using variant::variant;

  constexpr auto operator()(const auto&amp; value) {
    std::clog &lt;&lt; value &lt;&lt; '\n';
  }
};

int main(){
  std::visit(value{}, std::variant&lt;int, double&gt;(42));  // prints 42
  std::visit(value{}, std::variant&lt;int, double&gt;(99.)); // prints 99
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oez6McKzn">https://godbolt.org/z/oez6McKzn</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a generic state variant with <code>id</code> API (returns true if the given type is hold) and print_id which prints state id if available?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class state; // TODO

const auto print_id = [] (auto&amp; os); // TODO

int main(){
  using namespace boost::ut;

  struct disconnected {};
  struct connected { int id{}; };

  &quot;inheriting from variant&quot;_test = [] {
    state&lt;disconnected, connected&gt; state{};

    should(&quot;be disconnected and print nothing&quot;) = [=] {
      std::stringstream str{};
      mut(state) = disconnected{};
      std::visit(print_id(str), state);
      expect(state.is&lt;disconnected&gt;());
      expect(std::string{&quot;&quot;} == str.str());
    };

    should(&quot;be connected and print id&quot;) = [=] {
      std::stringstream str{};
      mut(state) = connected{.id = 42};
      std::visit(print_id(str), state);
      expect(state.is&lt;connected&gt;());
      expect(std::string{&quot;42&quot;} == str.str());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YPWcnYPsh">https://godbolt.org/z/YPWcnYPsh</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct state : std::variant&lt;Ts...&gt; {
    template&lt;class T&gt;
    state&amp; operator=(T&amp;&amp; t) noexcept {
        return (*this = state{t});
    }

    template&lt;class T&gt;
    bool is() const {
        return std::holds_alternative&lt;T&gt;(*this);
    }
};

const auto print_id = [] (auto&amp; os) {
    return [&amp;os] (const auto&amp; st) {
        if constexpr (requires { st.id; }) {
            os &lt;&lt; st.id;
        } else {
            os &lt;&lt; &quot;&quot;;
        }
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ndK5jnT4W">https://godbolt.org/z/ndK5jnT4W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct state : std::variant&lt;Ts...&gt; {
  using std::variant&lt;Ts...&gt;::operator=;

  template &lt;typename T&gt;
  [[nodiscard]] constexpr auto is() const noexcept -&gt; bool {
    return std::holds_alternative&lt;T&gt;(*this);
  }
};

const auto print_id = [](auto&amp; os) {
  return [&amp;](const auto state) {
    if constexpr (requires { state.id; }) {
      os &lt;&lt; state.id;
    }
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7W5chhjY5">https://godbolt.org/z/7W5chhjY5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class state : public std::variant&lt;Ts...&gt; {
  using base = std::variant&lt;Ts...&gt;;
  using base::base;

public:
  template &lt;typename T&gt;
  constexpr bool is() const { return holds_alternative&lt;T&gt;(*this); }
};

const auto print_id = [] (auto&amp; os) {
  return [&amp;] (const auto&amp; member) {
    if constexpr (requires { member.id; }) {
      os &lt;&lt; member.id;
    }
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vM387vehn">https://godbolt.org/z/vM387vehn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct state : std::variant&lt;Ts...&gt; {
    using std::variant&lt;Ts...&gt;::variant;

    template &lt;typename T&gt;
    constexpr auto is() const noexcept -&gt; bool {
        return std::holds_alternative&lt;T&gt;(*this);
    }
};

const auto print_id = [] (auto&amp; os) {
    return [&amp;] (auto const&amp; state) {
        if constexpr (requires { state.id; }) {
            os &lt;&lt; state.id;
        }
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xx7zj3jzs">https://godbolt.org/z/xx7zj3jzs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class state : public std::variant&lt;Ts...&gt; {
public:
    using std::variant&lt;Ts...&gt;::variant;

    template &lt;class T&gt;
    constexpr auto is() const {
        return std::holds_alternative&lt;T&gt;(*this);
    }
};

const auto print_id = [] ([[maybe_unused]] auto&amp; os) {
    return [&amp;] (const auto&amp; v) {
        if constexpr (requires { os &lt;&lt; v.id; }) {
            os &lt;&lt; v.id;
        }
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r15dWoE6T">https://godbolt.org/z/r15dWoE6T</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct state:std::variant&lt;Ts...&gt;
{
    using std::variant&lt;Ts...&gt;::variant;
    template&lt;class T&gt;
    constexpr bool is() const
    {
        return std::holds_alternative&lt;T&gt;(*this);
    }
};

const auto print_id (auto&amp; os)
{
    return [&amp;os](auto const &amp; val){
        if constexpr ( requires { val.id; })
            os &lt;&lt; val.id;
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TYhej3xsa">https://godbolt.org/z/TYhej3xsa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class state : public std::variant&lt;Ts...&gt; {
public:
    template&lt;class C&gt;
    bool is() const { return std::holds_alternative&lt;C&gt;(*this); }
    template&lt;class T&gt;
    state&amp; operator=(T&amp;&amp; t) {
        std::variant&lt;Ts...&gt;::operator=(std::forward&lt;T&gt;(t));
        return *this;
     }
};

template&lt;typename T&gt; using Id_t = decltype(std::declval&lt;T&amp;&gt;().id);
template&lt;typename T&gt; constexpr bool HasMember_id = std::experimental::is_detected_v&lt; Id_t, T&gt;;

const auto print_id = [] (auto&amp; os) {
    return [&amp;os]&lt;typename T&gt;(T const&amp; t) {
        if constexpr(HasMember_id&lt;T&gt;)
            os &lt;&lt; t.id;
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dzY344zv1">https://godbolt.org/z/dzY344zv1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
class state : public std::variant&lt;Ts ...&gt; {
public:
    using std::variant&lt;Ts ...&gt;::variant;

    template&lt;class T&gt;
    constexpr auto is() const{
        return std::holds_alternative&lt;T&gt;(*this);
    }
};

const auto print_id = [] (auto&amp; os) {
    return [&amp;](const auto &amp; v){
        if constexpr (requires { v.id; })
            os &lt;&lt; v.id;
    };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q3x6Wv6j7">https://godbolt.org/z/q3x6Wv6j7</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>225 - Did you know about C++23 feature which removes unnecessary ()s from C++ lambdas?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/225.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/225.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++23 feature which removes unnecessary ()s from C++ lambdas?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1102">http://wg21.link/p1102</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  constexpr auto okay_in_cpp20  = [] {};                    // okay in C++20
  constexpr auto error_in_cpp20 = [] mutable {};            // okay in C++23
  constexpr auto error_in_cpp20 = [] -&gt; int { return {};};  // okay in C++23
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4Tjbb8xzr">https://godbolt.org/z/4Tjbb8xzr</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you remove unnecessary ()'s from the following lambda expressions?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  constexpr auto l1 = []() {};
  constexpr auto l2 = []()mutable{};
  constexpr auto l3 = []()mutable constexpr{};
  constexpr auto l4 = []()mutable consteval{};
  constexpr auto l5 = []()mutable consteval  {};
  constexpr auto l6 = []() -&gt; int { return {}; };
  constexpr auto l7 = []() -&gt; auto { return 0; };
  constexpr auto l8 = []&lt;class...&gt;() {};
  constexpr auto l9 = []&lt;auto...&gt;() {};
  constexpr auto l10 = []&lt;auto...&gt;() mutable {};
  constexpr auto l11 = []&lt;auto...&gt;() noexcept {};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n6rPMjhaz">https://godbolt.org/z/n6rPMjhaz</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  constexpr auto l1 = [] {};
  constexpr auto l2 = [] mutable{};
  constexpr auto l3 = [] mutable constexpr {};
  constexpr auto l4 = [] mutable consteval {};
  constexpr auto l5 = [] mutable consteval  {};
  constexpr auto l6 = [] -&gt; int { return {}; };
  constexpr auto l7 = [] -&gt; auto { return 0; };
  constexpr auto l8 = []&lt;class...&gt; {};
  constexpr auto l9 = []&lt;auto...&gt; {};
  constexpr auto l10 = []&lt;auto...&gt; mutable {};
  constexpr auto l11 = []&lt;auto...&gt; noexcept {};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ozro3cr53">https://godbolt.org/z/ozro3cr53</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>224 - Did you know that the JSON standard does not specify that the insertion order of object elements should be preserved?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/224.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/224.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that the JSON standard does not specify that the insertion order of object elements should be preserved?</strong></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc8259.html">https://tools.ietf.org/html/rfc8259.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  {
  nlohmann::json json{};
  json[&quot;value&quot;] = 42;
  json[&quot;array&quot;] = std::array{1, 2, 3};
  std::cout &lt;&lt; json.dump(); // prints {&quot;array&quot;:[1,2,3],&quot;value&quot;:42}
  }

  {
  nlohmann::ordered_json json{};
  json[&quot;value&quot;] = 42;
  json[&quot;array&quot;] = std::array{1, 2, 3};
  std::cout &lt;&lt; json.dump(); // prints {&quot;value&quot;:42&quot;, array&quot;:[1,2,3]}
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E8sMcPTM8">https://godbolt.org/z/E8sMcPTM8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you extend <code>to_json</code> function from the last week with support of insertion_order/alphabetical_order policies?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class TPolicy = class insertion_order&gt;
constexpr auto to_json(const auto&amp; input); // TODO

template &lt;class T&gt;
struct named {
  std::string_view name{};
  T value{};
};

int main() {
  using namespace boost::ut;
  using std::literals::string_literals::operator&quot;&quot;s;

  &quot;to json&quot;_test = [] {
    const auto t = std::tuple{
          named{.name = &quot;int&quot;, .value = 1},
          named{.name = &quot;double&quot;, .value = 2.0},
          named{.name = &quot;array&quot;, .value = std::array{1, 2, 3}},
          named{.name = &quot;compound&quot;,
                .value = std::tuple{named{.name = &quot;unsigned&quot;, .value = 42u}}}};

    &quot;default order&quot;_test = [=] {
      const auto json = to_json(t);
      expect(R&quot;({&quot;int&quot;:1,&quot;double&quot;:2.0,&quot;array&quot;:[1,2,3],&quot;compound&quot;:{&quot;unsigned&quot;:42}})&quot;s == json.dump());
    };

    &quot;insertion order&quot;_test = [=] {
      const auto json = to_json&lt;class insertion_order&gt;(t);
      expect(R&quot;({&quot;int&quot;:1,&quot;double&quot;:2.0,&quot;array&quot;:[1,2,3],&quot;compound&quot;:{&quot;unsigned&quot;:42}})&quot;s == json.dump());
    };

    &quot;alphabetical order&quot;_test = [=] {
      const auto json = to_json&lt;class alphabetical_order&gt;(t);
      expect(R&quot;({&quot;array&quot;:[1,2,3],&quot;compound&quot;:{&quot;unsigned&quot;:42},&quot;double&quot;:2.0,&quot;int&quot;:1})&quot;s == json.dump());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4jT5fqnvr">https://godbolt.org/z/4jT5fqnvr</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct insertion_order {
  using json_t = nlohmann::ordered_json;
};

struct alphabetical_order {
  using json_t = nlohmann::json;
};

using default_order = insertion_order;

template &lt;class TPolicy = default_order&gt;
constexpr auto&amp; to_json(const auto&amp; t) {
  return t;
}

template &lt;class TPolicy = default_order, typename... Ts&gt;
constexpr auto to_json(const std::tuple&lt;Ts...&gt;&amp; t) {
  return std::apply([] (const auto&amp;... ts) {
    typename TPolicy::json_t obj{};
    ((obj[std::string{ts.name}] = to_json&lt;TPolicy&gt;(ts.value)), ...);
    return obj;
  }, t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5o1KEY6oW">https://godbolt.org/z/5o1KEY6oW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct alphabetical_order {
    using json_type = nlohmann::json;
};

struct insertion_order {
    using json_type = nlohmann::ordered_json;
};

template &lt;typename TPolicy = insertion_order&gt;
constexpr auto to_json(auto const&amp; value) -&gt; decltype(auto) {
    return value;
}

template &lt;typename TPolicy = insertion_order, typename... Ts&gt;
constexpr auto to_json(std::tuple&lt;Ts...&gt; const&amp; tuple) {
    typename TPolicy::json_type json{};
    std::apply([&amp;] (auto const&amp;... named) {
        ((json[std::string{named.name}] = to_json&lt;TPolicy&gt;(named.value)), ...);
    }, tuple);
    return json;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j3sPjvceY">https://godbolt.org/z/j3sPjvceY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct alphabetical_order {
    using json_type = nlohmann::json;
};

struct insertion_order {
    using json_type = nlohmann::ordered_json;
};

template &lt;typename TPolicy = insertion_order&gt;
constexpr auto to_json(auto const&amp; value) -&gt; decltype(auto) {
    return value;
}

template &lt;typename TPolicy = insertion_order, typename... Ts&gt;
constexpr auto to_json(std::tuple&lt;Ts...&gt; const&amp; tuple) {
    typename TPolicy::json_type json{};
    std::apply([&amp;] (auto const&amp;... named) {
        ((json[std::string{named.name}] = to_json&lt;TPolicy&gt;(named.value)), ...);
    }, tuple);
    return json;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qsTj8Gf8P">https://godbolt.org/z/qsTj8Gf8P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class insertion_order;
class alphabetical_order;

template&lt;class T&gt;
using json_t = typename std::conditional_t&lt;
  std::is_same_v&lt;T, insertion_order&gt;,
    std::type_identity&lt;nlohmann::ordered_json&gt;,
    std::enable_if&lt;
      std::is_same_v&lt;T, alphabetical_order&gt;,
      nlohmann::json&gt;&gt;::type;

template&lt;class TPolicy = class insertion_order, class... Ts&gt;
constexpr auto to_json(const std::tuple&lt;named&lt;Ts&gt;...&gt;&amp; t) {
  return std::apply([] (const auto&amp;... ts) {
    json_t&lt;TPolicy&gt; json{};
    (..., (json[std::string{ts.name}] = to_json&lt;TPolicy&gt;(ts.value)));
    return json;
  }, t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s4ov3M9fs">https://godbolt.org/z/s4ov3M9fs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto&amp; to_json(const auto&amp; t) {
  return t;
}

template &lt;class TPolicy = class insertion_order, typename... Ts&gt;
constexpr auto to_json(const std::tuple&lt;Ts...&gt;&amp; t) {
  return std::apply([] (const auto&amp;... ts) {
    if constexpr( std::is_same_v&lt;TPolicy, class insertion_order&gt; ) {
        nlohmann::ordered_json obj{};
        ((obj[std::string{ts.name}] = to_json(ts.value)), ...);
        return obj;
    } else {
        nlohmann::json obj{};
        ((obj[std::string{ts.name}] = to_json(ts.value)), ...);
        return obj;
    }
  }, t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ee4qa5xTq">https://godbolt.org/z/Ee4qa5xTq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto &amp; value) {
    return value;
}

template&lt;class ...T&gt; constexpr auto to_json(const std::tuple&lt;named&lt;T&gt;...&gt;&amp; tp) {
    nlohmann::ordered_json json{};

    std::apply([&amp;](const auto&amp;... n)
    {
        ((json[std::string{n.name}] = to_json(n.value)), ...);
   }, tp);

    return json;
};

template&lt;class ...T&gt; constexpr auto to_alphabetical_json(const std::tuple&lt;named&lt;T&gt;...&gt;&amp; tp) {
    nlohmann::json json{};

    std::apply([&amp;](const auto&amp;... n)
    {
        ((json[std::string{n.name}] = to_json(n.value)), ...);
   }, tp);

    return json;
};


template&lt;class TPolicy = insertion_order&gt;
constexpr auto to_json(const auto&amp; input)
{
    if constexpr(std::is_same_v&lt;TPolicy, insertion_order&gt;) {
        return to_json(input);
    }
    else if constexpr(std::is_same_v&lt;TPolicy, alphabetical_order&gt;) {
        return to_alphabetical_json(input);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hMzeT9nPG">https://godbolt.org/z/hMzeT9nPG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class TPolicy = class insertion_order&gt;
constexpr auto to_json( auto const &amp; arg){ return arg; }
template&lt;class TPolicy = class insertion_order,class T&gt;
constexpr std::tuple&lt;const char*,decltype(to_json(T{}))&gt; to_json( named&lt;T&gt; const &amp; arg)
{
    return {arg.name.data(),to_json(arg.value)};
}
template&lt;class TPolicy = class insertion_order,class ... T&gt;
constexpr auto to_json(std::tuple&lt; named&lt;T&gt; ... &gt; const &amp; arg)
{
    if constexpr ( std::is_same_v&lt;TPolicy,class insertion_order&gt; )
        return std::apply( []( auto const &amp; ...args ){ return nlohmann::ordered_json{to_json(args)...}; },arg);
    else
        return std::apply( []( auto const &amp; ...args ){ return nlohmann::json{to_json(args)...}; },arg);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/edzK6drj3">https://godbolt.org/z/edzK6drj3</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>223 - Did you know about the proposal to add json support to the standard library?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/223.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/223.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about the proposal to add json support to the standard library?</strong></p>
</li>
<li>
<p><a href="https://github.com/nlohmann/std_json/blob/master/proposal.md">https://github.com/nlohmann/std_json/blob/master/proposal.md</a></p>
</li>
<li><a href="https://github.com/nlohmann/json">https://github.com/nlohmann/json</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  nlohmann::json json{};
  json[&quot;value&quot;] = 42;
  json[&quot;array&quot;] = std::array{1, 2, 3};
  std::cout &lt;&lt; json.dump(); // prints {&quot;array&quot;:[1,2,3],&quot;value&quot;:42}
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cfs9Ycsh8">https://godbolt.org/z/cfs9Ycsh8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>to_json</code> function which converts a given tuple of named fields into <code>nlohmann::json</code> object?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto&amp;); // TODO

template &lt;class T&gt;
struct named {
  std::string_view name{};
  T value{};
};

int main() {
  using namespace boost::ut;

  &quot;to json&quot;_test = [] {
    &quot;value&quot;_test = [] {
      const auto json = to_json(std::tuple{named{.name = &quot;int&quot;, .value = 1}});
      expect(1_i == json[&quot;int&quot;].get&lt;int&gt;());
    };

    &quot;array&quot;_test = [] {
      const auto json = to_json(
          std::tuple{named{.name = &quot;array&quot;, .value = std::array{1, 2}}});
      expect(std::array{1, 2} == json[&quot;array&quot;].get&lt;std::array&lt;int, 2&gt;&gt;());
    };

    &quot;complex&quot;_test = [] {
      const auto json = to_json(std::tuple{
          named{.name = &quot;int&quot;, .value = 1},
          named{.name = &quot;double&quot;, .value = 2.0},
          named{.name = &quot;array&quot;, .value = std::array{1, 2, 3}},
          named{.name = &quot;compound&quot;,
                .value = std::tuple{named{.name = &quot;unsigned&quot;, .value = 42u}}}});

      expect(1_i == json[&quot;int&quot;].get&lt;int&gt;() and
             2._d == json[&quot;double&quot;].get&lt;double&gt;() and
             std::array{1, 2, 3} == json[&quot;array&quot;].get&lt;std::array&lt;int, 3&gt;&gt;() and
             42_u == json[&quot;compound&quot;][&quot;unsigned&quot;].get&lt;unsigned&gt;());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dfq8KxzKd">https://godbolt.org/z/dfq8KxzKd</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto&amp; to_json(const auto&amp; t) {
  return t;
}

template &lt;typename... Ts&gt;
constexpr auto to_json(const std::tuple&lt;Ts...&gt;&amp; t) {
  return std::apply([] (const auto&amp;... ts) {
    nlohmann::json obj{};
    ((obj[std::string{ts.name}] = to_json(ts.value)), ...);
    return obj;
  }, t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TxYT46Pb1">https://godbolt.org/z/TxYT46Pb1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto&amp; value) { return value; }

template &lt;typename... Ts&gt;
constexpr auto to_json(const std::tuple&lt;Ts...&gt;&amp; tuple) {
  nlohmann::json output;
  std::apply(
      [&amp;output](const auto&amp;... args) {
        (..., [&amp;output](const auto&amp; arg) {
          output[std::string{arg.name}] = to_json(arg.value);
        }(args));
      },
      tuple);
  return output;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Kaq4G7hcK">https://godbolt.org/z/Kaq4G7hcK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto&amp; value) -&gt; decltype(auto) {
  return value;
}

template &lt;typename... Ts&gt;
constexpr auto to_json(std::tuple&lt;Ts...&gt; const&amp; tuple) {
    nlohmann::json json{};
    std::apply([&amp;] (auto const&amp;... named) {
        ((json[std::string{named.name}] = to_json(named.value)), ...);
    }, tuple);
    return json;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v7bson4Tx">https://godbolt.org/z/v7bson4Tx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto&amp; v) { return v; }
template &lt;class... Ts&gt;
constexpr auto to_json(const std::tuple&lt;Ts...&gt;&amp; t) {
  nlohmann::json o{};
  (..., (o[std::string{std::get&lt;Ts&gt;(t).name}] = to_json(std::get&lt;Ts&gt;(t).value)));
  return o;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jfn8Esac6">https://godbolt.org/z/jfn8Esac6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto to_json(const T&amp; t) { return t; }

template&lt;class ...T&gt;
constexpr auto to_json(const std::tuple&lt;named&lt;T&gt;...&gt;&amp; tup) {
    nlohmann::json json{};
    [&amp;json, &amp;tup] &lt;auto ...Id&gt; (std::index_sequence&lt;Id...&gt; const&amp;) {
        ( (json[std::string(std::get&lt;Id&gt;(tup).name).c_str()] = to_json( std::get&lt;Id&gt;(tup).value)), ...);
    }(std::make_index_sequence&lt;sizeof...(T)&gt;{});
    return json;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1hKKeGdzc">https://godbolt.org/z/1hKKeGdzc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json( auto const &amp; arg){ return arg; }
template&lt;class T&gt;
constexpr std::tuple&lt;const char*,decltype(to_json(T{}))&gt; to_json( named&lt;T&gt; const &amp; arg)
{
    return {arg.name.data(),to_json(arg.value)};
}
template&lt;class ... T&gt;
constexpr auto to_json(std::tuple&lt; named&lt;T&gt; ... &gt; const &amp; arg)
{
    return std::apply( []( auto const &amp; ...args ){ return nlohmann::json{to_json(args)...}; },arg);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vcf4361Ta">https://godbolt.org/z/vcf4361Ta</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto to_json(const auto &amp; value) {
    return value;
}

template&lt;class ...T&gt; constexpr auto to_json(const std::tuple&lt;named&lt;T&gt;...&gt;&amp; tp) {
    nlohmann::json json{};

    std::apply([&amp;](const auto&amp;... n)
    {
        ((json[std::string{n.name}] = to_json(n.value)), ...);
   }, tp);

    return json;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9TqE9zr3T">https://godbolt.org/z/9TqE9zr3T</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>222 - Did you know that C++23 added `contains` function to `string_view`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/222.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/222.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>contains</code> function to <code>string_view</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1679">http://wg21.link/p1679</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  using std::literals::string_view_literals::operator&quot;&quot;sv;
  std::cout &lt;&lt; &quot;trade.price&quot;sv.contains(&quot;order&quot;); // prints 0
  std::cout &lt;&lt; &quot;trade.price&quot;sv.contains(&quot;&quot;);      // prints 1
  std::cout &lt;&lt; &quot;trade.price&quot;sv.contains(&quot;price&quot;); // prints 1
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jqoWq36Pe">https://godbolt.org/z/jqoWq36Pe</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>values</code> function which returns the sum of values that contains the given name?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto in, auto str); // TODO

using std::literals::string_view_literals::operator&quot;&quot;sv;

static_assert(0 == values(std::tuple{}, &quot;&quot;sv));
static_assert(0 == values(std::tuple{}, &quot;price&quot;sv));
static_assert(0 == values(std::tuple{}, &quot;size&quot;sv));

constexpr auto prices = std::tuple{std::pair{&quot;trade.price&quot;sv, 123.456}, std::pair{&quot;order.price&quot;sv, 42.}};
static_assert(0. == values(prices, &quot;&quot;sv));
static_assert(0. == values(prices, &quot;unknown&quot;sv));
static_assert(0. == values(prices, &quot;size&quot;sv));
static_assert(123.456 + 42.  == values(prices, &quot;price&quot;sv));

constexpr auto sizes = std::tuple{std::pair{&quot;trade.size&quot;sv, 42}, std::pair{&quot;trade.id&quot;sv, 100}, std::pair{&quot;order.size&quot;sv, 99}};
static_assert(0 == values(sizes, &quot;&quot;sv));
static_assert(0 == values(sizes, &quot;unknown&quot;sv));
static_assert(42 + 99 == values(sizes, &quot;size&quot;sv));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/696x6KP4E">https://godbolt.org/z/696x6KP4E</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">consteval auto values(const auto&amp; t, const auto str) {
  const auto value_for = [&amp;] (const auto&amp; p) {
    const auto&amp; [name, value] = p;
    return not std::empty(str) and name.contains(str) ? value : decltype(value){};
  };
  return std::apply([&amp;] (auto&amp;&amp;... elems) {
    return (value_for(elems) + ... + 0);
  }, t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e8o86sxo1">https://godbolt.org/z/e8o86sxo1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto in, auto str)
{
    return std::apply( [&amp;str](auto ... args ){
        return ( ( !str.empty() &amp;&amp; args.first.contains(str) ? args.second : 0 ) + ... + 0) ;
    }, in );
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9Yf8q1EGn">https://godbolt.org/z/9Yf8q1EGn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto in, auto str) {
  return std::apply(
      [&amp;](const auto&amp;... args) {
        return (([&amp;] {
                  if (const auto&amp; [name, value] = args;
                      not std::empty(str) and name.contains(str))
                    return value;
                  else
                    return decltype(value){};
                }()) +
                ... + 0);
      },
      in);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gqh3z81Yr">https://godbolt.org/z/Gqh3z81Yr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto value(auto in, auto str) {
  if constexpr (requires {
                  in.first;
                  in.second;
                  in.first.contains(str);
                  std::empty(str);
                }) {
    if (not std::empty(str) and in.first.contains(str)) {
      return in.second;
    } else {
        return decltype(in.second){};
    }
  } else {
    return 0;
  }
};

consteval auto values(auto in, auto str) {
  return std::apply(
      [&amp;str](const auto&amp;... items) { return (value(items, str) + ... + 0); },
      in);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qEq3653nf">https://godbolt.org/z/qEq3653nf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto const&amp; tuple, auto const strv) noexcept {
  const auto check_pairs = [=](auto const&amp; pair) {
    if (std::empty(strv) or pair.first.find(strv) == std::string_view::npos) {
        return decltype(pair.second){};
    }
    return pair.second;
  };

  return std::apply([&amp;] (auto const&amp;... pairs) {
    return (check_pairs(pairs) + ... + 0);
  }, tuple);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hTK517PW8">https://godbolt.org/z/hTK517PW8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto in, auto str)
{
    return std::apply([&amp;](auto... vs) -&gt; decltype((0 + ... + vs.second))
    {
        return str.empty() ? 0 : (0 + ... + (vs.first.contains(str) ? vs.second : 0));
    }, in);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8xev5GTPz">https://godbolt.org/z/8xev5GTPz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(auto in, auto str){
    const auto value = [&amp;](const auto&amp; arg){
        const auto [arg_str, arg_val] = arg;
        const auto default_val = decltype(arg_val){};
        return not std::empty(str) and arg_str.contains(str) ? arg_val : default_val;
    };

    return std::apply([&amp;] (auto... args){
        return (value(args) + ... + 0);
    },in);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nEsen5Ydh">https://godbolt.org/z/nEsen5Ydh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">consteval auto values(const auto tup, const auto key){
    if constexpr (std::tuple_size_v&lt;decltype(tup)&gt; == 0)
    {
        return 0.;
    }
    else
    {
       const auto get_value=[&amp;](const auto pair)
       {
            const auto [name, value] = pair;
            if (not std::empty(key) and name.contains(key))
            {
                return value;
            }
            else return decltype(value){};
       };

         return std::apply(
              [get_value]( const auto... args ) {
                  return (get_value(args) + ...  );
              }
         ,tup);
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5bEx5oEzo">https://godbolt.org/z/5bEx5oEzo</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>221 - Did you know that with Automatic DI production wiring can be overwritten for integration testing?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/221.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/221.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that with Automatic DI production wiring can be overwritten for integration testing?</strong></p>
</li>
<li>
<p><a href="https://boost-ext.github.io/di/user_guide.html#di_bind">https://boost-ext.github.io/di/user_guide.html#di_bind</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

struct production_api : iapi { auto call() const -&gt; int override { return {}; } };
struct fake_api       : iapi { auto call() const -&gt; int override { return 42; } };

struct app {
  const iapi&amp; api;
};

int main() {
  auto production = boost::di::make_injector(
    boost::di::bind&lt;iapi&gt;.to&lt;production_api&gt;()
  );

  assert(0 == boost::di::create&lt;app&gt;(production).api.call());

  auto testing = boost::di::make_injector(
    std::move(production), // include all production bindings
    boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;() [ boost::di::override ]
  );

  assert(42 == boost::di::create&lt;app&gt;(testing).api.call());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cr597oPnY">https://godbolt.org/z/cr597oPnY</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>create</code> routine which construct type <code>T</code> with the production wiring overwritten by given fakes?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... TFakes&gt;
constexpr auto create(auto&amp;&amp; production, const TFakes&amp;... fakes) -&gt; T; // TODO

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Production vs Integration Testing&quot;) = [&amp;] {

      // Production wiring
      auto production = boost::di::make_injector(
        boost::di::bind&lt;iapi&gt;.to&lt;production_api&gt;()
      );

      steps.scenario(&quot;*&quot;) = [&amp;] {
        constexpr auto expected_result = 42_i;

        steps.given(&quot;I have an app&quot;) = [&amp;] {
          fakeit::Mock&lt;iapi&gt; fake_api{};
          fakeit::When(Method(fake_api, call)).Return(int(expected_result));
          auto sut = create&lt;app&gt;(production, fake_api.get());
          auto run_result = 0;

          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = sut.run();
          };

          steps.then(&quot;I should get an expected result&quot;) = [&amp;] {
            expect(run_result == expected_result);
          };
        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Production vs Integration Testing
        Scenario: Dependency Injection
          Given I have an app
           When I call run on the app
           Then I should get an expected result
   )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bdsqGrz73">https://godbolt.org/z/bdsqGrz73</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... TFakes&gt;
constexpr auto create(auto&amp;&amp; production, const TFakes&amp;... fakes) {
  return boost::di::create&lt;T&gt;(boost::di::make_injector(
    std::move(production),
    boost::di::bind&lt;TFakes&gt;.to(fakes) [ boost::di::override ] ...
  ));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9e7aqsPdM">https://godbolt.org/z/9e7aqsPdM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class TProduction, class... TFakes&gt;
constexpr auto create(TProduction&amp;&amp; production, const TFakes&amp;... fakes) -&gt; T {
  auto i = boost::di::make_injector(std::forward&lt;TProduction&gt;(production),
                                    boost::di::bind&lt;iapi&gt;.to(fakes)[boost::di::override]...);
  return boost::di::create&lt;T&gt;(std::move(i));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x1ze7r44d">https://godbolt.org/z/x1ze7r44d</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... TFakes&gt;
constexpr auto create(auto&amp;&amp; production, const TFakes&amp;... fakes) -&gt; T{
  auto testing = boost::di::make_injector(
    std::move(production), // include all production bindings
    boost::di::bind&lt;TFakes&gt;.to(fakes) [ boost::di::override ]...
  );
  return boost::di::create&lt;T&gt;(testing);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ojGzqK9Pf">https://godbolt.org/z/ojGzqK9Pf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... TFakes&gt;
constexpr auto create(auto&amp;&amp; production, const TFakes&amp;... fakes) -&gt; T
{
    auto testingInjector = boost::di::make_injector(
        //the production one
        std::move(production),
        //when we see something that can take a TFake use the one passed in
        boost::di::bind&lt;TFakes&gt;.to(fakes) [ boost::di::override ]...
    );
    return boost::di::create&lt;T&gt;(testingInjector);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Kfqsz9hrr">https://godbolt.org/z/Kfqsz9hrr</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>220 - Did you know that with Automatic DI one can control how dependencies are being created?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/220.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/220.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that with Automatic DI one can control how dependencies are being created?</strong></p>
</li>
<li>
<p><a href="https://boost-ext.github.io/di/user_guide.html#configuration">https://boost-ext.github.io/di/user_guide.html#configuration</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class app {
 public:
  explicit(true) app(int, double) { }
};

struct config : boost::di::config {
  struct mocks {
    template &lt;class T, class TInitialization, class TMemory, class... TArgs&gt;
    auto get(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const
      -&gt; boost::di::aux::owner&lt;T*&gt; {
      std::clog &lt;&lt; typeid(T).name() &lt;&lt; '\n';
      return new T{args...};
    }
  };

  auto provider(...) const { return mocks{}; }
};

int main() {
  boost::di::create&lt;app&gt;(boost::di::make_injector&lt;config&gt;()); // prints app
                                                                        int
                                                                        double
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TnY9c9qva">https://godbolt.org/z/TnY9c9qva</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement Automatic Mocks Provider which will create mocks for polymorhpic types (using FakeIt)?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct mocks_provider : boost::di::config {
  struct mocks {
    template &lt;class...&gt; using is_creatable = std::true_type;

    template &lt;class T, class TInitialization, class TMemory, class... TArgs&gt;
    auto get(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const
      -&gt; boost::di::aux::owner&lt;T*&gt;; // TODO, creates mocks for polymorphic types
    template&lt;class T&gt; auto&amp; mock(); // TODO, returns mock for a given type
  };

  auto provider(...) const { return mocks{}; }
};

int main() {
  class iapi {
  public:
    virtual ~iapi() = default;
    virtual auto call() const -&gt; int = 0;
  };

  class app {
  public:
    constexpr explicit(true) app(const iapi&amp; api) : api_{api} {}
    constexpr auto run() -&gt; int { return api_.call(); }

  private:
    const iapi&amp; api_;
  };

  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Automatic Mocks Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        constexpr auto expected_result = 100_i;

        steps.given(&quot;I have an app&quot;) = [&amp;] {
          auto run_result = 0;
          auto [sut_, mocks] = make&lt;app&gt;();
          auto&amp; sut = sut_;
          fakeit::When(Method(mocks.mock&lt;iapi&gt;(), call)).Return(int(expected_result));

          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = sut.run();
          };

          steps.then(&quot;I should get an expected result&quot;) = [&amp;] {
            expect(expected_result == run_result);
          };
        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Automatic Mocks Injection
        Scenario: Dependency Injection
          Given I have an app
           When I call run on the app
           Then I should get an expected result
   )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wvh3hrPzd">https://godbolt.org/z/Wvh3hrPzd</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct mocks_provider : boost::di::config {
  struct mocks {
    template &lt;class...&gt; using is_creatable = std::true_type;

    template &lt;class T, class TInitialization, class TMemory, class... TArgs&gt;
    auto get(const TInitialization&amp;, const TMemory&amp;, [[maybe_unused]] TArgs&amp;&amp;... args) const
      -&gt; boost::di::aux::owner&lt;T*&gt; {
      if constexpr (std::is_abstract_v&lt;T&gt;) {
        the_mock_ = std::make_shared&lt;fakeit::Mock&lt;T&gt;&gt;();
        return std::addressof(mock&lt;T&gt;().get());
      } else {
        return new T{std::forward&lt;TArgs&gt;(args)...};
      }
    }

    template &lt;class T&gt; auto&amp; mock() const {
      return *static_cast&lt;fakeit::Mock&lt;T&gt;*&gt;(the_mock_.get());
    }

    private:
      // using shared_ptr here for the type-erased destructor
      static inline std::shared_ptr&lt;void&gt; the_mock_;
  };

  auto provider(...) const { return mocks{}; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5qv18888j">https://godbolt.org/z/5qv18888j</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct mocks_provider : boost::di::config {
  struct mocks {
    template &lt;class...&gt; using is_creatable = std::true_type;
    static inline std::shared_ptr&lt;void&gt; ptr;

    template &lt;class T, class TInitialization, class TMemory, class... TArgs&gt;
    auto get(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const
      -&gt; boost::di::aux::owner&lt;T*&gt;{
      if constexpr ( requires(T*t){ {t-&gt;call()}-&gt; std::same_as&lt;int&gt;;} )
      {
        auto * raw_ptr = new fakeit::Mock&lt;T&gt;;
        ptr.reset(raw_ptr);
        return reinterpret_cast&lt;T*&gt;(&amp;raw_ptr-&gt;get());
      } else {
        return new T{args...};
      }
    }

    template&lt;class T&gt; auto&amp; mock()
    {
        return *(reinterpret_cast&lt;fakeit::Mock&lt;T&gt;*&gt;(ptr.get()));
    }
  };

  auto provider(...) const { return mocks{}; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h1avYT7T4">https://godbolt.org/z/h1avYT7T4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct mocks_provider : boost::di::config {
  struct mocks {
    template &lt;class T, class TInitialization, class TMemory, class... TArgs&gt;
    auto get(const TInitialization&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const -&gt; boost::di::aux::owner&lt;T*&gt; {
      if constexpr (std::is_polymorphic_v&lt;T&gt;) {
        auto mock = std::make_shared&lt;fakeit::Mock&lt;T&gt;&gt;();
        mock_ = mock;
        return std::addressof(mock-&gt;get());
      } else {
        return new T{args...};
      }
    }

    template &lt;class...&gt;
    using is_creatable = std::true_type;

    template&lt;class T&gt;
    auto&amp; mock() {
      return *std::static_pointer_cast&lt;fakeit::Mock&lt;T&gt;&gt;(mock_);
    }

    static inline std::shared_ptr&lt;void&gt; mock_{};
  };

  auto provider(...) const { return mocks{}; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bjhqvEThs">https://godbolt.org/z/bjhqvEThs</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>219 - Did you know about Automatic Dependency Injection libraries such as DI?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/219.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/219.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about Automatic Dependency Injection libraries such as DI?</strong></p>
</li>
<li>
<p><a href="https://github.com/boost-ext/di">https://github.com/boost-ext/di</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

template&lt;class T1 = class iapi, // NOTE: class iapi for template injection
           api T2 = class iapi&gt; // NOTE: class iapi for concepts injection
struct app {
  constexpr app(const T1&amp; t1, const T2&amp; t2, const iapi&amp; t3) { // NOTE: iapi for interface injection
    assert(42 == t1.call() and 42 == t2.call() and 42 == t3.call());
  }
};

int main() {
  struct fake_api : iapi {
    auto call() const -&gt; int { return 42; }
  };

  const auto injector = boost::di::make_injector(
    boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;() // bind iapi to fake_api
  );

  boost::di::create&lt;app&gt;(injector); // return an app
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jEGK1z3nT">https://godbolt.org/z/jEGK1z3nT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement required steps with Automatic Dependency Injection using DI library?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface;
template&lt;class TApi /*= TODO*/&gt; class app_template;
template&lt;api TApi /*= TODO*/&gt; class app_concept;

class fake_api : public iapi {
 public:
  constexpr explicit(true) fake_api(const int&amp; value)
   : value{value}
  { }

  auto call() const -&gt; int override { return value; }

 private:
  const int&amp; value{};
};

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {

          const auto injector = boost::di::make_injector(
            // TODO
          );

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5jqnaGsnE">https://godbolt.org/z/5jqnaGsnE</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface{
    const iapi&amp; api_;
public:
    app_interface(const iapi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

template&lt;class TApi = iapi&gt; class app_template {
    const TApi&amp; api_;
public:
    app_template(const TApi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

template&lt;api TApi = iapi&gt; class app_concept {
    const TApi&amp; api_;
public:
    app_concept(const TApi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

class fake_api : public iapi {
 public:
  constexpr explicit(true) fake_api(const int&amp; value)
   : value{value}
  { }

  auto call() const -&gt; int override { return value; }

 private:
  const int&amp; value{};
};

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {

          const auto injector = boost::di::make_injector(
            boost::di::bind&lt;int&gt;.to(value),
            boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;()
          );

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            const auto&amp; app = boost::di::create&lt;app_interface&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            const auto&amp; app = boost::di::create&lt;app_template&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            const auto&amp; app = boost::di::create&lt;app_concept&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r4K8cfaYh">https://godbolt.org/z/r4K8cfaYh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface {
public:
  constexpr explicit(true) app_interface(const iapi&amp; a) : api_{a} {}
  const auto run() const { return api_.call(); }
private:
  const iapi&amp; api_;
};

template &lt;class TApi = iapi&gt; class app_template {
public:
  constexpr explicit(true) app_template(const TApi&amp; a) : api_{a} {}
  const auto run() const { return api_.call(); }
private:
  const TApi&amp; api_;
};

template &lt;api TApi = iapi&gt; using app_concept = app_template&lt;TApi&gt;;

class fake_api : public iapi {
 public:
  constexpr explicit(true) fake_api(const int&amp; value)
   : value{value}
  { }

  auto call() const -&gt; int override { return value; }

 private:
  const int&amp; value{};
};

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
          const auto injector = boost::di::make_injector(
            boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;(),
            boost::di::bind&lt;int&gt;.to(value)
          );

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            const auto app = boost::di::create&lt;app_interface&gt;(injector);
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            const auto app = boost::di::create&lt;app_template&gt;(injector);
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            const auto app = boost::di::create&lt;app_concept&gt;(injector);
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c8YYsaMGj">https://godbolt.org/z/c8YYsaMGj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface {
public:
    app_interface(iapi&amp; iapi) : _iapi(iapi) {}
    int run() { return _iapi.call(); }
private:
    iapi&amp; _iapi;
};

template&lt;class TApi = class iapi&gt; class app_template {
public:
    app_template(TApi&amp; tapi) : _tapi(tapi) {}
    int run() { return _tapi.call(); }
private:
    TApi&amp; _tapi;
};

template&lt;api TApi = class iapi&gt; class app_concept {
public:
    app_concept(TApi&amp; tapi) : _tapi(tapi) {}
    int run() { return _tapi.call(); }
private:
    TApi&amp; _tapi;
};

class fake_api : public iapi {
 public:
  constexpr explicit(true) fake_api(const int&amp; value)
   : value{value}
  { }

  auto call() const -&gt; int override { return value; }

 private:
  const int&amp; value{};
};

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {

          const auto injector = boost::di::make_injector(
            boost::di::bind&lt;int&gt;.to(value),
            boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;()
          );

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            app_interface app(boost::di::create&lt;app_interface&gt;(injector));
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            app_template app(boost::di::create&lt;app_template&gt;(injector));
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            app_concept app(boost::di::create&lt;app_concept&gt;(injector));
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MMqGPq8Po">https://godbolt.org/z/MMqGPq8Po</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface
{
    public:
    app_interface( iapi const &amp; p_api ):m_api(p_api){}
    auto run(){ return m_api.call();}
    iapi const &amp; m_api;
};
template&lt;class TApi&gt; class app_template
{
    public:
    app_template(TApi const &amp; p_api):m_api(p_api){}
    auto run(){ return m_api.call();}
    TApi const&amp; m_api;
};
template&lt;api TApi&gt;   class app_concept
{
    public:
    app_concept(TApi const &amp; p_api):m_api(p_api){}
    auto run(){ return m_api.call();}
    TApi const&amp; m_api;
};

class fake_api : public iapi {
 public:
  constexpr explicit(true) fake_api(const int&amp; value)
   : value{value}
  { }

  auto call() const -&gt; int override { return value; }

 private:
  const int&amp; value{};
};

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {

          const auto injector = boost::di::make_injector(
            boost::di::bind&lt;iapi&gt;.to&lt;fake_api&gt;(),
            boost::di::bind&lt;int&gt;.to(value)
          );

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            auto app = boost::di::create&lt;app_interface&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            auto app = boost::di::create&lt;app_template&lt;fake_api&gt;&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            auto app = boost::di::create&lt;app_concept&lt;fake_api&gt;&gt;(injector);

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4GjhTGrEa">https://godbolt.org/z/4GjhTGrEa</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>218 - Did you know about different ways of constructor Dependency Injection?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/218.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/218.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about different ways of constructor Dependency Injection?</strong></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Dependency_injection">https://en.wikipedia.org/wiki/Dependency_injection</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int { return 42; }
};

class app_interface {
 public:
  constexpr explicit(true) app_interface(const iapi&amp; api) : api_{api} {}
  auto run() const -&gt; int { return api_.call(); }

 private:
  const iapi&amp; api_;
};

template&lt;class TApi&gt;
class app_template {
 public:
  constexpr explicit(true) app_template(const TApi&amp; api) : api_{api} {}
  auto run() const -&gt; int { return api_.call(); }

 private:
  const TApi&amp; api_;
};

template&lt;class T&gt;
concept api = requires(T t) {
  t.call();
};

template&lt;api TApi&gt;
class app_concept {
 public:
  constexpr explicit(true) app_concept(const TApi&amp; api) : api_{api} {}
  auto run() const -&gt; int { return api_.call(); }

 private:
  const TApi&amp; api_;
};

int main() {
  // interface injection
  {
    struct : iapi {
      auto call() const -&gt; int override { return 42; }
    } fake_api;
    app_interface app{fake_api};
    assert(42 == app.run());
  }

  // template injection
  {
    iapi api{};
    app_template app{api};
    assert(42 == app.run());
  }

  // concept injection
  {
    iapi api{};
    app_concept app{api};
    assert(42 == app.run());
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qM85TT186">https://godbolt.org/z/qM85TT186</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement required steps with injecting <code>api</code> via {interface, template, concept}?</strong></p>
</li>
<li>
<p>Double points for injection via type erasure!</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">class iapi {
 public:
  virtual ~iapi() = default;
  virtual auto call() const -&gt; int = 0;
};

template&lt;class T&gt;
concept api = requires(const T&amp; t) {
  { t.call() } -&gt; std::same_as&lt;int&gt;;
};

class app_interface;                     // TODO
template&lt;class TApi&gt; class app_template; // TODO
template&lt;api TApi&gt;   class app_concept;  // TODO

// NOTE: Double points for injection via type erasure!

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
          // TODO

          steps.given(&quot;I have an app interface&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app template&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

          steps.given(&quot;I have an app concept&quot;) = [&amp;] {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              run_result = app.run();
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };

        };
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Dependency Injection
        Scenario: Via interface
          Given I have an api which returns 10
          Given I have an app interface
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Via template
          Given I have an api which returns 100
          Given I have an app template
           When I call run on the app
           Then I should get 100 from app call
        Scenario: Via concept
          Given I have an api which returns 1000
          Given I have an app concept
           When I call run on the app
           Then I should get 1000 from app call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YsGzxodMc">https://godbolt.org/z/YsGzxodMc</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">class app_interface{
    const iapi&amp; api_;
public:
    app_interface(const iapi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

template&lt;class TApi&gt; class app_template {
    const TApi&amp; api_;
public:
    app_template(const TApi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

template&lt;api TApi&gt; class app_concept {
    const TApi&amp; api_;
public:
    app_concept(const TApi&amp; api) : api_{api} {}
    auto run() const {
        return api_.call();
    }
};

class app_erasure {
    const std::any api_;
public:
    app_erasure(const auto&amp; api) : api_{api} {}
    auto run() const {
        return std::any_cast&lt;const iapi&amp;&gt;(api_).call();
    }
};

struct fake_api : iapi {
    fake_api(int value):value_{value}{}
    int value_{};
    virtual int call() const override {
        return value_;
    }
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
        const fake_api fake_{value};

        steps.given(&quot;I have an app interface&quot;) = [&amp;] {
          const app_interface app{fake_};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app template&quot;) = [&amp;] {
          const app_template&lt;fake_api&gt; app{fake_};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app concept&quot;) = [&amp;] {
          const app_concept&lt;fake_api&gt; app{fake_};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app app erasure&quot;) = [&amp;] {
          const app_erasure app{fake_};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result+1 == result);
          };
        };

      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xhc3MfsbG">https://godbolt.org/z/xhc3MfsbG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class app_interface
{
    public:
    app_interface( iapi const &amp; p_api ):m_api(p_api){}
    auto run(){ return m_api.call();}
    iapi const &amp; m_api;
};
template&lt;class TApi&gt; class app_template
{
    public:
    app_template(TApi const &amp; p_api):m_api(p_api){}
    auto run(){ return m_api.call();}
    TApi const&amp; m_api;
};
template&lt;api TApi&gt;   class app_concept
{
    public:
    app_concept(TApi const &amp; p_api):m_api(p_api){}
    auto run(){ return m_api.call();}
    TApi const&amp; m_api;
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
        struct fake_api:public iapi
        {
            fake_api(int v):v(v){}
            int call() const override{ return v; }
            int v;
        };
        fake_api my_api(value);

        steps.given(&quot;I have an app interface&quot;) = [&amp;] {
          app_interface app{my_api};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app template&quot;) = [&amp;] {

          app_template app{my_api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app concept&quot;) = [&amp;] {

          app_concept app{my_api};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5TKdca8v4">https://godbolt.org/z/5TKdca8v4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class app_interface {
public:
  app_interface(const iapi&amp; a) : api_{a} {}
  const auto run() const { return api_.call(); }
private:
  const iapi&amp; api_;
};

template &lt;api TApi&gt; class app_template {
public:
  app_template(const TApi&amp; a) : api_{a} {}
  const auto run() const { return api_.call(); }
private:
  const TApi&amp; api_;
};

class app_concept {
public:
  template &lt;api TApi&gt;
  app_concept(const TApi&amp; a) : api_{std::make_unique&lt;erased_api&lt;TApi&gt;&gt;(a)} {}
  const auto run() const { return api_-&gt;call(); }

private:
  template &lt;api TApi&gt;
  struct erased_api : iapi {
    erased_api(const TApi&amp; a) : api_{a} {}
    auto call() const -&gt; int override { return api_.call(); }
    TApi api_;
  };

  std::unique_ptr&lt;iapi&gt; api_;
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
        struct local_api : iapi {
          local_api(int value) : value_{value} {}
          auto call() const -&gt; int override { return value_; }
          int value_;
        } a{value};

        steps.given(&quot;I have an app interface&quot;) = [&amp;] {
          const auto app = app_interface{a};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app template&quot;) = [&amp;] {
          const auto app = app_template{a};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app concept&quot;) = [&amp;] {
          const auto app = app_concept{a};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6bnjW6M91">https://godbolt.org/z/6bnjW6M91</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">class app_interface {
public:
    constexpr explicit(true) app_interface(const iapi&amp; api) : api_{api} {}
    auto run() const -&gt; int { return api_.call(); }
private:
    const iapi&amp; api_;
};

template&lt;class TApi&gt; class app_template {
public:
    constexpr explicit(true) app_template(const TApi&amp; api) : api_{api} {}
    auto run() const -&gt; int {return api_.call(); }
private:
    const TApi&amp; api_;
};

template&lt;api TApi&gt;   class app_concept {
public:
    constexpr explicit(true) app_concept(const TApi&amp; api) : api_{api} {}
    auto run() const -&gt; int { return api_.call(); }
private:
    const TApi&amp; api_;
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Dependency Injection*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an api which returns {}&quot;) = [&amp;](int value) {
         api1 myApi(value);
        steps.given(&quot;I have an app interface&quot;) = [&amp;] {
          app_interface app(myApi);
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app template&quot;) = [&amp;] {
          app_template app(myApi);
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

        steps.given(&quot;I have an app concept&quot;) = [&amp;] {
          app_concept app(myApi);
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };

      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cxP4dc8EE">https://godbolt.org/z/cxP4dc8EE</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>217 - Did you know the difference between fakes, stubs, mocks?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/217.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/217.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know the difference between fakes, stubs, mocks?</strong></p>
</li>
<li>
<p><a href="https://martinfowler.com/articles/mocksArentStubs.html">https://martinfowler.com/articles/mocksArentStubs.html</a></p>
<ul>
<li>Fake - an object with limited capabilities</li>
<li>Stub - an object that provides predefined answers to method calls and record calls</li>
<li>Mock - an object on which you set expectations which are verified by itself</li>
</ul>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">class api {
 public:
  virtual ~api() = default;
  virtual auto call() const -&gt; int { return {}; }
};

struct fake_api final : api {
  auto call() const -&gt; int override { return 42; }
};

struct stub_api final : api {
  int call_value{};
  auto call() const -&gt; int override { ++call_calls; return call_value; }
  mutable int call_calls{};
};

int main() {
  {
    fake_api api{};
    assert(42 == api.call());
  }

  {
    stub_api api{};
    assert(0 == api.call_calls);
    api.call_value = 43;
    assert(43 == api.call());
    assert(1 == api.call_calls);
  }

  {
    fakeit::Mock&lt;api&gt; api{};
    fakeit::When(Method(api, call)).Return(43);
    auto &amp;mock_api = api.get();
    assert(43 == mock_api.call());
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cWaeeE">https://godbolt.org/z/cWaeeE</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement required steps with faking api with {stub, fake, mock}?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">class api {
 public:
  virtual ~api() = default;
  virtual auto call() const -&gt; int = 0;
};

class app;       // TODO
struct fake_api; // TODO
struct stub_api; // TODO

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Singleton*&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        const auto fake_api_steps = [&amp;](int value) {
          // TODO
          steps.given(&quot;I have an app&quot;) = [&amp;] {
            // TODO
            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              // TODO
            };
            steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };
        };

        const auto stub_api_steps = [&amp;](int value) {
          // TODO
          steps.given(&quot;I have an app2&quot;) = [&amp;] {
            // TODO
            auto run_result = 0;
            steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
              // TODO
            };
            steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };
          // TODO
        };

        const auto mock_api_steps = [&amp;](int value) {
          // TODO
          steps.given(&quot;I have an app3&quot;) = [&amp;] {
            // TODO
            auto run_result = 0;
            steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
              // TODO
            };
            steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };
        };

        steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
        steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
        steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
      };
    };
  };

  &quot;app&quot;_test = steps | R&quot;(
      Feature: Singleton
        Scenario: Dependency Injection
          Given I have a fake_api which returns 10
          Given I have an app
           When I call run on the app
           Then I should get 10 from app call
        Scenario: Dependency Injection
          Given I have a stub_api which returns 100
          Given I have an app2
           When I call run on the app2
           Then I should get 100 from app2 call
        Scenario: Dependency Injection
          Given I have a mock_api which returns 1000
          Given I have an app3
           When I call run on the app3
           Then I should get 1000 from app3 call
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9bcrd1">https://godbolt.org/z/9bcrd1</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct fake_api final : api {
  auto call() const -&gt; int override { return 10; }
};

struct stub_api final : api {
  int call_value{};
  auto call() const -&gt; int override { ++call_calls; return call_value; }
  mutable int call_calls{};
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      const auto fake_api_steps = [&amp;](int value) {
        auto api = fake_api{};
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto stub_api_steps = [&amp;](int value) {
        auto api = stub_api{};
        expect(0_i == api.call_calls);
        api.call_value = value;
        steps.given(&quot;I have an app2&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
        expect(1_i == api.call_calls);
      };

      const auto mock_api_steps = [&amp;](int value) {
        fakeit::Mock&lt;api&gt; api{};
        fakeit::When(Method(api, call)).Return(value);
        steps.given(&quot;I have an app3&quot;) = [&amp;] {
          app app{api.get()};
          auto run_result = 0;
          steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
      steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
      steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5GxrMr">https://godbolt.org/z/5GxrMr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct fake_api : api {
    int call() const override { return 10; }
};
struct stub_api : api {
    int call() const override { calls++; return value; }
    int value;
    mutable int calls{0};
};
struct mock_api : api {
    int call() const override { return value; }
    int value;
    bool validate(){ return call() == value; }
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      const auto fake_api_steps = [&amp;](int value) {
        singleton&lt;fake_api&gt;::get();
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app1(singleton&lt;fake_api&gt;::get());
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app1.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto stub_api_steps = [&amp;](int value) {
        singleton&lt;stub_api&gt;::get().value = value;
        steps.given(&quot;I have an app2&quot;) = [&amp;] {
          app app2(singleton&lt;stub_api&gt;::get());
          auto run_result = 0;
          steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
            run_result = app2.run();
          };
          steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
        expect(singleton&lt;stub_api&gt;::get().calls ==1);
      };

      const auto mock_api_steps = [&amp;](int value) {
        singleton&lt;mock_api&gt;::get().value = value;
        expect( singleton&lt;mock_api&gt;::get().validate());
        steps.given(&quot;I have an app3&quot;) = [&amp;] {
          app app3(singleton&lt;mock_api&gt;::get());
          auto run_result = 0;
          steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
            run_result = app3.run();
          };
          steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
      steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
      steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/595dT6">https://godbolt.org/z/595dT6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct fake_api : api {
  virtual int call() const override { return 10; }
};
struct stub_api : api {
  virtual int call() const override { ++calls; return 100; }
  mutable int calls{};
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      const auto fake_api_steps = [&amp;](int value) {
        fake_api api;
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto stub_api_steps = [&amp;](int value) {
        stub_api api;
        steps.given(&quot;I have an app2&quot;) = [&amp;] {
          app app2{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
            run_result = app2.run();
          };
          steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
          steps.then(&quot;the api was called {} time&quot;) = [&amp;](_i num_calls) {
            expect(num_calls == api.calls);
          };
        };
      };

      const auto mock_api_steps = [&amp;](int value) {
        fakeit::Mock&lt;api&gt; api{};
        fakeit::When(Method(api, call)).Return(value);
        steps.given(&quot;I have an app3&quot;) = [&amp;] {
          app app3{api.get()};
          auto run_result = 0;
          steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
            run_result = app3.run();
          };
          steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
      steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
      steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dPW8v8">https://godbolt.org/z/dPW8v8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct fake_api final : api {
public:
  fake_api(int value) : value_{value} {}
  auto call() const -&gt; int override { return value_; }
  int value_;
};

struct stub_api final : api {
public:
  int call_value{};
  auto call() const -&gt; int override { ++call_calls; return call_value; }
  mutable int call_calls{};
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      const auto fake_api_steps = [&amp;](int value) {
        fake_api api{value};
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto stub_api_steps = [&amp;](int value) {
        stub_api api{};
        api.call_value = value;
        steps.given(&quot;I have an app2&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
          steps.then(&quot;app2 should have been called {} times&quot;) = [&amp;](_i calls) {
            expect(api.call_calls == calls);
          };
        };
      };

      const auto mock_api_steps = [&amp;](int value) {
        fakeit::Mock&lt;api&gt; mock;
        fakeit::When(Method(mock, call)).Return(value);
        steps.given(&quot;I have an app3&quot;) = [&amp;] {
          app app{mock.get()};
          auto run_result = 0;
          steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
      steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
      steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8Mbsh1">https://godbolt.org/z/8Mbsh1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct fake_api final :public api
{
    int call() const override {return 10;}
};
struct stub_api final :public api
{
    int call() const override {return value;}
    int value;
};

bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton*&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      const auto fake_api_steps = [&amp;](int value) {
        fake_api f_api;
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app a{f_api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = a.run();
          };
          steps.then(&quot;I should get {} from app call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto stub_api_steps = [&amp;](int value) {
        stub_api s_api;
        s_api.value = value;
        steps.given(&quot;I have an app2&quot;) = [&amp;] {
          app a{s_api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app2&quot;) = [&amp;] {
            run_result = a.run();
          };
          steps.then(&quot;I should get {} from app2 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      const auto mock_api_steps = [&amp;](int value) {
        using namespace fakeit;
        Mock&lt;api&gt; mock;
        When(Method(mock,call)).Return(value);
        steps.given(&quot;I have an app3&quot;) = [&amp;] {
          app a{mock.get()};
          auto run_result = 0;
          steps.when(&quot;I call run on the app3&quot;) = [&amp;] {
            run_result = a.run();
          };
          steps.then(&quot;I should get {} from app3 call&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };

      steps.given(&quot;I have a fake_api which returns {}&quot;) = fake_api_steps;
      steps.given(&quot;I have a stub_api which returns {}&quot;) = stub_api_steps;
      steps.given(&quot;I have a mock_api which returns {}&quot;) = mock_api_steps;
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zvzW1s">https://godbolt.org/z/zvzW1s</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>216 - Did you know that you can inject singletons to improve testability?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/216.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/216.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that you can inject singletons to improve testability?</strong></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Singleton_pattern">https://en.wikipedia.org/wiki/Singleton_pattern</a></p>
</li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">https://en.wikipedia.org/wiki/Dependency_injection</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct singleton {
  static auto&amp; get() {
    static T s{};
    return s;
  }
};

class api {
 public:
  virtual ~api() = default;
  virtual auto call() const -&gt; int { return 42; }
};

class app {
 public:
  auto run() -&gt; int {
    return singleton&lt;api&gt;::get().call();
  }
};

class app_di {
 public:
  constexpr explicit(true) app_di(const api&amp; api)
    : api_{api}
  { }

  auto run() const -&gt; int {
    return api_.call();
  }

 private:
  const api&amp; api_;
};

int main() {
  {
    app a{}; // coupled
    assert(42 == a.run());
  }

  {
    app_di a{singleton&lt;api&gt;::get()}; // injected
    assert(42 == a.run())
  }

  {
    struct : api {
      auto call() const -&gt; int override { return 43; }
    } fake_api{};

    app_di api{fake_api}; // faked
    assert(43 == api.run());
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Phb9YE">https://godbolt.org/z/Phb9YE</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement required steps and the app to satisfy feature tests?</strong></p>
</li>
<li>
<p>NOTE: Feature test must remain as authored</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
struct singleton {
  static auto&amp; get() {
    static T s{};
    return s;
  }
};

class api {
 public:
  virtual ~api() = default;
  virtual auto call() const -&gt; int { return {}; }
};

class app; //TODO

int main() {
  using namespace boost::ut;

  bdd::gherkin::steps steps = [](auto&amp; steps) {
    steps.feature(&quot;Singleton&quot;) = [&amp;] {
      steps.scenario(&quot;*&quot;) = [&amp;] {
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          // TODO

          steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
            // TODO

            auto run_result = 0;
            steps.when(&quot;I call run on the app&quot;) = [&amp;] {
              // TODO
            };

            steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
              expect(run_result == result);
            };
          };
        };
      };
    };
  };

  // Feature tests must remain as authored
  &quot;app&quot;_test = steps | R&quot;(
      Feature: Singleton

        Scenario: Dependency Injection
          Given I have an app
          Given I have an fake_api which returns 42
           When I call run on the app
           Then I should get 42

        Scenario: Dependency Injection
          Given I have an app
          Given I have an fake_api which returns 100
           When I call run on the app
           Then I should get 100
    )&quot;;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xdq4WY">https://godbolt.org/z/xdq4WY</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an app&quot;) = [&amp;] {
        std::unique_ptr&lt;app&gt; app{};

        steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
          auto api = fake_api{value};
          app = std::make_unique&lt;class app&gt;(api);

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app-&gt;run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cz5s8q">https://godbolt.org/z/cz5s8q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        auto api = fake_api{value};
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app{api};
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xo8TsP">https://godbolt.org/z/xo8TsP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an app&quot;) = [&amp;] {
        app sut{};

        steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
          struct fake : api {
              fake(int value) : value(value), api{} {};
              int value{};
               auto call() const -&gt; int override {
                  return value;
              }
          } fake_api{ value };
          singleton&lt;api*&gt;::get() = &amp;fake_api;

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = sut.run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T69oEW">https://godbolt.org/z/T69oEW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        class FakeApi : public api {
          using value_t = int;

         public:
          constexpr FakeApi(const value_t val) : value(val) {}
          value_t call() const override { return value; }

         private:
          value_t value;
        } fake_api{value};

        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app app{fake_api};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MeexbT">https://godbolt.org/z/MeexbT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        struct fake_api {
          auto call() const -&gt; int { return value_; }
          auto set(int i) -&gt; void { value_ = i; }
          int value_;
        };
        singleton&lt;fake_api&gt;::get().set(value);
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app&lt;fake_api&gt; app;
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = app.run();
          };
          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jsn6G9">https://godbolt.org/z/jsn6G9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an app&quot;) = [&amp;] {
        app my_app{};

        steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
          singleton&lt;fake_api&gt;::get().value = value;

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = my_app.run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3n8bPv">https://godbolt.org/z/3n8bPv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        class fakeapi : public api {
           public:

           void set(const int value) { value_ = value; }
           auto call() const -&gt; int override { return value_; }

           private:
            int value_;
        };

        singleton&lt;fakeapi&gt;().get().set(value);

        steps.given(&quot;I have an app&quot;) = [&amp;] {
          singleton&lt;app&gt;().get().set(&amp;singleton&lt;fakeapi&gt;().get());

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = singleton&lt;app&gt;().get().run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7T3cnj">https://godbolt.org/z/7T3cnj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        apiI api1(value);
        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app myApp(api1);
          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
             run_result = myApp.run();
          };
          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q9Mo7o">https://godbolt.org/z/q9Mo7o</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">bdd::gherkin::steps steps = [](auto&amp; steps) {
  steps.feature(&quot;Singleton&quot;) = [&amp;] {
    steps.scenario(&quot;*&quot;) = [&amp;] {
      steps.given(&quot;I have an fake_api which returns {}&quot;) = [&amp;](int value) {
        singleton&lt;fake_api&gt;::get().value = value;

        steps.given(&quot;I have an app&quot;) = [&amp;] {
          app a{singleton&lt;fake_api&gt;::get()};

          auto run_result = 0;
          steps.when(&quot;I call run on the app&quot;) = [&amp;] {
            run_result = a.run();
          };

          steps.then(&quot;I should get {}&quot;) = [&amp;](_i result) {
            expect(run_result == result);
          };
        };
      };
    };
  };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fjzrfd">https://godbolt.org/z/fjzrfd</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>215 - Did you know C++2X Pattern Matching can be used for run-time dispatching?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/215.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/215.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know C++2X Pattern Matching can be used for run-time dispatching?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1371">http://wg21.link/p1371</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto...&gt; struct ids{};

template&lt;auto N, auto... Ns&gt;
auto dispatch(auto value, ids&lt;N, Ns...&gt;) -&gt; decltype(value) {
  return inspect (value) {
    N  =&gt; value;
    _  =&gt; [] {
      if constexpr (sizeof...(Ns) &gt; 0) {
        return dispatch(value, ids&lt;Ns...&gt;{});
      } else {
        return {};
      }
    }()
  };
}

int main() {
  std::cout &lt;&lt; dispatch(0, ids&lt;1, 2, 3&gt;{}); // prints 0
  std::cout &lt;&lt; dispatch(4, ids&lt;1, 2, 3&gt;{}); // prints 0

  std::cout &lt;&lt; dispatch(1, ids&lt;1, 2, 3&gt;{}); // prints 1
  std::cout &lt;&lt; dispatch(2, ids&lt;1, 2, 3&gt;{}); // prints 2
  std::cout &lt;&lt; dispatch(3, ids&lt;1, 2, 3&gt;{}); // prints 3
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6349xe">https://godbolt.org/z/6349xe</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement different run-time dispatching policies and apply them to process events?</strong></p>
</li>
<li>
<p>Policies ideas</p>
<ul>
<li>if/else</li>
<li>switch</li>
<li>inspect</li>
<li>fold expressions</li>
<li>jump table</li>
<li>goto table</li>
<li>...</li>
</ul>
</li>
<li>
<p>Double points for the most innovative policy</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template &lt;class TPolicy, class TMsg, class... Ts&gt;
concept dispatch_policy = requires(TPolicy policy, const TMsg&amp; msg,
                                   std::size_t&amp; state) {
  policy.template operator()&lt;Ts...&gt;(msg, state);
};

constexpr auto example_policy = []&lt;class... Ts&gt;(const auto&amp; msg, auto&amp; state) {
  /*TODO*/
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    /*TODO*/
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) { }

 private:
  std::size_t state_{};
};

template &lt;class TSrc, class TMsg, class TDst&gt;
struct transition {
  using src = TSrc;
  using msg = TMsg;
  using dst = TDst;
};

struct msg0 {};
struct msg1 {};
struct msg2 {};
struct msg3 {};
struct msg4 {};

int main() {
  using namespace boost::ut;

  &quot;state machine&quot;_test =
      [](const auto&amp; dispatch_policy) {
        sm sm{transition&lt;class State1, msg1, class State2&gt;{},
              transition&lt;class State2, msg2, class State1&gt;{}};

        should(&quot;state in the same state on unexpected message&quot;) = [&amp;] {
          expect(0_i == sm.process(msg0{}, dispatch_policy));
          expect(0_i == sm.process(msg2{}, dispatch_policy));
        };

        should(&quot;transition to destination state on expected message&quot;) = [&amp;] {
          expect(1_i == sm.process(msg1{}, dispatch_policy));
        };

        should(&quot;stay in the same state on unexpected message&quot;) = [&amp;] {
          expect(1_i == sm.process(msg0{}, dispatch_policy));
          expect(1_i == sm.process(msg1{}, dispatch_policy));
        };

        should(&quot;transition to source state on expected message&quot;) = [&amp;] {
          expect(0_i == sm.process(msg2{}, dispatch_policy));
        };
      }
      // policies
      | std::tuple{example_policy};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/obr4r3">https://godbolt.org/z/obr4r3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto example_policy = []&lt;class... Ts&gt;(const auto&amp; msg, auto&amp; state) {
  using states_t = boost::mp11::mp_unique&lt;
      boost::mp11::mp_list&lt;typename Ts::src..., typename Ts::dst...&gt;&gt;;
  (
      [&amp;state] {
        if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(msg)&gt;,
                                     typename Ts::msg&gt;) {
          if (state == boost::mp11::mp_find&lt;states_t, typename Ts::src&gt;{}) {
            state = boost::mp11::mp_find&lt;states_t, typename Ts::dst&gt;{};
          }
        }
      }(),
      ...);
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    policy.template operator()&lt;Transitions...&gt;(msg, state_);
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) {}

 private:
  int state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v4Ked7">https://godbolt.org/z/v4Ked7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto example_policy = []&lt;class... Ts&gt;(const auto&amp; msg, auto&amp; state){
    using states_t = boost::mp11::mp_unique&lt;boost::mp11::mp_list&lt;typename Ts::src..., typename Ts::dst...&gt;&gt;;
   ([&amp;state] {
      if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(msg)&gt;, typename Ts::msg&gt;) {
        if (state == boost::mp11::mp_find&lt;states_t, typename Ts::src&gt;{}) {
          state = boost::mp11::mp_find&lt;states_t, typename Ts::dst&gt;{};
        }
      }
    }(), ...);
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    policy.template operator()&lt;Transitions...&gt;(msg, state_);
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) {}

 private:
  std::size_t state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WG48Pv">https://godbolt.org/z/WG48Pv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto only_thursdays_policy = []&lt;class... TTransitions&gt;(const auto&amp; msg, auto&amp; state){
    using msg_t = std::decay_t&lt;decltype(msg)&gt;;
    ([&amp;] &lt;typename TTransition&gt; () {
      if constexpr (std::is_same_v&lt;msg_t, typename TTransition::msg&gt;) {
        if (boost::mp11::mp_find&lt;boost::mp11::mp_list&lt;TTransitions...&gt;, TTransition&gt;{} == state) {
          using namespace std::chrono;
          const auto d = floor&lt;days&gt;(system_clock::now());
          if (const year_month_weekday ymd{d}; ymd.weekday() == Thursday) {
            state = boost::mp11::mp_find&lt;boost::mp11::mp_list&lt;typename TTransitions::src...&gt;,
                                         typename TTransition::dst&gt;{};
            return true;
          }
        }
      }
      return false;
    }.template operator()&lt;TTransitions&gt;() or ...);
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    policy.template operator()&lt;Transitions...&gt;(msg, state_);
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) {}

private:
  std::size_t state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h9PWfa">https://godbolt.org/z/h9PWfa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto example_policy = []&lt;class... Ts&gt;(const auto&amp; msg, auto&amp; state){
  using Msgs = mp_list&lt;typename Ts::msg...&gt;;
  using MsgI = mp_find&lt;Msgs, std::remove_cvref_t&lt;decltype(msg)&gt;&gt;;

  if constexpr (mp_less&lt;MsgI, mp_size&lt;Msgs&gt;&gt;::value) {
    mp_with_index&lt;sizeof...(Ts)&gt;(state, [&amp;]&lt;class SrcI&gt;(const SrcI&amp;){
      if constexpr (mp_same&lt;SrcI, MsgI&gt;::value) {
        using Srcs = mp_list&lt;typename Ts::src...&gt;;
        using Dsts = mp_list&lt;typename Ts::dst...&gt;;
        using DstI = mp_at&lt;Dsts, MsgI&gt;;

        state = mp_find&lt;Srcs, DstI&gt;::value;
      }
    });
  }
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    policy.template operator()&lt;Transitions...&gt;(msg, state_);
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) {}

 private:
  std::size_t state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/exEYEE">https://godbolt.org/z/exEYEE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto example_policy = []&lt;class... Ts, class T&gt;(T const &amp; msg, auto &amp; state){
    return mp_with_index&lt;sizeof...(Ts)&gt;( state
                                       , [&amp;]( auto I ) {
                                           using TMsg = mp_at_c&lt;mp_list&lt;typename Ts::msg...&gt;,I&gt;;
                                           using TDst = mp_at_c&lt;mp_list&lt;typename Ts::dst...&gt;,I&gt;;
                                           return std::is_same_v&lt;T,TMsg&gt;? mp_find&lt;mp_list&lt;typename Ts::src...&gt;, TDst&gt;{}: state;
                                       });
};

template &lt;class... Transitions&gt;
struct sm {
  template &lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg,
                         dispatch_policy&lt;TMsg, Transitions...&gt; auto policy) {
    state_ = policy.template operator()&lt;Transitions...&gt; (msg,state_);
    return state_;
  }

  constexpr explicit(false) sm(const Transitions&amp;...) {}

 private:
  std::size_t state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v4oE8o">https://godbolt.org/z/v4oE8o</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>214 - Did you know about variadic aggregate initialization?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/214.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/214.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about variadic aggregate initialization?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/array.overview#:array,as_aggregate">http://eel.is/c++draft/array.overview#:array,as_aggregate</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct sm {
  template&lt;class T&gt;
  constexpr auto process() {
    return std::array{
      [] {
        if constexpr (std::is_same_v&lt;T, typename Ts::second_type&gt;) {
          return Ts::first_type::value;
        } else {
          return 0;
        }
     }()...
   };
 }
};

struct T0{};
struct T1{};
struct T2{};

static_assert(std::array{0, 0} == sm&lt;std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;{}.process&lt;T0&gt;());
static_assert(std::array{1, 0} == sm&lt;std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;{}.process&lt;T1&gt;());
static_assert(std::array{0, 2} == sm&lt;std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;{}.process&lt;T2&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9sT44a">https://godbolt.org/z/9sT44a</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a <code>State machine</code> with support for orthogonal regions which returns current states with the <code>process</code> call?</strong></p>
</li>
<li>
<p><a href="https://www.omg.org/spec/UML/2.5">https://www.omg.org/spec/UML/2.5</a></p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;...) {}
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
    /*TODO*/return std::array&lt;int, sizeof...(Transitions)&gt;{};
  }
};

template&lt;class TSrc, class TMsg, class TDst&gt;
struct transition {
  using src = TSrc;
  using msg = TMsg;
  using dst = TDst;
};

struct msg0{};
struct msg1{};
struct msg2{};
struct msg3{};
struct msg4{};

int main() {
  using namespace boost::ut;

  &quot;state machine with orthogonal regions&quot;_test = [] {
    sm sm{
      std::tuple{
        transition&lt;class State1, msg1, class State2&gt;{},
        transition&lt;class State2, msg2, class State1&gt;{},
      },
      std::tuple{
        transition&lt;class State1, msg3, class State2&gt;{},
        transition&lt;class State2, msg4, class State1&gt;{}
      }
    };

    should(&quot;state in the same state on unexpected message&quot;) = [&amp;] {
      expect(std::array{0, 0} == sm.process(msg0{}));
      expect(std::array{0, 0} == sm.process(msg2{}));
      expect(std::array{0, 0} == sm.process(msg4{}));
    };

    should(&quot;transition to destination state on expected message&quot;) = [&amp;] {
      expect(std::array{1, 0} == sm.process(msg1{}));
      expect(std::array{1, 1} == sm.process(msg3{}));
    };

    should(&quot;stay in the same state on unexpected message&quot;) = [&amp;] {
      expect(std::array{1, 1} == sm.process(msg0{}));
      expect(std::array{1, 1} == sm.process(msg1{}));
      expect(std::array{1, 1} == sm.process(msg3{}));
    };

    should(&quot;transition to source state on expected message&quot;) = [&amp;] {
      expect(std::array{0, 1} == sm.process(msg2{}));
      expect(std::array{0, 0} == sm.process(msg4{}));
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M7ra3b">https://godbolt.org/z/M7ra3b</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class Transitions&gt;
struct sm_single {
    constexpr explicit(false) sm_single(const Transitions&amp;) {}
    constexpr static std::size_t N = std::tuple_size_v&lt;Transitions&gt;;
    template&lt;class TMsg&gt;
    constexpr auto process(const TMsg&amp;) {
        [&amp;]&lt;auto ... Is &gt;( std::index_sequence&lt;Is...&gt; const &amp; )
        {
            ( [&amp;](){ using T = std::tuple_element_t&lt;Is,Transitions&gt;;
                     if( Is == current_state &amp;&amp; std::is_same_v&lt; typename T::msg , TMsg&gt;  )
                     {
                         // assuming we can find a state index that the src match this dst
                         std::size_t next_state = []&lt;auto ... Js &gt;( std::index_sequence&lt;Js...&gt; const &amp; ){
                             return ( [](){ if(std::is_same_v&lt; typename std::tuple_element_t&lt;Js,Transitions&gt;::src, typename T::dst&gt;)
                                                return Js;
                                            return 0ul;
                                          }() + ...);
                         }( std::make_index_sequence&lt;N&gt;{});
                         current_state = next_state;
                     }
                   }(), ...);
        }(std::make_index_sequence&lt;N&gt;{});
        return current_state;
    }
    int  current_state = 0;
};
template&lt;class... Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;... transitions)
  :sms{sm_single(transitions) ...}
  {}
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg ) {
    return [&amp;]&lt;auto ... Is &gt;( std::index_sequence&lt;Is...&gt; const &amp; ){
            return std::array&lt;int, sizeof...(Transitions)&gt;{std::get&lt;Is&gt;(sms).process(msg)...};
        }(std::make_index_sequence&lt;sizeof...(Transitions)&gt;{});
  }
  std::tuple&lt;sm_single&lt;Transitions&gt;...&gt; sms;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a54EfP">https://godbolt.org/z/a54EfP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template&lt;class... Ts&gt;
struct sm {
  using states_t = boost::mp11::mp_unique&lt;boost::mp11::mp_list&lt;typename Ts::src..., typename Ts::dst...&gt;&gt;;

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg) {
    ([this] {
      if constexpr (std::is_same_v&lt;TMsg, typename Ts::msg&gt;) {
        if (state_ == boost::mp11::mp_find&lt;states_t, typename Ts::src&gt;{}) {
          state_ = boost::mp11::mp_find&lt;states_t, typename Ts::dst&gt;{};
        }
      }
    }(), ...);
    return state_;
  }

  constexpr explicit(false) sm(const std::tuple&lt;Ts...&gt;&amp;) {}

 private:
  int state_{};
};
}

template&lt;class... Ts&gt;
struct sm : decltype(detail::sm{Ts{}})... {
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg) {
    return std::array{static_cast&lt;decltype(detail::sm{Ts{}})&amp;&gt;(*this).process(msg)...};
  }

  constexpr explicit(false) sm(const Ts&amp;... ts)
    : decltype(detail::sm{Ts{}}){ts}...
  { }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jxfY8q">https://godbolt.org/z/jxfY8q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;...) {}
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
    [&amp;] &lt;auto... Is&gt; (std::index_sequence&lt;Is...&gt;) {
      (process&lt;TMsg, Is, Transitions&gt;(), ...);
    }(std::index_sequence_for&lt;Transitions...&gt;{});
    return current_states;
  }

private:
  template &lt;class TMsg, auto Index, class TTransitions&gt;
  constexpr auto process() {
    [&amp;] &lt;template &lt;class...&gt; class TList, class... Ts&gt; (TList&lt;Ts...&gt;) {
      ([&amp;] {
        if constexpr (std::is_same_v&lt;TMsg, typename Ts::msg&gt;) {
          if (index_for&lt;typename Ts::src, TTransitions&gt;() == current_states[Index]) {
            current_states[Index] = index_for&lt;typename Ts::dst, TTransitions&gt;();
            return true;
          }
        }
        return false;
      }() or ...);
    }(TTransitions{});
  }

  template &lt;class TMsg, class TTransitions&gt;
  constexpr auto index_for() const {
    return [] &lt;template &lt;class...&gt; class TList, class... Ts, auto... Is&gt; (
        TList&lt;Ts...&gt;, std::index_sequence&lt;Is...&gt;) {
      return ([] () -&gt; int {
        if constexpr (std::is_same_v&lt;TMsg, typename Ts::src&gt;) {
          return Is;
        } else {
          return 0;
        }
      }() + ... + 0);
    }(TTransitions{}, std::make_index_sequence&lt;std::tuple_size_v&lt;TTransitions&gt;&gt;{});
  }

  std::array&lt;int, sizeof...(Transitions)&gt; current_states{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cYv7j5">https://godbolt.org/z/cYv7j5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Transitions&gt;
struct sm {
  template&lt;class ...Ts&gt;
  using states_impl_t = boost::mp11::mp_unique&lt;boost::mp11::mp_list&lt;typename Ts::src..., typename Ts::dst...&gt;&gt;;
  using states_t = std::tuple&lt;boost::mp11::mp_rename&lt;Transitions, states_impl_t&gt;...&gt;;
  using TransitionList = boost::mp11::mp_list&lt;Transitions...&gt;;

  constexpr explicit(false) sm(const Transitions&amp;...) {}
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
    [this]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt; const&amp;) {
        ( [this]&lt;class... Ts, auto I&gt;(std::tuple&lt;Ts...&gt; const&amp;, std::integral_constant&lt;int, I&gt;const&amp;) {
            ( [this]() {
                if constexpr (std::is_same_v&lt;TMsg, typename Ts::msg&gt;) {
                  if ( states[I] == boost::mp11::mp_find&lt; boost::mp11::mp_at_c&lt;states_t, I&gt;, typename Ts::src&gt;{}) {
                    states[I] = boost::mp11::mp_find&lt;boost::mp11::mp_at_c&lt;states_t, I&gt;, typename Ts::dst&gt;{};
                  }
                }
             }  (), ...);
        }( boost::mp11::mp_at_c&lt;TransitionList, Is&gt;{}, std::integral_constant&lt;int, Is&gt;{} ), ...);
    }(std::make_index_sequence&lt;sizeof...(Transitions)&gt;{});

    return states;
  }
private:
  std::array&lt;int, sizeof...(Transitions)&gt; states{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eebYbG">https://godbolt.org/z/eebYbG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;...) {}

    template &lt;class TDst, class TTransitions, typename T, T... ints&gt;
    constexpr auto dest_index(std::integer_sequence&lt;T, ints...&gt; index_seq){
        return ([](){
            using element_type = std::tuple_element_t&lt;ints, TTransitions&gt;;
            if (std::is_same_v&lt;TDst, typename element_type::src&gt;)
            {
                return static_cast&lt;int&gt;(ints);
            }
            else
                return 0;
        }() + ...);
    }

    template&lt;class TMsg, class TTransitions, class TIndex&gt;
    constexpr auto matched(int state)
    {
        constexpr auto transitions_size = std::tuple_size&lt;TTransitions&gt;::value;
        using index_seq = std::make_index_sequence&lt;transitions_size&gt;;

        using element_type = std::tuple_element_t&lt;TIndex::value, TTransitions&gt;;
        if (state == TIndex::value &amp;&amp; std::is_same_v&lt;TMsg, typename element_type::msg&gt;)
            return dest_index&lt;typename element_type::dst, TTransitions&gt;(index_seq{}) - TIndex::value;
        else
            return 0;
    }

    template&lt;class TMsg, class TTransitions, typename T, T... ints&gt;
    constexpr auto sum_matches(std::integer_sequence&lt;T, ints...&gt; index_seq, int state)
    {
        return (matched&lt;TMsg, TTransitions, std::integral_constant&lt;int, ints&gt;&gt;(state) + ...);
    }

    template&lt;class TMsg, class TTransitions&gt;
    constexpr auto get_state_for_transition_table(int i)
    {

        auto state = states[i];
        constexpr auto transitions_size = std::tuple_size&lt;TTransitions&gt;::value;
        using index_seq = std::make_index_sequence&lt;transitions_size&gt;;
        auto state_step = sum_matches&lt;TMsg, TTransitions&gt;(index_seq{}, state);

        state += state_step;
        return state;
    }

    template&lt;class TMsg, class ...&gt;
    constexpr auto process(const TMsg&amp;) {
        std::ptrdiff_t i = 0;
        (void(states[i++] = get_state_for_transition_table&lt;TMsg, Transitions&gt;(i)) , ...);

        return states;
    }

    private:
        std::array&lt;int, sizeof...(Transitions)&gt; states{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8Khx77">https://godbolt.org/z/8Khx77</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Transitions&gt;
struct sm : sm&lt;Transitions&gt;... {
  constexpr explicit(false) sm(const Transitions&amp;... t) : sm&lt;Transitions&gt;(t)... {}
  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg) {
    return std::array{sm&lt;Transitions&gt;::process(msg)...};
  }
};

template&lt;class Transitions&gt;
struct sm&lt;Transitions&gt; {
  constexpr explicit(false) sm(const Transitions&amp;) {}

  template&lt;class TMsg&gt;
  constexpr int process(const TMsg&amp;) {
    std::visit([this]&lt;class I&gt;(const I&amp;) {
      using Prev = mp_at&lt;Transitions, I&gt;;

      if constexpr (is_trait_same&lt;Prev, mp_quote&lt;msg&gt;, TMsg&gt;::value) {
        using is_src_same_prev_dst = mp_bind_back&lt;is_trait_same, mp_quote&lt;src&gt;, dst&lt;Prev&gt;&gt;;
        using J = mp_find_if_q&lt;Transitions, is_src_same_prev_dst&gt;;
        using Next = mp_bind_front&lt;mp_at, Transitions, J&gt;;

        if constexpr (mp_valid_q&lt;Next&gt;::value) {
          state = mp_find&lt;Transitions, mp_invoke_q&lt;Next&gt;&gt;{};
        }
      }
    }, state);

    return state.index();
  }

private:
  template&lt;class T&gt;
  using src = typename T::src;
  template&lt;class T&gt;
  using msg = typename T::msg;
  template&lt;class T&gt;
  using dst = typename T::dst;

  template&lt;class T, class Trait, class V&gt;
  using is_trait_same = mp_same&lt;mp_eval_or_q&lt;void, Trait, T&gt;, V&gt;;

  using State = mp_rename&lt;mp_iota&lt;mp_size&lt;Transitions&gt;&gt;, std::variant&gt;;
  State state{mp_size_t&lt;0&gt;{}};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hTo3d6">https://godbolt.org/z/hTo3d6</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>213 - Did you know that mapping types to values is a simple way to transition from compile-time to run-time space?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/213.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/213.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that mapping types to values is a simple way to transition from compile-time to run-time space?</strong></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/1_75_0/libs/mp11/doc/html/mp11.html#mp_find">https://www.boost.org/doc/libs/1_75_0/libs/mp11/doc/html/mp11.html#mp_find</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class... Ts&gt;
constexpr auto find = ([] {
  if constexpr (std::is_same_v&lt;T, typename Ts::second_type&gt;) {
    return Ts::first_type::value;
  } else {
    return 0;
  }
}() + ...);

struct T0{};
struct T1{};
struct T2{};

static_assert(0 == find&lt;T0, std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;);
static_assert(1 == find&lt;T1, std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;);
static_assert(2 == find&lt;T2, std::pair&lt;std::integral_constant&lt;int, 1&gt;, T1&gt;, std::pair&lt;std::integral_constant&lt;int, 2&gt;, T2&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v4h3b8">https://godbolt.org/z/v4h3b8</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simple <code>State machine</code> which returns the current state with the <code>process</code> call?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;) {}

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
    /*TODO*/return 0;
  }
};

template&lt;class TSrc, class TMsg, class TDst&gt;
struct transition {
  using src = TSrc;
  using msg = TMsg;
  using dst = TDst;
};

struct msg0{};
struct msg1{};
struct msg2{};

int main() {
  using namespace boost::ut;

  &quot;state machine&quot;_test = [] {
    sm sm{
      std::tuple{
        transition&lt;class State1, msg1, class State2&gt;{},
        transition&lt;class State2, msg2, class State1&gt;{}
      }
    };

    should(&quot;state in the same state on unexpected message&quot;) = [&amp;] {
      expect(0_i == sm.process(msg0{}));
      expect(0_i == sm.process(msg2{}));
    };

    should(&quot;transition to destination state on expected message&quot;) = [&amp;] {
      expect(1_i == sm.process(msg1{}));
    };

    should(&quot;stay in the same state on unexpected message&quot;) = [&amp;] {
      expect(1_i == sm.process(msg0{}));
      expect(1_i == sm.process(msg1{}));
    };

    should(&quot;transition to source state on expected message&quot;) = [&amp;] {
      expect(0_i == sm.process(msg2{}));
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oEjrT8">https://godbolt.org/z/oEjrT8</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class Transitions&gt;
struct sm {
    constexpr explicit(false) sm(const Transitions&amp;) {}
    constexpr static std::size_t N = std::tuple_size_v&lt;Transitions&gt;;
    template&lt;class TMsg&gt;
    constexpr auto process(const TMsg&amp;) {
        [&amp;]&lt;auto ... Is &gt;( std::index_sequence&lt;Is...&gt; const &amp; )
        {
            ( [&amp;](){ using T = std::tuple_element_t&lt;Is,Transitions&gt;;
                     if( Is == current_state &amp;&amp; std::is_same_v&lt; typename T::msg , TMsg&gt;  )
                     {
                         // assuming we can find a state index that the src match this dst
                         std::size_t next_state = []&lt;auto ... Js &gt;( std::index_sequence&lt;Js...&gt; const &amp; ){
                             return ( [](){ if(std::is_same_v&lt; typename std::tuple_element_t&lt;Js,Transitions&gt;::src, typename T::dst&gt;)
                                                return Js;
                                            return 0ul;
                                          }() + ...);
                         }( std::make_index_sequence&lt;N&gt;{});
                         current_state = next_state;
                     }
                   }(), ...);
        }(std::make_index_sequence&lt;N&gt;{});
        return current_state;
    }
    std::size_t  current_state = 0ul;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rjvq6d">https://godbolt.org/z/rjvq6d</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct sm {
  using states_t = boost::mp11::mp_unique&lt;boost::mp11::mp_list&lt;typename Ts::src..., typename Ts::dst...&gt;&gt;;

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; msg) {
    ([this] {
      if constexpr (std::is_same_v&lt;TMsg, typename Ts::msg&gt;) {
        if (state_ == boost::mp11::mp_find&lt;states_t, typename Ts::src&gt;{}) {
          state_ = boost::mp11::mp_find&lt;states_t, typename Ts::dst&gt;{};
        }
      }
    }(), ...);
    return state_;
  }

  constexpr explicit(false) sm(const std::tuple&lt;Ts...&gt;&amp;) {}

 private:
  int state_{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r85hqP">https://godbolt.org/z/r85hqP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;) {}

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
    std::visit([this]&lt;class I&gt;(const I&amp;) {
      using Prev = mp_at&lt;Transitions, I&gt;;

      if constexpr (is_trait_same&lt;Prev, mp_quote&lt;msg&gt;, TMsg&gt;::value) {
        using is_src_same_prev_dst = mp_bind_back&lt;is_trait_same, mp_quote&lt;src&gt;, dst&lt;Prev&gt;&gt;;
        using J = mp_find_if_q&lt;Transitions, is_src_same_prev_dst&gt;;
        using Next = mp_bind_front&lt;mp_at, Transitions, J&gt;;

        if constexpr (mp_valid_q&lt;Next&gt;::value) {
          state = mp_find&lt;Transitions, mp_invoke_q&lt;Next&gt;&gt;{};
        }
      }
    }, state);

    return state.index();
  }

private:
  template&lt;class T&gt;
  using src = typename T::src;
  template&lt;class T&gt;
  using msg = typename T::msg;
  template&lt;class T&gt;
  using dst = typename T::dst;

  template&lt;class T, class Trait, class V&gt;
  using is_trait_same = mp_same&lt;mp_eval_or_q&lt;void, Trait, T&gt;, V&gt;;

  using State = mp_rename&lt;mp_iota&lt;mp_size&lt;Transitions&gt;&gt;, std::variant&gt;;
  State state{mp_size_t&lt;0&gt;{}};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nGfW9j">https://godbolt.org/z/nGfW9j</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace sm_impl {
template&lt;class ...CS&gt; struct set{};
template&lt;class ...Cs&gt; struct list{};

template&lt;typename N, typename ... C&gt;
struct is_in {
    static constexpr bool value {(std::is_same_v&lt;N, C&gt; || ...)};
};

template&lt;class S, class L&gt; struct add_to_set;
template&lt;class ...Cs, class N&gt;
struct add_to_set&lt;set&lt;Cs...&gt;, list&lt;N&gt;&gt; {
    using type = std::conditional_t&lt; is_in&lt;N,Cs...&gt;::value, set&lt;Cs...&gt;, set&lt;Cs...,N&gt;&gt;;
};

template&lt;class... Cs, class N, class ...Ns&gt;
struct add_to_set&lt; set&lt;Cs...&gt;, list&lt;N,Ns...&gt; &gt; {
    using type = std::conditional_t&lt; is_in&lt;N, Cs...&gt;::value,
                                   typename add_to_set&lt; set&lt;Cs...&gt;, list&lt;Ns...&gt;&gt;::type,
                                   typename add_to_set&lt; set&lt;Cs...,N&gt;, list&lt;Ns...&gt;&gt;::type&gt;;
};

template&lt;class S, class T, class IC&gt; struct index_of_impl;
template&lt;class T, int N&gt;
struct index_of_impl&lt;set&lt;&gt;, T, std::integral_constant&lt;int, N&gt;&gt; {
    using type = std::integral_constant&lt;int, -1&gt;;
};

template&lt;class C, class ...Cs, class T, int N&gt;
struct index_of_impl&lt;set&lt;C, Cs...&gt;, T, std::integral_constant&lt;int, N&gt;&gt; {
    using type = std::conditional_t&lt; std::is_same_v&lt;C,T&gt;,
                                     std::integral_constant&lt;int, N&gt;,
                                     typename index_of_impl&lt; set&lt;Cs...&gt;, T, std::integral_constant&lt;int, N+1&gt;&gt;::type&gt;;
};

template&lt;class S, class T&gt; struct index_of;
template&lt;class ... Cs, class T&gt; struct index_of&lt;set&lt;Cs...&gt;, T&gt; {
    using type = typename index_of_impl&lt;set&lt;Cs...&gt;, T, std::integral_constant&lt;int, 0&gt; &gt;::type;
};

template&lt;class Src, class Msg, class Dst&gt; struct instruction{};

template&lt;typename Transitions&gt; struct TransitionList;
template&lt;template&lt;typename&gt; typename C, template&lt;class, class, class&gt; typename T,
         typename ... Src, typename ... Msg, typename ... Dst&gt;
struct TransitionList&lt; C&lt;T&lt;Src, Msg, Dst&gt;...&gt;&gt; {
    using stateSet = add_to_set&lt;set&lt;&gt;, list&lt;Src..., Dst...&gt;&gt;::type;
    using type = std::tuple&lt; instruction&lt; typename index_of&lt;stateSet, Src&gt;::type,
                                          Msg,
                                          typename index_of&lt;stateSet, Dst&gt;::type&gt; ...&gt;;
};

template&lt;int... S, class msg, class ...Msgs, int... D&gt;
int process(int currState, msg const&amp;, std::tuple&lt; instruction&lt;std::integral_constant&lt;int, S&gt;, Msgs, std::integral_constant&lt;int, D&gt;&gt;...&gt; const&amp; ) {
    int newState = currState;
    ([&amp;newState, currState= currState](){
        if ( currState == S &amp;&amp; std::is_same_v&lt;msg,Msgs&gt;)
            newState = D;
    }() , ...);
    return newState;
}

} //namespace sm_impl

template&lt;class Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;) {}

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp;) {
      using transitionList = typename sm_impl::TransitionList&lt;Transitions&gt;::type;
      state = sm_impl::process(state, TMsg{}, transitionList{});
      return state;
  }
  int state = 0;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M5s16r">https://godbolt.org/z/M5s16r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;template &lt;class...&gt; class TList, class... Ts&gt;
struct sm {
  constexpr explicit(false) sm(TList&lt;Ts...&gt;&amp;&amp;) {}

  template&lt;class TMsg&gt;
  constexpr auto process(const TMsg&amp; m) {
    ([&amp;] {
      if constexpr (std::is_same_v&lt;TMsg, typename Ts::msg&gt;) {
        if (index_for&lt;typename Ts::src&gt;() == current_state) {
          current_state = index_for&lt;typename Ts::dst&gt;();
          return true;
        }
      }
      return false;
    }() or ...);

    return current_state;
  }

private:
  template &lt;class TMsg&gt;
  consteval static auto index_for() {
    return [] &lt;class T, T... Is&gt; (std::integer_sequence&lt;T, Is...&gt;) {
      return ((std::is_same_v&lt;TMsg, typename Ts::src&gt; ? Is : 0) + ... + 0);
    }(std::make_integer_sequence&lt;int, sizeof...(Ts)&gt;{});
  }

  int current_state{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aE799E">https://godbolt.org/z/aE799E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class Transitions&gt;
struct sm {
  constexpr explicit(false) sm(const Transitions&amp;) {}

    template &lt;class TDst, typename T, T... ints&gt;
    constexpr auto dest_index(std::integer_sequence&lt;T, ints...&gt; index_seq){
        return ([](){
            using element_type = std::tuple_element_t&lt;ints, Transitions&gt;;
            if (std::is_same_v&lt;TDst, typename element_type::src&gt;)
            {
                return static_cast&lt;int&gt;(ints);
            }
            else
                return 0;
        }() + ...);
    }

    template&lt;class TMsg, class TIndex&gt;
    constexpr auto matched()
    {
        constexpr auto transitions_size = std::tuple_size&lt;Transitions&gt;::value;
        using index_seq = std::make_index_sequence&lt;transitions_size&gt;;

        using element_type = std::tuple_element_t&lt;TIndex::value, Transitions&gt;;
        if (state == TIndex::value &amp;&amp; std::is_same_v&lt;TMsg, typename element_type::msg&gt;)
            return dest_index&lt;typename element_type::dst&gt;(index_seq{}) - TIndex::value;
        else
            return 0;
    }

    template&lt;class TMsg, typename T, T... ints&gt;
    constexpr auto sum_matches(std::integer_sequence&lt;T, ints...&gt; index_seq)
    {
        return (matched&lt;TMsg, std::integral_constant&lt;int, ints&gt;&gt;() + ...);
    }

    template&lt;class TMsg&gt;
    constexpr auto process(const TMsg&amp;) {
        constexpr auto transitions_size = std::tuple_size&lt;Transitions&gt;::value;
        using index_seq = std::make_index_sequence&lt;transitions_size&gt;;
        auto state_step = sum_matches&lt;TMsg&gt;(index_seq{});

        state += state_step;

        return state;
    }

    private:
        int state = 0;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TGvhPo">https://godbolt.org/z/TGvhPo</a></p>
</blockquote>
</div>]]></description>
        </item>
<item>
            <title>212 - Did you know that lambdas are const by default but can be mutable and keep state?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/212.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/212.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that lambdas are const by default but can be mutable and keep state?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/dcl.stc#:mutable">http://eel.is/c++draft/dcl.stc#:mutable</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">auto sum = [sums = 0](auto sum) mutable {
  return sums += sum;
};

int main() {
  std::cout &lt;&lt; sum(1) &lt;&lt; sum(2) &lt;&lt; sum(3); // prints 1 3 6
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GEse7z">https://godbolt.org/z/GEse7z</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a mutable lambda <code>sum_prices</code> which parses the input buffer and sums prices (price1,price2,...) for matching messages (dispatch based on header.id)?</strong></p>
</li>
<li>
<p>Double points for the most generic solution</p>
</li>
<li>Triple points for the most efficient solution (Assembly)</li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct [[gnu::packed]] header {
  short id;
};

struct [[gnu::packed]] add1 {
  header h;
  std::array&lt;char, 1&gt; price1;
};

struct [[gnu::packed]] add2 {
  header h;
  std::array&lt;char, 2&gt; price1;
};

struct [[gnu::packed]] add3 {
  header h;
  std::array&lt;char, 5&gt; price1;
  std::array&lt;char, 6&gt; price2;
};

template&lt;auto Id, class T&gt;
struct msg_traits {
  static constexpr auto id = Id;
  using type = T;
};

template&lt;class...&gt;
auto sum_prices = [](std::string_view buffer) {
  /*TODO*/return 0;
};

int main() {
  using namespace boost::ut;

  &quot;should return 0 with empty buffer&quot;_test = [] {
    expect(0_i == sum_prices&lt;&gt;(std::string_view{}));
  };

  &quot;should return 0 with empty buffer and traits&quot;_test = [] {
    expect(0_i == sum_prices&lt;msg_traits&lt;1, add1&gt;&gt;(std::string_view{}));
  };

  &quot;should return 0 with not matchind id&quot;_test = [] {
    add1 msg{ {.id = {}}, std::array{'9'} };
    expect(0_i == (sum_prices&lt;msg_traits&lt;7, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg), sizeof(msg)})));
  };

  &quot;should return the price of matching message&quot;_test = [] {
    add1 msg{ {.id = 42}, std::array{'9'} };
    expect(9_i == (sum_prices&lt;msg_traits&lt;42, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg), sizeof(msg)})));
  };

  &quot;should return sum of prices for the same id&quot;_test = [] {
    add1 msg1{ {.id = 42}, std::array{'2'} };
    expect(2_i == (sum_prices&lt;msg_traits&lt;0, add2&gt;, msg_traits&lt;42, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg1), sizeof(msg1)})));

    add1 msg2{ {.id = 42}, std::array{'3'} };
    expect(_i(2 + 3) == (sum_prices&lt;msg_traits&lt;0, add2&gt;, msg_traits&lt;42, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg2), sizeof(msg2)})));
  };

  &quot;should return sum of prices for matching messages by id&quot;_test = [] {
    add1 msg1{ {.id = 1}, std::array{'1'} };
    expect(1_i == (sum_prices&lt;msg_traits&lt;1, add1&gt;, msg_traits&lt;2, add2&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg1), sizeof(msg1)})));

    add2 msg2{ {.id = 2}, std::array{'4', '2'} };
    expect(_i(1 + 42) == (sum_prices&lt;msg_traits&lt;1, add1&gt;, msg_traits&lt;2, add2&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg2), sizeof(msg2)})));
  };

  &quot;should return sum of prices for matching messages by id in different oder&quot;_test = [] {
    add2 msg2{ {.id = 200}, std::array{'1', '1'} };
    expect(11_i == (sum_prices&lt;msg_traits&lt;200, add2&gt;, msg_traits&lt;100, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg2), sizeof(msg2)})));

    add1 msg1{ {.id = 100}, std::array{'7'} };
    expect(_i(11 + 7) == (sum_prices&lt;msg_traits&lt;200, add2&gt;, msg_traits&lt;100, add1&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg1), sizeof(msg1)})));
  };

  &quot;should return sum of prices for matching messages with spaces in prices &quot;_test = [] {
    add1 msg1{ {.id = 100}, std::array{' '} };
    expect(0_i == (sum_prices&lt;msg_traits&lt;100, add1&gt;, msg_traits&lt;200, add2&gt;, msg_traits&lt;300, add3&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg1), sizeof(msg1)})));

    add2 msg2{ {.id = 200}, std::array{' ', '9'} };
    expect(9_i == (sum_prices&lt;msg_traits&lt;100, add1&gt;, msg_traits&lt;200, add2&gt;, msg_traits&lt;300, add3&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg2), sizeof(msg2)})));

    add3 msg3{ {.id = 300}, std::array{' ', ' ', '1', '2', '3'}, std::array{' ', '0', '8', '7', '0', '0'} };
    expect(_i(9 + 123 + 8700) == (sum_prices&lt;msg_traits&lt;100, add1&gt;, msg_traits&lt;200, add2&gt;, msg_traits&lt;300, add3&gt;&gt;(std::string_view{reinterpret_cast&lt;const char*&gt;(&amp;msg3), sizeof(msg3)})));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n138a1">https://godbolt.org/z/n138a1</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto integer_price = [](const auto price) {
    auto p = 0;
    for (auto i = 0u; i &lt; std::size(price); ++i) {
      if (std::isdigit(price[i])) {
        p = (p * 10) + (price[i] - '0');
      }
    }
    return p;
};

template&lt;class Traits&gt;
auto sum_prices_impl = [](std::string_view buffer) {
  auto sum = 0;
  if (const auto* msg = reinterpret_cast&lt;const typename Traits::type*&gt;(std::data(buffer)); std::size(buffer) and Traits::id == msg-&gt;h.id) {
    if constexpr (requires {msg-&gt;price1;}) {
      sum += integer_price(msg-&gt;price1);
    }
    if constexpr (requires {msg-&gt;price2;}) {
      sum += integer_price(msg-&gt;price2);
    }
  }
  return sum;
};

template&lt;class... Traits&gt;
auto sum_prices = [total = 0](std::string_view buffer) mutable {
    return total += (0 + ... + sum_prices_impl&lt;Traits&gt;(buffer));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dMhWxW">https://godbolt.org/z/dMhWxW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;class T, class... TArgs&gt; decltype(void(T{std::declval&lt;TArgs&gt;()...}), std::true_type{}) test_is_braces_constructible(int);
template &lt;class, class...&gt; std::false_type test_is_braces_constructible(...);
template &lt;class T, class... TArgs&gt; using is_braces_constructible = decltype(test_is_braces_constructible&lt;T, TArgs...&gt;(0));
struct any_type { template&lt;class T&gt; constexpr explicit(false) operator T(); };

template&lt;class T&gt;
constexpr auto to_tuple(T&amp;&amp; object) noexcept {
  using type = std::decay_t&lt;T&gt;;
  if constexpr(is_braces_constructible&lt;type, any_type, any_type, any_type&gt;{}) {
    auto&amp;&amp; [p1, p2, p3] = std::forward&lt;T&gt;(object);
    return std::tuple(p1, p2, p3);
  } else if constexpr(is_braces_constructible&lt;type, any_type, any_type&gt;{}) {
    auto&amp;&amp; [p1, p2] = std::forward&lt;T&gt;(object);
    return std::tuple(p1, p2);
  } else if constexpr(is_braces_constructible&lt;type, any_type&gt;{}) {
    auto&amp;&amp; [p1] = std::forward&lt;T&gt;(object);
    return std::tuple(p1);
  } else {
    return std::tuple{};
  }
}

template&lt;class R, R N&gt;
static constexpr const R ascii_to_int[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1 * R(std::pow(10, N)), 2* R(std::pow(10, N)), 3* R(std::pow(10, N)), 4* R(std::pow(10, N)), 5* R(std::pow(10, N)), 6* R(std::pow(10, N)), 7* R(std::pow(10, N)), 8* R(std::pow(10, N)), 9* R(std::pow(10, N)) };

template&lt;class R, auto Size&gt;
constexpr auto to_number = [](const auto&amp; buffer) {
  return []&lt;auto... Ns&gt;(const auto&amp; buffer, std::integer_sequence&lt;R, Ns...&gt;) {
    return ((ascii_to_int&lt;R, sizeof...(Ns) - Ns - 1&gt;[buffer[Ns]]) + ...);
  }(buffer, std::make_integer_sequence&lt;R, Size&gt;{});
};

template &lt;class THeader, class... Ts&gt;
auto sum_prices(const std::tuple&lt;THeader, Ts...&gt;&amp; msg) {
  return (to_number&lt;std::uint32_t, Ts{}.size()&gt;(std::data(std::get&lt;Ts&gt;(msg))) + ...);
}

template &lt;class... Ts&gt;
constexpr auto sum_prices(const auto&amp; buffer) {
  return ([&amp;buffer] {
    const auto* msg = reinterpret_cast&lt;const typename Ts::type*&gt;(buffer);
    return msg-&gt;h.id == Ts::id ? sum_prices(to_tuple(*msg)) : 0;
  }() + ... + 0);
}
}  // namespace detail

template &lt;class... Ts&gt;
auto sum_prices = [prices = 0](std::string_view buffer) mutable {
  return std::size(buffer) ? prices += detail::sum_prices&lt;Ts...&gt;(std::data(buffer)) : prices;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Y3cEn9">https://godbolt.org/z/Y3cEn9</a> | <a href="https://godbolt.org/z/qKerKe">https://godbolt.org/z/qKerKe</a> | <a href="https://quick-bench.com/q/Pt3-lzZOU6FodyGLqAPjHHN48Fk">https://quick-bench.com/q/Pt3-lzZOU6FodyGLqAPjHHN48Fk</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto parse(const auto&amp; arr) {
  auto it = std::find_if(std::cbegin(arr), std::cend(arr),
                         [](char c) { return c &gt;= '0' &amp;&amp; c &lt;= '9'; });
  int i{};
  std::from_chars(it, std::cend(arr), i);
  return i;
};

auto msg_value(const auto&amp; msg) {
  return parse(msg.price1);
}

auto msg_value(const add3&amp; msg) {
  return parse(msg.price1) + parse(msg.price2);
}

template &lt;class... TMsgTraits&gt;
auto sum_prices = [sum = 0](std::string_view buffer) mutable {
  if (std::size(buffer) &lt; sizeof(header)) {
    return 0;
  }
  const auto id = reinterpret_cast&lt;const header*&gt;(std::data(buffer))-&gt;id;
  ([&amp;] &lt;auto Id, class T&gt; (msg_traits&lt;Id, T&gt;) {
    if (std::size(buffer) &lt; sizeof(T)) {
      return false;
    }
    if (Id == id) {
      sum += msg_value(*reinterpret_cast&lt;const T*&gt;(std::data(buffer)));
      return true;
    }
    return false;
  }(TMsgTraits{}) or ...);
  return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a1hhG6">https://godbolt.org/z/a1hhG6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
static constexpr auto DEFAULT_RETURN = 0;

constexpr auto from_chars_wrapper(const auto iterable)
{
    int output {};
    const auto first_num = std::find(std::crbegin(iterable), std::crend(iterable), ' ').base();
    (void)std::from_chars(first_num, std::cend(iterable), output);
    return output;
}

template &lt;class TMsgTraits&gt;
constexpr auto calculate_price(const char* buffer)
{
    using message_t = TMsgTraits::type;

    if (const auto id = reinterpret_cast&lt;const header*&gt;(buffer)-&gt;id; id != TMsgTraits::id) {
        return DEFAULT_RETURN;
    }

    const message_t* message = reinterpret_cast&lt;const message_t*&gt;(buffer);

    int output {};
    if constexpr (requires { message_t::price1; }) {
        output += from_chars_wrapper(message-&gt;price1);
    }
    if constexpr (requires { message_t::price2; }) {
        output += from_chars_wrapper(message-&gt;price2);
    }
    return output;
};
}

template &lt;class... TAllMsgTraits&gt;
auto sum_prices = [sum = 0](std::string_view buffer) mutable {
    if (std::size(buffer) &lt; sizeof(header)) {
        return detail::DEFAULT_RETURN;
    }

    sum += (detail::calculate_price&lt;TAllMsgTraits&gt;(std::data(buffer)) + ... + 0);
    return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/75f6o9c">https://godbolt.org/z/75f6o9c</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class F&gt;
constexpr decltype(auto) apply_prices(F&amp;&amp; f, const add1&amp; a) { return std::forward&lt;F&gt;(f)(a.price1); }
template &lt;class F&gt;
constexpr decltype(auto) apply_prices(F&amp;&amp; f, const add2&amp; a) { return std::forward&lt;F&gt;(f)(a.price1); }
template &lt;class F&gt;
constexpr decltype(auto) apply_prices(F&amp;&amp; f, const add3&amp; a) { return std::forward&lt;F&gt;(f)(a.price1, a.price2); }

template&lt;class... Ts&gt;
auto sum_prices = [sum = 0](const std::string_view&amp; buffer) mutable {
  constexpr auto Ns = sizeof...(Ts);

  if constexpr (Ns &gt; 0) {
    const auto id = reinterpret_cast&lt;const short*&gt;(buffer.data());

    if (sizeof(*id) &lt;= buffer.size()) {
      constexpr std::array&lt;std::size_t, Ns&gt; ids{ Ts::id... };
      constexpr std::array&lt;int(*)(const void*), Ns&gt; acc{
        [](const void* ptr) {
          return apply_prices([](const auto&amp;... prices) {
            return (... + std::accumulate(
              prices.begin(), prices.end(), 0, [](int s, char c) {
                if (c == ' ') return s;
                return s * 10 + (c - '0');
              })
            );
          }, *reinterpret_cast&lt;const Ts::type*&gt;(ptr));
        }...
      };

      const auto begin = ids.begin();
      const auto end   = ids.end();
      const auto it    = std::find(begin, end, *id);

      if (it != end) {
        sum += acc[it - begin](id);
      }
    }
  }

  return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/drnqTa">https://godbolt.org/z/drnqTa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto array_to_price(const auto &amp;array){
    auto text = std::string{std::data(array), std::size(array)};
    auto pos = text.find_first_not_of(' ');
    if(std::string::npos == pos){
        return 0;
    }

    return std::stoi(text.substr(pos));
}
template&lt;class Trait&gt;
auto sum_one_price = [](std::string_view buffer)  {
    using my_type = Trait::type;

    if (std::empty(buffer)) { return 0; }

    const auto&amp; msg = *reinterpret_cast&lt;const my_type*&gt;(std::data(buffer));
    if (msg.h.id == Trait::id) {
        const auto price1 = array_to_price(msg.price1);
        if constexpr (requires{msg.price2;}){
            return price1 + array_to_price(msg.price2);
        }
        else{
            return price1;
        }
    }

    return 0;
};

template&lt;class... Traits&gt;
auto sum_prices =[sum = 0] (std::string_view buffer) mutable {
    if constexpr (sizeof...(Traits) ==0 )
        return 0;

    else {
        sum +=(sum_one_price&lt;Traits&gt;(buffer)+...);
        return sum;
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7Wssz7">https://godbolt.org/z/7Wssz7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto N&gt;
int parse_number(const std::array&lt;char, N&gt;&amp; arr) {
    int num = 0;
    for(uint32_t n=0; n&lt;N; n++)
        if(arr[n] != ' ')
            num = 10*num + arr[n] - '0';
    return num;
};

template&lt;class T&gt; int totalPrices(const T&amp; t) { return parse_number(t.price1); }
template&lt;&gt; int totalPrices&lt;add3&gt;(const add3&amp; t) { return parse_number(t.price1) + parse_number(t.price2); }

template&lt;class&gt; struct process_msg;
template&lt;auto Id, class T&gt;
struct process_msg&lt;msg_traits&lt;Id, T&gt;&gt; {
    process_msg(std::string_view buffer) : buffer(buffer) {}
    int operator()() {
        const T* msg = reinterpret_cast&lt;const T*&gt;(buffer.data());
        if( msg-&gt;h.id == Id)
            return totalPrices(*msg);
        else
            return 0;
    }
    std::string_view buffer;
};

template&lt;class...Msgs&gt;
auto sum_prices = [sums = 0](std::string_view buffer) mutable  {
    if(buffer.size() ==0)
        return sums;
    if constexpr(sizeof...(Msgs) ==0) {
        return sums;
    } else {
        return sums += (process_msg&lt;Msgs&gt;(buffer)() + ...);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yn3zP6">https://godbolt.org/z/Yn3zP6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class...Ts&gt;
auto sum_prices = [ price = 0](std::string_view buffer) mutable {
    if constexpr ( sizeof ...(Ts) == 0 ) return price;
    if ( buffer.size() &gt;= sizeof(header)  )
    {
        header hd = *(header*)buffer.data();
        ([&amp;](){ if( hd.id == Ts::id )
                {
                    std::stringstream ss;
                    ss &lt;&lt; buffer;
                    ss.seekg(sizeof(header));
                    int p = 0;
                    while( ss.good() )
                    {
                        ss &gt;&gt; p;
                        price +=p;
                    }
                }
            }(),...);
    }
    return price;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d1aezc">https://godbolt.org/z/d1aezc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;std::size_t N, typename Seq&gt; struct offset_sequence;
template&lt;std::size_t N, std::size_t... Ints&gt;
struct offset_sequence&lt;N, std::index_sequence&lt;Ints...&gt;&gt; {
    using type = std::index_sequence&lt;Ints + N...&gt;;
};
template&lt;std::size_t N, typename Seq&gt;
using offset_sequence_t = typename offset_sequence&lt;N, Seq&gt;::type;

template&lt;auto N&gt;
int constexpr parse_number(const std::array&lt;char, N&gt;&amp; arr) {
    int num = 0;
    for(uint32_t n=0; n&lt;N; n++)
        if(arr[n] != ' ')
            num = 10*num + arr[n] - '0';
    return num;
};

template&lt;class T&gt; int constexpr totalPrices(const T&amp; t) {
    auto tup = to_tuple(t);
    return [tup]&lt;std::size_t... Is&gt;(std::index_sequence&lt;Is...&gt;) { return (parse_number(std::get&lt;Is&gt;(tup)) + ...); }
    ( offset_sequence_t&lt;1, std::make_index_sequence&lt;std::tuple_size_v&lt;decltype(tup)&gt;-1&gt;&gt;{}   );
}


template&lt;class&gt; struct process_msg;
template&lt;auto Id, class T&gt;
struct process_msg&lt;msg_traits&lt;Id, T&gt;&gt; {
    process_msg(std::string_view buffer) : buffer(buffer) {}
    int operator()() {
        if(buffer.size() ==0)
            return 0;
        const T* msg = reinterpret_cast&lt;const T*&gt;(buffer.data());
        if( msg-&gt;h.id == Id)
            return totalPrices(*msg);
        else
            return 0;
    }
    std::string_view buffer;
};

template&lt;class...Msgs&gt;
auto sum_prices = [sums = 0](std::string_view buffer) mutable  {
    if constexpr(sizeof...(Msgs) ==0) {
        return sums;
    } else {
        return sums += (process_msg&lt;Msgs&gt;(buffer)() + ...);
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c9Y5oM">https://godbolt.org/z/c9Y5oM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">static inline auto skip_spaces(auto &amp; begin) {
    while(*begin == ' ')
        ++begin;
}

template&lt;class TMsg&gt;
auto dispatch(std::string_view buffer)
{
    auto id = reinterpret_cast&lt;const short *&gt;(buffer.data());
    bool match = TMsg::id == *id;
    if (match)
    {
        using msg_type = typename TMsg::type;
        auto msg = reinterpret_cast&lt;const msg_type*&gt;(buffer.data());
        auto sum = 0;
        if constexpr (requires { msg-&gt;price1; }) {
            auto begin = msg-&gt;price1.begin();
            skip_spaces(begin);
            if( begin != msg-&gt;price1.end())
                std::from_chars(begin, msg-&gt;price1.end(), sum);
        }
        if constexpr (requires { msg-&gt;price2; }) {
            int price2;
            auto begin = msg-&gt;price2.begin();
            skip_spaces(begin);
            if( begin != msg-&gt;price2.end())
            {
                std::from_chars(begin, msg-&gt;price2.end(), price2);
                sum += price2;
            }
        }
        return sum;
    }
    return 0;
}

template&lt;class...TMsgTrait&gt;
auto sum_prices = [sum = 0](std::string_view buffer) mutable {
    if (std::size(buffer) == 0)
        return 0;
    sum += (dispatch&lt;TMsgTrait&gt;(buffer) + ... + 0);
    return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/64s4M3">https://godbolt.org/z/64s4M3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto value_of = [](const auto&amp; data) {
    const auto start = std::find_if(std::cbegin(data), std::cend(data),
                                    [](const auto c) { return std::isdigit(static_cast&lt;int&gt;(c)); });
    std::size_t value{};
    // Assume well-formedness of input prices. In principle, should check
    // the error code returned, but handling the error case makes this more expensive
    // than it already is...
    std::from_chars(start, std::cend(data), value);
    return value;
};

template&lt;class TMsg&gt;
concept msg_with_price = requires(TMsg m) { m.price1; };

template&lt;msg_with_price TMsg&gt;
constexpr auto get_price(const TMsg&amp; msg) {
    if constexpr (requires{ msg.price2; }) {
        return value_of(msg.price1) + value_of(msg.price2);
    }
    return value_of(msg.price1);
}

template&lt;class... TMsgs&gt;
auto sum_prices = [sum = std::size_t{}](std::string_view buffer) mutable -&gt; std::size_t {
  if(std::size(buffer) &lt; sizeof(header)) {
      return sum;
  }

  const auto id = reinterpret_cast&lt;const header*&gt;(std::data(buffer))-&gt;id;
  ([&amp;]&lt;auto Id, class T&gt;(msg_traits&lt;Id, T&gt; msg) {
      if (std::size(buffer) &lt; sizeof(T)) {
          return false;
      }

      if (Id == id) {
          sum += get_price(*reinterpret_cast&lt;const T*&gt;(std::data(buffer)));
          return true;
      }
    return false;
  }(TMsgs{}) or ...);

  return sum;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5TYbq5">https://godbolt.org/z/5TYbq5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>211 - Did you know about C++2X Pattern Matching proposal?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/211.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/211.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++2X Pattern Matching proposal?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1371">http://wg21.link/p1371</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  auto value = 42;

  inspect (value) {
    0  =&gt; { std::cout &lt;&lt; 0; }
    42 =&gt; { std::cout &lt;&lt; 42; } // prints 42
    x  =&gt; { std::cout &lt;&lt; x; }
  };

  auto tuple = std::tuple{&quot;Quantlab&quot;, 42};

  inspect(tuple) {
    [str, 42] =&gt; { std::cout &lt;&lt; str &lt;&lt; ' ' &lt;&lt; 42; } // prints Quantlab42
    [_, _]    =&gt; { std::cout &lt;&lt; &quot;...&quot;; }
  };

  return inspect(value) {
    _ =&gt; _ + 1; // returns 43
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/efE3va">https://godbolt.org/z/efE3va</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you apply pattern matching to the following use cases {integral, enum, tuple}?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  using namespace boost::ut;

  &quot;pattern matching - integral&quot;_test = [value = 42u] {
     expect(value == inspect(value) {
       _ =&gt; 0; // TODO
     });
  };

  &quot;pattern matching - enum&quot;_test = [] {
    enum class op { Add, Sub, Mul, Div };

    const auto inspect_expr = [](const std::size_t value) {
      return inspect(value) {
        // TODO
      };
    };

    expect(op::Add == inspect_expr('+'));
    expect(op::Sub == inspect_expr('-'));
    expect(op::Mul == inspect_expr('*'));
    expect(op::Div == inspect_expr('/'));
    expect(throws( [=] { inspect_expr(' '); }));
  };

  &quot;pattern matching - tuple&quot;_test = [] {
    const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
      return inspect(value) {
        // TODO
      };
    };

    expect(0_i == inspect_expr(std::tuple{0, 2}));
    expect(0_i == inspect_expr(std::tuple{1, 0}));
    expect(3_i == inspect_expr(std::tuple{1, 2}));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fEnb8c">https://godbolt.org/z/fEnb8c</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     _ =&gt; 42;
   });
};
&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };
  const auto inspect_expr = [](const std::size_t value) {
    return inspect(value) {
      '+' =&gt; op::Add;
      '-' =&gt; op::Sub;
      '*' =&gt; op::Mul;
      '/' =&gt; op::Div;
      _ =&gt; !{throw 0;}
    };
  };
  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};
&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
      [0, _] =&gt; 0;
      [_, 0] =&gt; 0;
      [x, y] =&gt; x + y;
    };
  };
  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E9W5za">https://godbolt.org/z/E9W5za</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     x =&gt; x;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  constexpr auto inspect_expr = [](const std::size_t value) {
    return inspect(value) {
      '+' =&gt; op::Add;
      '-' =&gt; op::Sub;
      '*' =&gt; op::Mul;
      '/' =&gt; op::Div;
      _ =&gt; !{ throw std::runtime_error(&quot;Nope&quot;); };
    };
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
      [0, x] =&gt; 0;
      [x, 0] =&gt; 0;
      [x, y] =&gt; x+y;
    };
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ePMTKo">https://godbolt.org/z/ePMTKo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">  &quot;pattern matching - integral&quot;_test = [value = 42u] {
     expect(value == inspect(value) {
       _ =&gt; _;
     });
  };

  &quot;pattern matching - enum&quot;_test = [] {
    enum class op { Add, Sub, Mul, Div };

    const auto inspect_expr = [](const std::size_t value) {
      return inspect(value) {
        '+' =&gt; op::Add;
        '-' =&gt; op::Sub;
        '*' =&gt; op::Mul;
        '/' =&gt; op::Div;
         _  =&gt; !{ throw std::invalid_argument{&quot;Only arithmetic operations&quot;}; }
      };
    };

    expect(op::Add == inspect_expr('+'));
    expect(op::Sub == inspect_expr('-'));
    expect(op::Mul == inspect_expr('*'));
    expect(op::Div == inspect_expr('/'));
    expect(throws( [=] { inspect_expr(' '); }));
  };

  &quot;pattern matching - tuple&quot;_test = [] {
    const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
      return inspect(value) {
        [0, _] =&gt; 0;
        [_, 0] =&gt; 0;
        [x, y] =&gt; x + y;
      };
    };

    expect(0_i == inspect_expr(std::tuple{0, 2}));
    expect(0_i == inspect_expr(std::tuple{1, 0}));
    expect(3_i == inspect_expr(std::tuple{1, 2}));
  };
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Wj5jhv">https://godbolt.org/z/Wj5jhv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     _ =&gt; value;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  const auto inspect_expr = [](const std::size_t value) {
    return inspect(value) {
      '+' =&gt; op::Add;
      '-' =&gt; op::Sub;
      '*' =&gt; op::Mul;
      '/' =&gt; op::Div;
      _   =&gt; throw(1), op::Add;
    };
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(std::get&lt;0&gt;(value)+std::get&lt;1&gt;(value)) {
        3 =&gt; 3;
        _ =&gt; 0;
    };
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7Y3jas">https://godbolt.org/z/7Y3jas</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     _ =&gt; value;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  const auto inspect_expr  = [](const std::size_t value) -&gt;op{
    return inspect(value) {
      '+'=&gt;op::Add;
      '-'=&gt;op::Sub;
      '*'=&gt;op::Mul;
      '/'=&gt;op::Div;
       _ =&gt;!{throw std::runtime_error(&quot;Not Supported&quot;);}
    };
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
        [0,_]=&gt;0;
        [_,0]=&gt;0;
        [x,y]=&gt;x+y;
    };
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/o9xqvx">https://godbolt.org/z/o9xqvx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     x =&gt; x;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  const auto inspect_expr = [](const std::size_t value) {
    return inspect(value) {
      '+' =&gt; op::Add;
      '-' =&gt; op::Sub;
      '*' =&gt; op::Mul;
      '/' =&gt; op::Div;
       _  =&gt; !{ throw std::invalid_argument(&quot;value&quot;); }
    };
    throw;
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
      [0, _] =&gt; 0;
      [_, 0] =&gt; 0;
      [u, v] =&gt; u + v;
    };
    throw;
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nzMKeT">https://godbolt.org/z/nzMKeT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     _ =&gt; _;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  const auto inspect_expr = [](const std::size_t value) {
    return inspect(value) {
      '+' =&gt; op::Add;
      '-' =&gt; op::Sub;
      '*' =&gt; op::Mul;
      '/' =&gt; op::Div;
      _ =&gt; !{
          throw std::invalid_argument(&quot;Could not parse argument&quot;);
      }
    };
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
        // Not sure if there's some algorithm at play here that I'm not seeing - the tests don't seem correlated to me.
        [0, 2] =&gt; 0;
        [1, 0] =&gt; 0;
        [1, 2] =&gt; 3;
    };
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sea88v">https://godbolt.org/z/sea88v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;pattern matching - integral&quot;_test = [value = 42u] {
   expect(value == inspect(value) {
     _ =&gt; value;
   });
};

&quot;pattern matching - enum&quot;_test = [] {
  enum class op { Add, Sub, Mul, Div };

  const auto inspect_expr = [](const std::size_t value) {
    return   inspect  (value) {
        '+' =&gt; op::Add;
        '-' =&gt; op::Sub;
        '*' =&gt; op::Mul;
        '/' =&gt; op::Div;
        ' ' =&gt; !{throw std::runtime_error(&quot;inspect_expr not there&quot;);}
    };
  };

  expect(op::Add == inspect_expr('+'));
  expect(op::Sub == inspect_expr('-'));
  expect(op::Mul == inspect_expr('*'));
  expect(op::Div == inspect_expr('/'));
  expect(throws( [=] { inspect_expr(' '); }));
};

&quot;pattern matching - tuple&quot;_test = [] {
  const auto inspect_expr = [](const std::tuple&lt;int, int&gt;&amp; value) {
    return inspect(value) {
      [0, _] =&gt; 0;
      [_, 0] =&gt; 0;
      [x, y] =&gt; x + y;
    };
  };

  expect(0_i == inspect_expr(std::tuple{0, 2}));
  expect(0_i == inspect_expr(std::tuple{1, 0}));
  expect(3_i == inspect_expr(std::tuple{1, 2}));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vojTqd">https://godbolt.org/z/vojTqd</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>210 - Did you know about `Design By Introspection`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/210.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/210.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>Design By Introspection</code>?</strong></p>
</li>
<li>
<p><a href="https://dconf.org/2017/talks/alexandrescu.pdf">https://dconf.org/2017/talks/alexandrescu.pdf</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto foo(T t) {
  if constexpr(requires{ t.foo; }) {
    return t.foo;
  } else {
    return 0;
  }
}

constexpr struct { int foo{42}; } f;
static_assert(42 == foo(f));

constexpr struct { int bar{42}; } b;
static_assert(0 == foo(b));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PKhE9x">https://godbolt.org/z/PKhE9x</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a simple system <code>sys</code> which leverages <code>Policy By Design</code> to ensure that the process call returns { true: if the condition is satisfied by the trade; false: otherwise }?</strong></p>
</li>
<li>
<p>Double points for explaining the advantages of <code>Design By Introspection</code></p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct sys;/*TODO*/

int main() {
  using namespace boost::ut;

  &quot;should not trade since there is no condition set&quot;_test = [] {
    sys sys{};
    struct { int price = 42; } trade;
    expect(not sys.process(trade));
  };

  &quot;should not trade since condition doesn't match&quot;_test = [] {
    sys sys{};
    sys.process([](auto price) { return price &gt; 100; });
    struct { int price = 42; } trade;
    expect(not sys.process(trade));
  };

  &quot;should trade since condition matches&quot;_test = [] {
    sys sys{};
    sys.process([](auto price) { return price &gt; 100; });
    struct { int price = 142; } trade;
    expect(sys.process(trade));
  };

  &quot;should only trade on the second condition&quot;_test = [] {
    sys sys{};
    struct { int price = 42; } trade;

    sys.process([](auto price) { return price == 100; });
    expect(not sys.process(trade));

    sys.process([](auto price) { return price == 42; });
    expect(sys.process(trade));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oTjhv4">https://godbolt.org/z/oTjhv4</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct sys {
  bool process(auto input) {
    if constexpr (requires { input.price; }) {
      return condition_(input.price);
    } else {
      condition_ = input;
      return false;
    }
  }
 private:
  using condition_t = std::function&lt;bool(int)&gt;;
  condition_t condition_ = [](int) { return false; };
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4bbszK">https://godbolt.org/z/4bbszK</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys {
    std::optional&lt;std::function&lt;bool(int)&gt;&gt; condition{};

    constexpr auto process(const auto&amp; x) {
        if constexpr (requires { condition = x; }) {
            condition = x;
        } else if constexpr (requires { x.price; }) {
            if (condition.has_value()) {
                return (*condition)(x.price);
            }
        }
        return false;
    }
};

// Design by Introspection
//  - Enables lambdas which typically aren't directly overloadable to behave differently based on type
//  - Helps replace run-time branches with compile-time branches
//  - Can result in deeper nesting of if statements within a function
//  - Causes a surprising number of silent bugs when almost-correct objects are passed but no action is taken
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zozxjn">https://godbolt.org/z/zozxjn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys {
  constexpr auto process(const auto&amp; t) {
    if constexpr (requires{ condition = t; }) {
      condition = t;
    } else if constexpr (requires{ t.price;}) {
      return condition and condition(t.price);
    } else {
      static_assert(not sizeof(t), &quot;type t not supported!&quot;);
      return false;
    }
  }

 private:
  bool (*condition)(int){};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zYe7ao">https://godbolt.org/z/zYe7ao</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys {
private:
  using condition_t = auto(*) (int) -&gt; bool;
  condition_t condition = nullptr;

  template &lt;typename T&gt;
  constexpr static inline bool always_false = false;

public:
  template &lt;typename T&gt;
  constexpr auto process(const T&amp; t) {
    if constexpr (requires { condition = t; }) {
      condition = t;
    } else if constexpr (requires { condition(t.price); }) {
      return condition and condition(t.price);
    } else {
      static_assert(always_false&lt;T&gt;, &quot;Incorrect argument to process&quot;);
    }
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oEvh6T">https://godbolt.org/z/oEvh6T</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename T&gt;
concept priced_object = requires
{
    T {}.price;
};
}

struct sys {
    using condition_func_t = std::function&lt;bool(int)&gt;;

    auto process(const auto&amp; input)
    {
        if constexpr (requires { condition = input; }) {
            condition = input;
        } else if constexpr (detail::priced_object&lt;decltype(input)&gt;) {
            if (not condition.has_value()) {
                return false;
            }
            return (*condition)(input.price);
        } else {
            return false;
        }
    }

    std::optional&lt;condition_func_t&gt; condition {};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aoeszf">https://godbolt.org/z/aoeszf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys {
  auto process(const auto&amp; event) -&gt; decltype(auto) {
    if constexpr (requires { condition = event; }) {
      condition = event;
    } else if constexpr (requires { condition(event.price); }) {
      return condition and condition(event.price);
    }
  }

private:
  bool (*condition)(int) = nullptr;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dnT1h7">https://godbolt.org/z/dnT1h7</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys{
    template&lt;class T &gt;
    auto process( T arg )
    {
        if constexpr ( requires{ f=arg ; } )
            f = arg;
        else if( requires{ f(arg.price);} &amp;&amp; f)
            return f(arg.price);
        return false;
    }
    std::function&lt;bool(int)&gt; f;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nKso7E">https://godbolt.org/z/nKso7E</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct sys {
    template&lt;typename T&gt;
    bool constexpr process(T t) {
        if constexpr( requires(int a){ t.operator()(a); }) {
            procF = t;
        } else if (procF) {
            return procF(t.price);
        }
        return false;
    }
    std::function&lt;bool(int)&gt; procF;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ozhM8s">https://godbolt.org/z/ozhM8s</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>209 - Did you know about `Policy Based Design`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/209.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/209.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>Policy Based Design</code>?</strong></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design">https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class TPolicy&gt;
struct foo : TPolicy {
  static constexpr auto bar() {
    return TPolicy::bar();
  }
};

template&lt;auto N&gt;
struct policy { static constexpr auto bar() { return N; } };

static_assert(0 == foo&lt;policy&lt;0&gt;&gt;::bar());
static_assert(42 == foo&lt;policy&lt;42&gt;&gt;::bar());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Mhhs9q">https://godbolt.org/z/Mhhs9q</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement <code>foo::bar</code> which is noexcept when <code>noexcept_policy</code> is set and returns a sum of <code>execute_policy::bar</code> calls?</strong></p>
</li>
<li>
<p>Types not satisfying any policy should be ignored</p>
</li>
<li>Double points for explaining what advantages <code>Policy Based Design</code> has over passing <code>Enums/Booleans</code>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto bar() noexcept/*TODO*/ {
    return 0;/*TODO*/
  }
};

template&lt;auto N&gt; struct execute_policy { static constexpr auto bar() { return N; } };
struct noexcept_policy { };
struct ignore { };

static_assert(not noexcept(foo&lt;&gt;::bar()));
static_assert(not noexcept(foo&lt;ignore&gt;::bar()));
static_assert(noexcept(foo&lt;noexcept_policy&gt;::bar()));
static_assert(noexcept(foo&lt;noexcept_policy, ignore&gt;::bar()));
static_assert(noexcept(foo&lt;ignore, noexcept_policy, ignore&gt;::bar()));
static_assert(noexcept(foo&lt;ignore, noexcept_policy, ignore, execute_policy&lt;0&gt;&gt;::bar()));

static_assert(42 == foo&lt;execute_policy&lt;42&gt;&gt;::bar());
static_assert(42 == foo&lt;ignore, execute_policy&lt;42&gt;&gt;::bar());
static_assert(42 == foo&lt;ignore, execute_policy&lt;42&gt;, ignore&gt;::bar());
static_assert(100 == foo&lt;ignore, execute_policy&lt;42&gt;, ignore, execute_policy&lt;58&gt;&gt;::bar());
static_assert(3 == foo&lt;execute_policy&lt;1&gt;, noexcept_policy, execute_policy&lt;2&gt;, noexcept_policy&gt;::bar());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a6M6sr">https://godbolt.org/z/a6M6sr</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TPolicies&gt;
struct foo {
  template&lt;class T &gt; struct  no_bar{ constexpr static bool value = !requires{ T::bar();}; };
  static constexpr auto bar() noexcept( !std::is_same_v&lt; mp_find&lt;mp_list&lt;TPolicies...&gt;,  class noexcept_policy &gt;, mp_size&lt;mp_list&lt;TPolicies...&gt; &gt; &gt; )/*TODO*/ {
    using L = mp_remove_if&lt;mp_list&lt; TPolicies... &gt;, no_bar &gt;;
    return []&lt; class ... Ts &gt;( mp_list&lt;Ts... &gt; ){ return ( (Ts::bar()) + ... + 0 ) ;}( L{} );
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/azhGoh">https://godbolt.org/z/azhGoh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">// Advantages of policies? They're basically the [https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
// Decoupled interfaces, adherence to the open/closed principle, etc.

template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto bar() noexcept((std::is_same_v&lt;TPolicies, struct noexcept_policy&gt; or ...)) {
    constexpr auto run_bar = []&lt;class TPolicy&gt;() {
      if constexpr (requires { TPolicy::bar(); }) {
        return TPolicy::bar();
      } else {
        return 0;
      }
    };
    return (0 + ... + run_bar.template operator()&lt;TPolicies&gt;());
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cvzr7q">https://godbolt.org/z/cvzr7q</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct noexcept_policy { };

template&lt;class...&gt;
struct has_noexcept_policy;

template&lt;&gt;
struct has_noexcept_policy&lt;&gt; {
  static constexpr auto value = false;
};

template&lt;class T, class... Ts&gt;
struct has_noexcept_policy&lt;T, Ts...&gt; {
  static constexpr auto value = [] {
    if constexpr (std::is_same_v&lt;T, noexcept_policy&gt;) {
      return true;
    } else {
      return has_noexcept_policy&lt;Ts...&gt;::value;
    }
  }();
};

template&lt;class TPolicy&gt;
struct execute_policy_bar {
  static constexpr auto value = [] {
    if constexpr (requires { { TPolicy::bar() } -&gt; std::integral; }) {
      return TPolicy::bar();
    } else {
      return 0;
    }
  }();
};

template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto bar() noexcept(has_noexcept_policy&lt;TPolicies...&gt;::value) {
    return (0 + ... + execute_policy_bar&lt;TPolicies&gt;::value);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Pn1x3n">https://godbolt.org/z/Pn1x3n</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template&lt;class T&gt;
concept has_func_bar = requires { T::bar(); };
}

template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto has_noexcept_policy = (std::is_same_v&lt;TPolicies, struct noexcept_policy&gt; or ...);

  [[nodiscard]] static constexpr auto bar() noexcept(has_noexcept_policy) {
    [[maybe_unused]] constexpr auto run_execute_policy = []&lt;class TPolicy&gt;(){
       if constexpr(detail::has_func_bar&lt;TPolicy&gt;) {
           return TPolicy{}.bar();
       } else {
           return 0;
       }
    };

    return (run_execute_policy.template operator()&lt;TPolicies&gt;() + ... + 0);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KWTqYe">https://godbolt.org/z/KWTqYe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt; concept HasBar = requires(T) {  T::bar(); };
template&lt;HasBar T&gt; auto constexpr CallBar() { return T::bar(); }
template&lt;typename T&gt; auto constexpr CallBar() { return 0; }

template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto bar() noexcept((std::is_same_v&lt;TPolicies, noexcept_policy&gt; || ...)) {
      return (CallBar&lt;TPolicies&gt;() + ...+ 0);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fa199r">https://godbolt.org/z/fa199r</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... TPolicies&gt;
struct foo {
  static constexpr auto bar() noexcept((std::is_same_v&lt;struct noexcept_policy, TPolicies&gt; or ...)) {
    return ([] {
      if constexpr (requires { TPolicies::bar(); }) {
        return TPolicies::bar();
      } else {
        return 0;
      }
    }() + ... + 0);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/65r6bv">https://godbolt.org/z/65r6bv</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>208 - Did you know that default template arguments can be explored with template template arguments?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/208.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/208.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that default template arguments can be explored with template template arguments?</strong></p>
</li>
<li>
<p><a href="https://eel.is/c++draft/temp.arg.template">https://eel.is/c++draft/temp.arg.template</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template&lt;class...&gt;
  struct type_defaults{};

  template&lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct type_defaults&lt;T&lt;Ts...&gt;&gt;{
    using type = std::tuple&lt;Ts...&gt;;
  };
} // namespace detail

template&lt;template&lt;class...&gt; class T&gt;
using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

template&lt;class = int&gt; struct foo{};
static_assert(std::is_same_v&lt;std::tuple&lt;int&gt;, type_defaults_t&lt;foo&gt;&gt;);

template&lt;class TQuant = class Quant, class TLab = class Lab&gt; struct bar{};
static_assert(std::is_same_v&lt;std::tuple&lt;Quant, Lab&gt;, type_defaults_t&lt;bar&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/TWPo6j">https://godbolt.org/z/TWPo6j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>rebind_defaults_t</code> type trait which rebinds template arguments depending on provided bindings... (<code>bind&lt;From, To&gt;</code>)</strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct bind;

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t = /*TODO*/T&lt;Ts...&gt;;

template&lt;class = int&gt; struct foo{};
static_assert(std::is_same_v&lt;foo&lt;&gt;, rebind_defaults_t&lt;foo&gt;&gt;);
static_assert(std::is_same_v&lt;foo&lt;int&gt;, rebind_defaults_t&lt;foo&gt;&gt;);
static_assert(std::is_same_v&lt;foo&lt;double&gt;, rebind_defaults_t&lt;
  foo,
  bind&lt;int, double&gt;
&gt;&gt;);

template&lt;class TQuant = class Quant, class TLab = class Lab&gt; struct bar{};
static_assert(std::is_same_v&lt;bar&lt;Quant, Lab&gt;, rebind_defaults_t&lt;bar&gt;&gt;);
static_assert(std::is_same_v&lt;bar&lt;int, Lab&gt;, rebind_defaults_t&lt;
  bar,
  bind&lt;Quant, int&gt;
&gt;&gt;);
static_assert(std::is_same_v&lt;bar&lt;Quant, double&gt;, rebind_defaults_t&lt;
  bar,
  bind&lt;class Lab, double&gt;
&gt;&gt;);
static_assert(std::is_same_v&lt;bar&lt;int, double&gt;, rebind_defaults_t&lt;
  bar,
  bind&lt;Quant, int&gt;,
  bind&lt;Lab, double&gt;
&gt;&gt;);
static_assert(std::is_same_v&lt;bar&lt;int, double&gt;, rebind_defaults_t&lt;
  bar,
  bind&lt;Lab, double&gt;,
  bind&lt;Quant, int&gt;
&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/se4rc7">https://godbolt.org/z/se4rc7</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class T, class U&gt; struct bind {};

namespace detail {
template &lt;class... Ts&gt; struct rebind_map : Ts... {};

template &lt;class T, class U&gt; constexpr auto rebind_lookup(const bind&lt;T, U&gt;&amp;) -&gt; U;
template &lt;class T&gt; constexpr auto rebind_lookup(...) -&gt; T;

template &lt;class TMap&gt;
struct rebinder {
  template &lt;class...&gt; struct rebind_types{};

  template &lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct rebind_types&lt;T&lt;Ts...&gt;&gt; {
    using type = T&lt;decltype(rebind_lookup&lt;Ts&gt;(std::declval&lt;TMap&gt;()))...&gt;;
  };
};
} // namespace detail

template &lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t =
  typename detail::rebinder&lt;detail::rebind_map&lt;Ts...&gt;&gt;::template rebind_types&lt;T&lt;&gt;&gt;::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PY49f8">https://godbolt.org/z/PY49f8</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template&lt;class...&gt; struct type_defaults{};

  template&lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct type_defaults&lt;T&lt;Ts...&gt;&gt;{
    using type = std::tuple&lt;Ts...&gt;;
  };
} // namespace detail

template&lt;template&lt;class...&gt; class T&gt;
using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

template&lt;class...&gt; struct bind;
template&lt;class L, class T &gt; struct unbind;
template&lt;class L, class T1,class T2 &gt; struct unbind&lt;L, bind&lt;T1,T2&gt;&gt;
{
    using type = boost::mp11::mp_replace&lt;L,T1,T2&gt;;
};
template&lt;class L, class T &gt; using unbind_t = typename unbind&lt;L,T&gt;::type;
template&lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t = boost::mp11::mp_apply&lt;T,boost::mp11::mp_fold&lt;boost::mp11::mp_list&lt;Ts...&gt;,type_defaults_t&lt;T&gt;,unbind_t&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K8W8h4">https://godbolt.org/z/K8W8h4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    template&lt;class...&gt; struct type_defaults {};

    template&lt;template&lt;class...&gt; class T, class... Ts&gt;
    struct type_defaults&lt;T&lt;Ts...&gt;&gt; {
        using type = T&lt;Ts...&gt;;
    };

    template&lt;template&lt;class...&gt; class T&gt;
    using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

    template&lt;class T&gt; struct unhandled {
        using type = T;
    };

    template&lt;class T&gt; struct handled {
        using type = T;
    };

    template&lt;class T&gt;
    using trait_t = typename T::type;
} // namespace detail

template&lt;class From, class To&gt; struct bind {
    template&lt;class T&gt;
    using fn = mp11::mp_if&lt;
        mp11::mp_same&lt;T, detail::unhandled&lt;From&gt;&gt;,
        detail::handled&lt;To&gt;,
        T&gt;;
};

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t = mp11::mp_transform_q&lt;
    mp11::mp_compose_q&lt;
        mp11::mp_quote&lt;detail::unhandled&gt;,
        Ts...,
        mp11::mp_quote&lt;detail::trait_t&gt;&gt;,
    detail::type_defaults_t&lt;T&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/n8rvso">https://godbolt.org/z/n8rvso</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template&lt;class...&gt;
  struct type_defaults{};

  template&lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct type_defaults&lt;T&lt;Ts...&gt;&gt;{
    using type = std::tuple&lt;Ts...&gt;;
  };

  template&lt;template&lt;class...&gt; class, class...&gt; struct rebind_defaults{};
  template&lt;template&lt;class...&gt; class T, class... TIfs, class... TImpls&gt;
  struct rebind_defaults&lt;T, std::tuple&lt;TIfs...&gt;, TImpls...&gt;{
    template&lt;class U, class&gt; struct rebind { using type = U; };
    template&lt;class U, template&lt;class, class&gt; class TBind, class TIf, class TImpl&gt; struct rebind&lt;U, TBind&lt;TIf, TImpl&gt;&gt; { using type = TImpl; };
    using type = T&lt;typename rebind&lt;TIfs, boost::mp11::mp_map_find&lt;boost::mp11::mp_inherit&lt;TImpls...&gt;, TIfs&gt;&gt;::type...&gt;;
  };

} // namespace detail

template&lt;template&lt;class...&gt; class T&gt;
using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t = typename detail::rebind_defaults&lt;T, type_defaults_t&lt;T&gt;, Ts...&gt;::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yrer9f">https://godbolt.org/z/Yrer9f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template&lt;class...&gt; struct type_defaults{};

  template&lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct type_defaults&lt;T&lt;Ts...&gt;&gt;{
    using type = std::tuple&lt;Ts...&gt;;
  };
} // namespace detail

template&lt;template&lt;class...&gt; class T&gt;
using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

template&lt;class...&gt; struct bind;

template&lt;class...&gt; struct rebind_next;
template&lt;class D&gt; struct rebind_next&lt;D&gt; { using type = D;  };

template&lt;class D, class R, class ...Ms, class...Rs&gt;
struct rebind_next&lt;D, bind&lt;D,R&gt;, bind&lt;Ms,Rs&gt;...&gt; { using type = R; };
template&lt;class D, class M, class R, class ...Ms, class... Rs&gt;
struct rebind_next&lt;D, bind&lt;M,R&gt;, bind&lt;Ms,Rs&gt;...&gt; {
    using type = typename rebind_next&lt;D, bind&lt;Ms,Rs&gt;...&gt;::type;
};

template&lt;class...&gt; struct list;
template&lt;class ...Fs, class D, class ...Ds, class...Ms, class ...Rs&gt;
struct rebind_next&lt; list&lt;Fs...&gt;, list&lt;D, Ds...&gt;, bind&lt;Ms, Rs&gt;...&gt; {
    using type = typename rebind_next&lt; list&lt;Fs..., typename rebind_next&lt;D, bind&lt;Ms, Rs&gt; ...&gt;::type &gt;, list&lt;Ds...&gt;, bind&lt;Ms,Rs&gt;...&gt;::type;
};
template&lt;class ...Fs, class D, class...Ms, class ...Rs&gt;
struct rebind_next&lt; list&lt;Fs...&gt;, list&lt;D&gt;, bind&lt;Ms,Rs&gt;...&gt; {
    using type = list&lt;Fs..., typename rebind_next&lt;D, bind&lt;Ms,Rs&gt;...&gt;::type&gt;;
};


template&lt;template&lt;class...&gt; class N, class O&gt; struct rename;
template&lt;template&lt;class...&gt; class N , template&lt;class...&gt; class O, class ...Es&gt;
struct rename&lt; N, O&lt;Es...&gt;&gt; { using type = N&lt;Es...&gt;;  };

template&lt;class...&gt; struct rebind_defaults;
template&lt;template&lt;class...&gt; class T, class... Ds, class ...Ms, class... Rs&gt;
struct rebind_defaults&lt;T&lt;Ds...&gt;, bind&lt;Ms, Rs&gt;...&gt; {
    using rebound_list = typename rebind_next&lt; list&lt;&gt;, list&lt;Ds...&gt;, bind&lt;Ms,Rs&gt;...&gt;::type;
    using type = typename rename&lt; T, rebound_list&gt;::type;
};

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
using rebind_defaults_t = typename rebind_defaults&lt;T&lt;&gt;, Ts...&gt;::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rKPG9h">https://godbolt.org/z/rKPG9h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template&lt;class...&gt; struct type_defaults{};

  template&lt;template&lt;class...&gt; class T, class... Ts&gt;
  struct type_defaults&lt;T&lt;Ts...&gt;&gt;{
    using type = std::tuple&lt;Ts...&gt;;
  };

  template&lt;class T, class&gt;
  struct process_bind {
    using type = T;
  };
  template&lt;class T, template&lt;class, class&gt; class TBind, class TReplace&gt;
  struct process_bind&lt;T, TBind&lt;T, TReplace&gt;&gt; {
    using type = TReplace;
  };

  template&lt;class T, class TBind&gt;
  using process_bind_t = process_bind&lt;T, TBind&gt;::type;

  template&lt;template&lt;class...&gt; class, class...&gt;
  struct rebind {};
  template&lt;template&lt;class...&gt; class TContainer, template&lt;class...&gt; class TDefaultContainer, class... TDefaults, class... TBinds&gt;
  struct rebind&lt;TContainer, TDefaultContainer&lt;TDefaults...&gt;, TBinds...&gt; {
    using binds_t = boost::mp11::mp_list&lt;TBinds...&gt;;
    using type = TContainer&lt;process_bind_t&lt;TDefaults, boost::mp11::mp_map_find&lt;binds_t, TDefaults&gt;&gt;...&gt;;
  };

  namespace test {
    template&lt;class...&gt; struct test {};

    static_assert(std::is_same_v&lt;process_bind_t&lt;int, test&lt;int, float&gt;&gt;, float&gt;);
    static_assert(std::is_same_v&lt;process_bind_t&lt;int, test&lt;long, float&gt;&gt;, int&gt;);
  }
} // namespace detail

template&lt;template&lt;class...&gt; class T&gt;
using type_defaults_t = typename detail::type_defaults&lt;T&lt;&gt;&gt;::type;

template&lt;class...&gt; struct bind;
template&lt;template&lt;class...&gt; class T, class... TBinds&gt;
using rebind_defaults_t = detail::rebind&lt;T, type_defaults_t&lt;T&gt;, TBinds...&gt;::type;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a88PzG">https://godbolt.org/z/a88PzG</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>207 - Did you know about the proposal to add constexpr function parmaters?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/207.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/207.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about the proposal to add constexpr function parmaters?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1045">http://wg21.link/p1045</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">#if __cpp_has_constexpr_function_parameters
  void foo(constexpr int x) {
    static_assert(42 == x);
  }

  int main() {
    foo(42);
  }
#else
  template&lt;int x&gt; void foo() {
    static_assert(42 == x);
  }

  int main() {
    foo&lt;42&gt;();
  }
#endif
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ojrqd7">https://godbolt.org/z/ojrqd7</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a compile-time and run-time map-like accessors for tuple?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;char...&gt; constexpr auto operator&quot;&quot;_id(); // TODO
template&lt;class...&gt; struct tuple; // TODO

int main() {
  using namespace boost::ut;

  &quot;compile-time tuple map-like access&quot;_test = [] {
    constexpr tuple ct{42, [](auto x){ return x; }};
    expect(constant&lt;42_i == ct[0_id]&gt;);
    expect(constant&lt;43_i == ct[1_id](43)&gt;);
  };

  &quot;run-time tuple map-like access&quot;_test = [] {
    const tuple rt = tuple{1, 2.0};
    expect(throws&lt;std::bad_cast&gt;([&amp;rt]{std::any_cast&lt;float&gt;(rt[1]);}));
    expect(1_i == std::any_cast&lt;int&gt;(rt[0]));
    expect(2.0_d == std::any_cast&lt;double&gt;(rt[1]));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/8vGqj3">https://godbolt.org/z/8vGqj3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt; constexpr auto operator&quot;&quot;_id() {
  constexpr std::array chars{Cs...};
  constexpr auto index = std::reduce(std::cbegin(chars), std::cend(chars), 0,
                                     [] (const auto i, const auto digit) { return i * 10 + (digit - '0'); });
  return std::integral_constant&lt;int, index&gt;{};
}

template&lt;class... Ts&gt; struct tuple : std::tuple&lt;Ts...&gt; {
  using std::tuple&lt;Ts...&gt;::tuple;

  template &lt;class T, auto N&gt;
  constexpr const auto&amp; operator[](std::integral_constant&lt;T, N&gt;) const {
    return std::get&lt;N&gt;(*this);
  }

  constexpr const auto operator[](int i) const {
    return [&amp;] &lt;auto... Is&gt; (std::index_sequence&lt;Is...&gt;) {
      using F = auto (*)(const tuple&lt;Ts...&gt;&amp;) -&gt; std::any;
      constexpr std::array&lt;F, sizeof...(Is)&gt; fs{
        [] (const auto&amp; t) -&gt; std::any { return t[std::integral_constant&lt;int, Is&gt;{}]; }...
      };
      return fs[i](*this);
    }(std::index_sequence_for&lt;Ts...&gt;{});
  }
};

template &lt;class... Ts&gt;
tuple(Ts...) -&gt; tuple&lt;Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GaPYcb">https://godbolt.org/z/GaPYcb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt;
constexpr auto operator&quot;&quot;_id() {
  return []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return std::integral_constant&lt;int, ((int(std::pow(10, sizeof...(Ns) - Ns - 1)) * (Cs - '0')) + ...)&gt;{};
  }(std::make_index_sequence&lt;sizeof...(Cs)&gt;{});
}

template&lt;class... Ts&gt;
struct tuple : std::tuple&lt;Ts...&gt; {
  using std::tuple&lt;Ts...&gt;::tuple;

  template&lt;class TId&gt; constexpr decltype(auto) operator[](const TId id) const {
    if constexpr (std::is_integral_v&lt;TId&gt;) {
      return std::apply([id](auto... args) { return std::array{std::any{args}...}[id];  }, std::tuple&lt;Ts...&gt;(*this));
    } else {
      return std::get&lt;TId{}&gt;(*this);
    }
  }
};
template&lt;class... Ts&gt; tuple(Ts...) -&gt; tuple&lt;Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vMWaa9">https://godbolt.org/z/vMWaa9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">using integer_t = int;

namespace details {  // Intentionally using details instead of detail to avoid
                     // ambiguous namespace
[[nodiscard]] constexpr auto apply_power(const auto power, const auto val) {
  return static_cast&lt;integer_t&gt;(std::pow(10, power)) * (val - '0');
}
}  // namespace details

template &lt;char... Cs&gt;
[[nodiscard]] constexpr auto operator&quot;&quot;_id() {
  constexpr auto num_chars = sizeof...(Cs);

  return []&lt;auto... Is&gt;(const std::index_sequence&lt;Is...&gt;) {
    return std::integral_constant&lt;
        integer_t, (details::apply_power(num_chars - Is - 1, Cs) + ...)&gt;{};
  }
  (std::make_index_sequence&lt;num_chars&gt;{});
};

template &lt;class... Ts&gt;
struct tuple : std::tuple&lt;Ts...&gt; {
  using std::tuple&lt;Ts...&gt;::tuple;

  template &lt;auto Index&gt;
  [[nodiscard]] constexpr auto operator[](
      const std::integral_constant&lt;integer_t, Index&gt;) const {
    return std::get&lt;Index&gt;(*this);
  }

  [[nodiscard]] constexpr auto operator[](const auto index) const {
    return boost::mp11::mp_with_index&lt;sizeof...(Ts)&gt;(
        index, [&amp;](const auto I) { return std::any(std::get&lt;I&gt;(*this)); });
  }
};
template &lt;class... Ts&gt;
tuple(Ts...) -&gt; tuple&lt;Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oKn8zs">https://godbolt.org/z/oKn8zs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt; char ... str &gt;
constexpr auto stoi = []()
{
    constexpr int N = sizeof ... (str) ;
    return []&lt;auto ... Is&gt; ( std::index_sequence&lt; Is ... &gt; ){
        std::size_t m = std::pow( 10, N );//not constexpr but works under gcc
        return ( 0 + ... + ( ( str - '0') * (m/=10)  )  );
    }( std::make_index_sequence&lt;N&gt;{} );
} ();

template&lt; char ... str &gt; constexpr auto operator&quot;&quot;_id()
{
    return std::index_sequence&lt; stoi&lt;str...&gt; &gt;{} ;
}

template &lt;class T, class ... Ts &gt;
struct tuple:tuple&lt;Ts...&gt;
{
    constexpr tuple(T data, Ts... datas):tuple&lt;Ts...&gt;(datas...),data{data}{}
    T data;
    std::any operator[]( int i ) const
    {
        if ( i == 0)
            return data;
        else
            return tuple&lt;Ts...&gt;::operator[](i-1);
    }
    template&lt;std::size_t I&gt;
    constexpr auto operator[]( std::index_sequence&lt;I&gt; )  const
    {
        if constexpr ( I == 0 ){
            return data;
        } else
        {
            return tuple&lt;Ts...&gt;::operator[](std::index_sequence&lt;I-1&gt;{});
        }
    }
};
template &lt;class T&gt;
struct tuple&lt;T&gt;
{
    std::any operator[]( int ) const
    {
        return data;
    }
    template&lt;std::size_t I&gt;
    constexpr auto operator[]( std::index_sequence&lt;I&gt; ) const
    {
        return data;
    }

    T data;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/89f9eb">https://godbolt.org/z/89f9eb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    template&lt;class T, char C, char... Cs&gt;
    consteval T make_integer_constant() {
        if constexpr (sizeof...(Cs) == 0) return C - '0';
        else return make_integer_constant&lt;T, C&gt;() * 10 + make_integer_constant&lt;T, Cs...&gt;();
    }
} // namespace detail

template&lt;char... Cs&gt;
consteval auto operator&quot;&quot;_id() {
    constexpr auto value = detail::make_integer_constant&lt;std::size_t, Cs...&gt;();
    return std::integral_constant&lt;std::remove_cvref_t&lt;decltype(value)&gt;, value&gt;{};
}

template&lt;class... Ts&gt;
struct tuple {
    constexpr tuple(Ts&amp;&amp;... args) : t{std::forward&lt;Ts&gt;(args)...} {}

    // compile-time
    template&lt;std::size_t I&gt;
    constexpr auto operator[] (std::integral_constant&lt;std::size_t, I&gt;) const {
        return std::get&lt;I&gt;(t);
    }

    // run-time
    constexpr auto operator[] (std::size_t i) const {
        return [&amp;] &lt;std::size_t... Is&gt; (std::index_sequence&lt;Is...&gt;) {
            constexpr std::array&lt;std::any(*)(const tuple&amp;), sizeof...(Is)&gt; fs{
                [] (const auto&amp; t) -&gt; std::any { return t[std::integral_constant&lt;std::size_t, Is&gt;{}]; }...
            };

            return fs[i](*this);
        }(std::index_sequence_for&lt;Ts...&gt;{});
    }

private:
    std::tuple&lt;Ts...&gt; t;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1zGrnY">https://godbolt.org/z/1zGrnY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;int I&gt; struct Id{};

template&lt;char...Cs&gt; constexpr auto operator&quot;&quot;_id() {
    constexpr std::array&lt;int, sizeof...(Cs)&gt; digits{Cs-'0'...};
    constexpr int number = std::accumulate(digits.begin(), digits.end(), 0, [](auto a, auto b) { return 10*a+b;});
    return Id&lt;number&gt;{};
}

template&lt;class Tp, size_t N=0&gt;
std::any runtime_get(Tp const&amp; tp, size_t idx) {
    if(N==idx)
        return std::get&lt;N&gt;(tp);
    if constexpr( N+1 &lt; std::tuple_size_v&lt;Tp&gt;)
        return runtime_get&lt;Tp, N+1&gt;(tp, idx);
    return {};
}

template&lt;class...Args&gt; struct tuple : std::tuple&lt;Args...&gt; {
    constexpr tuple(Args...args) : std::tuple&lt;Args...&gt;(args...) {}
    template&lt;int I&gt; constexpr auto operator[](Id&lt;I&gt;) const { return std::get&lt;I&gt;(*this); }
    auto operator[](int I) const { return runtime_get(static_cast&lt;std::tuple&lt;Args...&gt;&gt;(*this),I); }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z77Tdn">https://godbolt.org/z/z77Tdn</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>206 - Did you know about proposal to add support for recursive lambdas?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/206.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/206.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about proposal to add support for recursive lambdas?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0839">http://wg21.link/p0839</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">// [http://wg21.link/p0839](http://wg21.link/p0839)
#if __has_feature(cpp_recursive_lambdas)
  auto fib = [](auto x) -&gt; int {
    if (x &lt;= 1) {
      return 1;
    } else {
      return fib(x-1) + fib(x-2);
    }
  };
#else
  auto fib = [](auto x, const auto&amp; fib) -&gt; int {
    if (x &lt;= 1) {
      return 1;
    } else {
      return fib(x-1, fib) + fib(x-2, fib);
    }
  };
#endif

int main() {
  std::cout &lt;&lt; fib(7, fib); // prints 21
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6zPxeM">https://godbolt.org/z/6zPxeM</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a constexpr recursive lambda <code>sum_years</code> which sum up all years up to a given one?</strong></p>
</li>
<li>
<p>It may require extending <code>-fconstexpr-depth</code></p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_years = [](auto year) { /*TODO*/ return 0; }

static_assert(0 ==  sum_years(0));
static_assert(1 ==  sum_years(1));
static_assert(3 ==  sum_years(2));
static_assert(6 == sum_years(3));
static_assert(2'041'210 == sum_years(2020));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/eTYxM5">https://godbolt.org/z/eTYxM5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-c++">constexpr auto sum_years = [](auto year) {
    constexpr auto sum_me = [](auto year, const auto&amp; sum_me) {
        if (year == 0) { return 0; }
        return year + sum_me(year - 1, sum_me);
    };
    return sum_me(year, sum_me);
};

static_assert(0 ==  sum_years(0));
static_assert(1 ==  sum_years(1));
static_assert(3 ==  sum_years(2));
static_assert(6 == sum_years(3));
static_assert(2'041'210 == sum_years(2020));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ao4fxa">https://godbolt.org/z/ao4fxa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    constexpr auto sum = [] (const auto&amp; f, auto n, auto acc) {
        if (n == 0) {
            return acc;
        } else {
            return f(f, n-1, acc + n);
        }
    };
}
constexpr auto sum_years = [](auto year) {
    return detail::sum(detail::sum, year, 0);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5v43hq">https://godbolt.org/z/5v43hq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    constexpr auto accumulator = [](const auto x, const auto y){
        return x + y;
    };

    template&lt;auto AccumulatorFn&gt;
    constexpr auto sum = [](const auto&amp; fn, const auto current,  const auto accumulated_value) {
        if (current == 0) {
            return accumulated_value;
        }
        else {
            return fn(fn, current - 1, AccumulatorFn(current, accumulated_value));
        }
    };
}

constexpr auto sum_years = [](const auto year) {
    return detail::sum&lt;detail::accumulator&gt;(detail::sum&lt;detail::accumulator&gt;, year, 0);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xGEYo4">https://godbolt.org/z/xGEYo4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_years = [](auto year) {
  auto impl = [year](auto i, auto&amp; impl) mutable -&gt; std::size_t {
    if (i &lt;= year) {
      return i + impl(i + 1, impl);
    } else {
      return {};
    }
  };
  return impl(0u, impl);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WWfxqq">https://godbolt.org/z/WWfxqq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_years = [](auto year ){
    auto impl = [](auto year, auto const &amp; impl )
    {
        if( year == 0 ) return 0;
        return year + impl(year -1, impl);
    };
    return impl(year,impl);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c9sWcb">https://godbolt.org/z/c9sWcb</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_years = [] (auto year) {
    constexpr auto sy_impl = [](auto year, const auto&amp; sy_impl) -&gt; decltype(year) {
        return year == 0 ? 0 : year + sy_impl(year-1, sy_impl);
    };
    return sy_impl(year, sy_impl);
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a68cWc">https://godbolt.org/z/a68cWc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto sum_years = []{
    constexpr auto impl = [](const auto&amp; f, auto year) -&gt; decltype(year) {
        return year ? year + f(f, year - 1) : 0;
    };

    return std::bind_front(impl, impl);
}();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dMsMhq">https://godbolt.org/z/dMsMhq</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>205 - Did you know that C++20 `std::to_array` supports creating from string literals?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/205.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/205.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 <code>std::to_array</code> supports creating from string literals?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/array#overview">http://eel.is/c++draft/array#overview</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(1 == std::size(std::to_array(&quot;&quot;)));
static_assert(0 == std::to_array(&quot;&quot;)[0]);

static_assert(4 == std::size(std::to_array(&quot;foo&quot;)));
static_assert(0 == std::to_array(&quot;foo&quot;)[3]);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5bnPrj">https://godbolt.org/z/5bnPrj</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a <code>xmas_tree</code> variable template which creates a Xmas-tree array with a given size?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size, class T = char&gt;
constexpr const auto xmas_tree = /*TODO*/std::array&lt;T, (Size+1) * ((Size*2) - 1) + 1&gt;{};

static_assert(
  xmas_tree&lt;3&gt;
  ==
  std::to_array(
    &quot;  #  &quot;
    &quot; ### &quot;
    &quot;#####&quot;
    &quot;  #  &quot;
  )
);

static_assert(
  xmas_tree&lt;5&gt;
  ==
  std::to_array(
    &quot;    #    &quot;
    &quot;   ###   &quot;
    &quot;  #####  &quot;
    &quot; ####### &quot;
    &quot;#########&quot;
    &quot;    #    &quot;
  )
);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z93hhf">https://godbolt.org/z/z93hhf</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size, class T = char&gt;
constexpr const auto xmas_tree = []&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
  std::array&lt;T, (Size+1) * ((Size*2) - 1) + 1&gt; arr{};

  auto row = [it = arr.begin()](size_t i) mutable {
    it = std::fill_n(it, Size - i, ' ');
    it = std::fill_n(it, i * 2 - 1, '#');
    it = std::fill_n(it, Size - i, ' ');
  };

  (row(Is + 1), ..., row(1));

  return arr;
}(std::make_index_sequence&lt;Size&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oKMTqY">https://godbolt.org/z/oKMTqY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size, class T = char&gt;
constexpr const auto xmas_tree = []&lt;auto ... Is&gt;(std::index_sequence&lt;Is...&gt;)
{
    static_assert( Size &gt; 0 );
    auto constexpr M = Size * 2  - 1 ;
    auto constexpr Center = Size - 1 ;
    return std::array&lt;T, (Size+1) * (Size * 2  - 1)  + 1&gt; {
        []&lt;auto I &gt;(std::index_sequence&lt;I&gt;) {
            auto constexpr R = I/ M ;
            auto constexpr C = I - R * M;
            auto constexpr CL = (R != Size? Size-R-1:Size-1);
            auto constexpr CH = (R != Size? Size+R-1:Size-1);
            if constexpr( C &gt;= CL &amp;&amp; C &lt;= CH )
                return '#';
            else
                return ' ';
        }(std::index_sequence&lt;Is&gt;{}) ...
    };
}(std::make_index_sequence&lt;(Size+1) * (Size * 2  - 1) &gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5evv39">https://godbolt.org/z/5evv39</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto Size, class T&gt;
consteval auto make_xmas_tree() {
    constexpr const auto rows = Size + 1;
    constexpr const auto cols = (Size * 2) - 1;
    std::array&lt;T, rows * cols + 1&gt; tree{};
    tree.fill(' ');
    for (auto mid = cols/2, width = 0;
         mid &lt; rows * cols;
         mid += cols, ++width, width %= Size) {
      std::fill_n(&amp;tree[mid - width], width * 2 + 1, '#');
    }
    tree.back() = 0;
    return tree;
}

template&lt;auto Size, class T = char&gt;
constexpr const auto xmas_tree = make_xmas_tree&lt;Size, T&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fEa9v5">https://godbolt.org/z/fEa9v5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size, class T= char&gt;
constexpr const auto tree()
{
    std::array&lt;T, (Size+1)*((Size*2)-1)+1&gt; tree{};
    for(uint32_t r=0; r&lt;Size+1; r++)
        for(int32_t c=0; c&lt;2*Size-1; c++)
            if(r &lt; Size)
                tree[r*(2*Size-1)+c] = std::abs(c-(Size-1)) &gt;r ? ' ' : '#';
            else
                tree[r*(2*Size-1)+c] = std::abs(c-(Size-1)) != 0 ? ' ' : '#';
    return tree;
}

template&lt;auto Size, class T = char&gt;
constexpr const auto xmas_tree = tree&lt;Size, T&gt;();
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fjs58z">https://godbolt.org/z/fjs58z</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>204 - Did you know that you can implement a compile-time map with C++?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/204.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/204.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that you can implement a compile-time map with C++?</strong></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/1_75_0/libs/mp11/doc/html/mp11.html#mp_map_find_m_k">https://www.boost.org/doc/libs/1_75_0/libs/mp11/doc/html/mp11.html#mp_map_find_m_k</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(std::is_same_v&lt;void, boost::mp11::mp_map_find&lt;std::tuple&lt;&gt;, int&gt;&gt;);
static_assert(std::is_same_v&lt;void, boost::mp11::mp_map_find&lt;std::tuple&lt;std::pair&lt;int, double&gt;&gt;, double&gt;&gt;);
static_assert(std::is_same_v&lt;std::pair&lt;int, double&gt;, boost::mp11::mp_map_find&lt;std::tuple&lt;std::pair&lt;int, double&gt;&gt;, int&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zh7488">https://godbolt.org/z/zh7488</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a user-friendly <code>make</code> routine which creates a given type with named parameters by leveraging a compile-time map?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;template&lt;class...&gt; class T, class... Ts&gt;
constexpr auto make(Ts...) { /*TODO*/ }

template&lt;class TSize, class TValue&gt;
struct foo {};

static_assert(std::is_same_v&lt;foo&lt;int, int&gt;, decltype(make&lt;foo&gt;(&quot;size&quot;_arg = int{}, &quot;value&quot;_arg = int{}))&gt;);
static_assert(std::is_same_v&lt;foo&lt;int, int&gt;, decltype(make&lt;foo&gt;(&quot;value&quot;_arg = int{}, &quot;size&quot;_arg = int{}))&gt;);
static_assert(std::is_same_v&lt;foo&lt;short, double&gt;, decltype(make&lt;foo&gt;(&quot;size&quot;_arg = short{}, &quot;value&quot;_arg = double{}))&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/465xzr">https://godbolt.org/z/465xzr</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;auto... Cs&gt;
struct Arg {
  template &lt;typename T&gt;
  constexpr auto operator=(const T&amp;) { return std::pair&lt;Arg&lt;Cs...&gt;, T&gt;{}; }
};

template &lt;typename T, T... Cs&gt;
constexpr auto operator&quot;&quot;_arg() {
  return Arg&lt;Cs...&gt;{};
}

template&lt;template&lt;typename...&gt; typename T, typename... Ts&gt;
constexpr auto make(Ts...) {
    using map_t = boost::mp11::mp_list&lt;Ts...&gt;;
    using size_t = typename boost::mp11::mp_map_find&lt;map_t, decltype(&quot;size&quot;_arg)&gt;::second_type;
    using value_t = typename boost::mp11::mp_map_find&lt;map_t, decltype(&quot;value&quot;_arg)&gt;::second_type;
    return T&lt;size_t, value_t&gt;{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K6eznr">https://godbolt.org/z/K6eznr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt; typename K&gt;
struct KeyValue
{
    template&lt; typename V&gt;
    auto operator = ( V )
    {
        return std::pair&lt;K,V&gt;{};
    }
};

template&lt;std::size_t N&gt;
struct StaticString
{
    char str[N]{};
    constexpr StaticString ( char const(&amp;p_str)[N] )
    {
        std::ranges::copy(p_str, str);
    };
    template&lt;std::size_t M&gt;
    constexpr bool operator == ( char const(&amp;p_str)[M] ) const
    {
        return std::ranges::equal( p_str, str);
    }
};

struct value_type{};
struct size_type{};


template&lt;StaticString ss&gt;
constexpr auto operator&quot;&quot;_arg()
{
    if constexpr(ss == &quot;value&quot;)
        return KeyValue&lt;value_type&gt;{};
    else if constexpr( ss == &quot;size&quot; )
        return KeyValue&lt;size_type&gt;{};
}

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
constexpr auto make(Ts...) {
    return T&lt; typename boost::mp11::mp_map_find&lt;std::tuple&lt;Ts...&gt;, size_type&gt;::second_type
            , typename boost::mp11::mp_map_find&lt;std::tuple&lt;Ts...&gt;, value_type&gt;::second_type
            &gt;{};
 }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s9WMoj">https://godbolt.org/z/s9WMoj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size&gt;
struct fixed_string {
  char data[Size + 1]{};
  static constexpr auto size = Size;
  constexpr explicit(false) fixed_string(char const* str) { std::copy_n(str, Size + 1, data); }
  constexpr explicit(false) operator std::string_view() const { return {data, Size}; }
};
template&lt;auto Size&gt; fixed_string(char const (&amp;)[Size]) -&gt; fixed_string&lt;Size - 1&gt;;

template&lt;auto...&gt;
struct arg {
  template&lt;class T&gt; constexpr auto operator=(const T&amp; t) const { return std::pair&lt;arg, T&gt;{*this, t}; }
};

template&lt;fixed_string Str&gt; constexpr auto operator&quot;&quot;_arg() {
  return []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
    return arg&lt;Str.data[Ns]...&gt;{};
  }(std::make_index_sequence&lt;Str.size&gt;{});
}

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
constexpr auto make(Ts...) {
  using types_t = boost::mp11::mp_list&lt;Ts...&gt;;
  using size_t = typename boost::mp11::mp_map_find&lt;types_t, decltype(&quot;siize&quot;_arg)&gt;::second_type;
  using value_t = typename boost::mp11::mp_map_find&lt;types_t, decltype(&quot;value&quot;_arg)&gt;::second_type;
  return T&lt;size_t, value_t&gt;{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/94qhrM">https://godbolt.org/z/94qhrM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;char... Cs&gt; struct Name;

template&lt;typename T, char ... Cs&gt;
struct NamedType {
    using name = Name&lt;Cs...&gt;;
    using type = T;
};

template&lt;char ...Cs&gt;
struct Name {
    template&lt;typename T&gt; NamedType&lt;T, Cs...&gt; operator=(T) { return {}; }
};

template&lt;typename Tchar, Tchar ... Cs&gt; constexpr Name&lt;Cs...&gt; operator&quot;&quot; _arg() { return {}; }

template&lt;template&lt;class...&gt; class T, class... Ts&gt;
constexpr auto make(Ts...) {
    using map = std::tuple&lt;std::pair&lt;typename Ts::name, typename Ts::type&gt;...&gt;;
    using value = boost::mp11::mp_map_find&lt;map, Name&lt;'v','a','l','u','e'&gt;&gt;::second_type;
    using size = boost::mp11::mp_map_find&lt;map, Name&lt;'s','i','z','e'&gt;&gt;::second_type;
    return T&lt;size,value&gt;{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YK8GPW">https://godbolt.org/z/YK8GPW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail
{
    using boost::mp11::mp_second;
    using boost::mp11::mp_map_find;

    template&lt;auto Size&gt;
    struct fixed_string {
      using type = fixed_string;
        char data[Size + 1]{};
        static constexpr auto size = Size;
        constexpr fixed_string() = default;
        constexpr fixed_string(char const* str) { std::copy_n(str, Size + 1, data); }
    };

    template&lt;auto Size&gt; fixed_string(char const (&amp;)[Size]) -&gt; fixed_string&lt;Size - 1&gt;;

    template&lt;auto...&gt;
    struct arg
    {
        template &lt;class T&gt;
        constexpr std::pair&lt;arg, T&gt; operator=(T&amp;&amp; value) const { return {*this, value}; }
    };

    template&lt;template&lt;class...&gt; class T&gt;
    struct class_template {};

    template&lt;template&lt;class...&gt; class T, template&lt;class... Ts&gt; class M&gt;
    concept is_same_class_template_v = std::is_same_v&lt;class_template&lt;T&gt;, class_template&lt;M&gt;&gt;;

    namespace literal
    {
        template&lt;fixed_string Fs&gt; constexpr auto operator&quot;&quot;_arg()
        {
            return []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;)
            {
                return arg&lt;Fs.data[Ns]...&gt;{};
            }(std::make_index_sequence&lt;Fs.size&gt;{});
        }

        template&lt;fixed_string Fs&gt; constexpr auto make_arg()
        {
            return []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;)
            {
                return arg&lt;Fs.data[Ns]...&gt;{};
            }(std::make_index_sequence&lt;Fs.size&gt;{});
        }
    }

    // for simplifying user-defined declarations below
    namespace helpers
    {
        template&lt;template&lt;class...&gt; class T, template&lt;class... Ts&gt; class M&gt;
        concept match = is_same_class_template_v&lt;T, M&gt;;

        template&lt;template &lt;class...&gt; class T, class L, fixed_string... Ks&gt;
        using unpack = T&lt;typename mp_map_find&lt;L, decltype(literal::make_arg&lt;Ks&gt;())&gt;::second_type...&gt;;

        template&lt;class... Ts&gt;
        using pack = std::tuple&lt;Ts...&gt;;
    }
}

using namespace detail::literal;
using namespace detail::helpers;

// user-defined template classes

template&lt;class TSize, class TValue&gt;
struct foo {};

template&lt;class TOne, class TTwo&gt;
struct bar {};

// user-defined declarations to define unpacking order of named arguments for template classes

template&lt;template&lt;class...&gt; class T, class... Ts&gt; requires match&lt;T, foo&gt;
constexpr unpack&lt;T, pack&lt;Ts...&gt;, &quot;size&quot;, &quot;value&quot;&gt; make(Ts...) { return {}; }

template&lt;template&lt;class...&gt; class T, class... Ts&gt; requires match&lt;T, bar&gt;
constexpr unpack&lt;T, pack&lt;Ts...&gt;, &quot;one&quot;, &quot;two&quot;&gt; make(Ts...) { return {}; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e15nzv">https://godbolt.org/z/e15nzv</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>203 - Did you know that in C++ `char`, `signed char` and `unsigned char` are 3 different types?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/203.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/203.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that in C++ <code>char</code>, <code>signed char</code> and <code>unsigned char</code> are 3 different types?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/basic.fundamental#:type,signed_char">http://eel.is/c++draft/basic.fundamental#:type,signed_char</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(not std::is_same_v&lt;char, signed char&gt;);
static_assert(std::is_same_v&lt;int, signed int&gt;);

static_assert(not std::is_same_v&lt;char, unsigned char&gt;);
static_assert(not std::is_same_v&lt;int, unsigned int&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ccah6j">https://godbolt.org/z/ccah6j</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>unique_types</code> concept which is satisfied when all given types are unique and a <code>foo</code> function which only allows to take unique arguments?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
/*TODO */ concept unique_types = false;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

/*TODO*/ constexpr auto foo(...) { }

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5v1Kbx">https://godbolt.org/z/5v1Kbx</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">#include &lt;type_traits&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;boost/mp11/list.hpp&gt;
#include &lt;boost/mp11/set.hpp&gt;

template&lt;class... Ts&gt;
concept unique_types = boost::mp11::mp_is_set&lt;boost::mp11::mp_list&lt;Ts...&gt;&gt;::value;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template&lt;class... Ts&gt;
constexpr auto foo(Ts...) requires unique_types&lt;Ts...&gt; { }

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P9n4WE">https://godbolt.org/z/P9n4WE</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename...&gt; constexpr bool unique_head = true;
template &lt;typename T, typename... Ts&gt;
constexpr bool unique_head&lt;T, Ts...&gt; = ((not std::is_same_v&lt;T, Ts&gt;) and ...) and unique_head&lt;Ts...&gt;;

template &lt;typename... Ts&gt;
concept unique_types = unique_head&lt;Ts...&gt;;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template &lt;typename... Ts&gt; requires unique_types&lt;Ts...&gt;
constexpr auto foo(Ts&amp;&amp;...) { }

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MxPzz3">https://godbolt.org/z/MxPzz3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class ...Ts&gt; bool constexpr unique_types_impl = false;
template&lt;class T1&gt; bool constexpr unique_types_impl&lt;T1&gt; = true;
template&lt;class T, class ...Ts&gt;
bool constexpr unique_types_impl&lt;T, Ts...&gt; =
    (!std::is_same_v&lt;T, Ts&gt; &amp;&amp; ... ) &amp;&amp; unique_types_impl&lt;Ts...&gt;;

template&lt;class... Ts&gt; concept unique_types = unique_types_impl&lt;Ts...&gt;;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template&lt;class ...Ts&gt;
constexpr auto foo(Ts...) requires unique_types&lt;Ts...&gt; {}

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hcE91b">https://godbolt.org/z/hcE91b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, typename... Ts&gt;
constexpr bool are_unique() {
    if constexpr (sizeof...(Ts) == 0)
        return true;
    else
        return are_unique&lt;Ts...&gt;()
           and not boost::mp11::mp_contains&lt;boost::mp11::mp_list&lt;Ts...&gt;, T&gt;::value;
}

template&lt;class... Ts&gt;
concept unique_types = are_unique&lt;Ts...&gt;();

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template &lt;typename... Ts&gt;
constexpr auto foo(Ts&amp;&amp;...)
requires unique_types&lt;Ts...&gt;
{}

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bhY15f">https://godbolt.org/z/bhY15f</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
concept unique_types = std::is_same_v&lt;mp_list&lt;Ts...&gt;, mp_unique&lt;mp_list&lt;Ts...&gt;&gt;&gt;;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template&lt;class... Ts&gt; requires unique_types&lt;Ts...&gt;
constexpr auto foo(Ts...) { }

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/haeEd6">https://godbolt.org/z/haeEd6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
concept unique_types = std::is_same_v&lt;mp_unique_if&lt;mp_list&lt;Ts...&gt;, std::is_same&gt;, mp_list&lt;Ts...&gt;&gt;;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template&lt;typename... T&gt;
constexpr auto foo(T &amp;&amp;... t) requires unique_types&lt;T...&gt; { }

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Knqxzq">https://godbolt.org/z/Knqxzq</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename...&gt;
constexpr bool unique = true;

template &lt;typename T, typename... Ts&gt;
constexpr bool unique&lt;T, Ts...&gt; = (!std::is_same_v&lt;T, Ts&gt; &amp;&amp; ...) &amp;&amp; unique&lt;Ts...&gt;;

template&lt;class... Ts&gt;
concept unique_types = unique&lt;Ts...&gt;;

static_assert(unique_types&lt;char&gt;);
static_assert(unique_types&lt;signed char&gt;);
static_assert(unique_types&lt;signed, char&gt;);
static_assert(unique_types&lt;unsigned char&gt;);
static_assert(unique_types&lt;char, signed char&gt;);
static_assert(unique_types&lt;signed char, char&gt;);
static_assert(unique_types&lt;char, signed char, unsigned char&gt;);
static_assert(unique_types&lt;std::byte, char, signed char, unsigned char&gt;);

static_assert(not unique_types&lt;signed char, signed char&gt;);
static_assert(not unique_types&lt;char, signed, char&gt;);
static_assert(not unique_types&lt;char, signed, char, char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, unsigned char&gt;);
static_assert(not unique_types&lt;std::uint8_t, std::byte, char, signed char, unsigned char&gt;);
static_assert(not unique_types&lt;std::int8_t, std::uint8_t, std::byte, char, signed char, unsigned char&gt;);

template&lt; typename ...Ts&gt;
constexpr auto foo(Ts...) requires unique_types&lt;Ts...&gt; {}

static_assert([](auto... args) { return requires { foo(args...); }; }(char{}));
static_assert([](auto... args) { return requires { foo(args...); }; }(char{}, signed{}));
static_assert([](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}));

static_assert(not [](auto... args) { return requires { foo(args...); }; }(char{}, char{}));
static_assert(not [](auto... args) { return requires { foo(args...); }; }((signed char){}, char{}, (signed char){}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dbGMdY">https://godbolt.org/z/dbGMdY</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>202 - Did you know that C++20 added `Using Enum` which introduces the enumerator names of the named enumeration as if by a using-declaration for each enumerator?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/202.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/202.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added <code>Using Enum</code> which introduces the enumerator names of the named enumeration as if by a using-declaration for each enumerator?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p1099">http://wg21.link/p1099</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">enum quantlab { dev, research, };

struct Quantlab {
  using enum quantlab;
};

int main() {
  std::cout &lt;&lt; Quantlab::dev;       // prints 0
  std::cout &lt;&lt; Quantlab{}.research; // prints 1
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jf4d8Kc">https://godbolt.org/z/jf4d8Kc</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you introduce missing enumerators by applying <code>using Enum</code> and add <code>is_enum_in_scope</code> routine to verify whether an enum is in a given scope?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">enum E { e1, e2 };
enum class EC { ec1, ec2, };
enum class ECT : int { ect1, ect2 };

struct UsingEnum {
  // TODO
};
static_assert(0 == UsingEnum::e1);
static_assert(1 == UsingEnum::e2);
static_assert([](auto t) { return requires { t.e1; }; }(UsingEnum{}));
static_assert([](auto t) { return requires { t.e2; }; }(UsingEnum{}));

struct UsingEnumValue {
  // TODO
};
static_assert(0 == UsingEnumValue::e1);
static_assert([](auto t) { return requires { t.e1; }; }(UsingEnumValue{}));
static_assert(not [](auto t) { return requires { t.e2; }; }(UsingEnumValue{}));

struct UsingEnumsMix {
  // TODO
};
static_assert(1 == UsingEnumsMix::e2);
static_assert(0 == int(UsingEnumsMix::ec1));
static_assert(0 == int(UsingEnumsMix::ect1));
static_assert(1 == int(UsingEnumsMix::ect2));
static_assert(not [](auto t) { return requires { t.e1; }; }(UsingEnumsMix{}));
static_assert(not [](auto t) { return requires { t.ec2; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.e2; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ec1; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ect1; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ect2; }; }(UsingEnumsMix{}));

template&lt;class T&gt;
constexpr auto is_enum_in_scope(auto expr) { /*TODO*/ return false; }

struct NotInScope {};
static_assert(not is_enum_in_scope&lt;NotInScope&gt;([](auto e){ return requires { e.ec1; }; }));

struct InScope {
  using enum EC;
};
static_assert(is_enum_in_scope&lt;InScope&gt;([](auto e){ return requires { e.ec1; }; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ocs9ME">https://godbolt.org/z/ocs9ME</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">enum E { e1, e2 };
enum class EC { ec1, ec2, };
enum class ECT : int { ect1, ect2 };

struct UsingEnum {
  using enum E;
};
static_assert(0 == UsingEnum::e1);
static_assert(1 == UsingEnum::e2);
static_assert([](auto t) { return requires { t.e1; }; }(UsingEnum{}));
static_assert([](auto t) { return requires { t.e2; }; }(UsingEnum{}));

struct UsingEnumValue {
  using E::e1;
};
static_assert(0 == UsingEnumValue::e1);
static_assert([](auto t) { return requires { t.e1; }; }(UsingEnumValue{}));
static_assert(not [](auto t) { return requires { t.e2; }; }(UsingEnumValue{}));

struct UsingEnumsMix {
  using E::e2;
  using EC::ec1;
  using enum ECT;
};
static_assert(1 == UsingEnumsMix::e2);
static_assert(0 == int(UsingEnumsMix::ec1));
static_assert(0 == int(UsingEnumsMix::ect1));
static_assert(1 == int(UsingEnumsMix::ect2));
static_assert(not [](auto t) { return requires { t.e1; }; }(UsingEnumsMix{}));
static_assert(not [](auto t) { return requires { t.ec2; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.e2; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ec1; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ect1; }; }(UsingEnumsMix{}));
static_assert([](auto t) { return requires { t.ect2; }; }(UsingEnumsMix{}));

template&lt;class T&gt;
constexpr auto is_enum_in_scope(auto expr) { return expr(T{}); }

struct NotInScope {};
static_assert(not is_enum_in_scope&lt;NotInScope&gt;([](auto e){ return requires { e.ec1; }; }));

struct InScope {
  using enum EC;
};
static_assert(is_enum_in_scope&lt;InScope&gt;([](auto e){ return requires { e.ec1; }; }));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/KvYYKM">https://godbolt.org/z/KvYYKM</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>201 - Did you know that `sizeof` operator can be used for efficient math computation?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/201.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/201.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>sizeof</code> operator can be used for efficient math computation?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/expr.sizeof">http://eel.is/c++draft/expr.sizeof</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto n&gt; consteval auto sqr() {
  return sizeof(std::byte[n][n]);
}

static_assert(2*2 == sqr&lt;2&gt;());
static_assert(10*10 == sqr&lt;10&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bsvKKT">https://godbolt.org/z/bsvKKT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement an <code>exponent</code> variable template which calculates the {x^n} only by leveraging <code>sizeof</code> operator?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto X, auto N&gt;
constexpr auto exponent = 0;

static_assert(1 == exponent&lt;1, 1&gt;);
static_assert(1*1*1*1 == exponent&lt;1, 4&gt;);
static_assert(2*2 == exponent&lt;2, 2&gt;);
static_assert(4*4 == exponent&lt;4, 2&gt;);
static_assert(5*5*5*5 == exponent&lt;5, 4&gt;);
static_assert(10*10*10 == exponent&lt;10, 3&gt;);

static_assert(0 != exponent&lt;1, 2&gt;);
static_assert(1 != exponent&lt;2, 1&gt;);
static_assert(2 != exponent&lt;2, 2&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qqoGxs">https://godbolt.org/z/qqoGxs</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto X, auto N&gt;
constexpr auto dimensions(auto x) {
    if constexpr (N == 0) {
        return x;
    } else {
        return dimensions&lt;X,N-1&gt;(std::array&lt;decltype(x), X&gt;{});
    }
}

template&lt;auto X, auto N&gt;
constexpr auto exponent = sizeof(decltype(dimensions&lt;X,N&gt;(std::byte{})));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j7Yh46">https://godbolt.org/z/j7Yh46</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;auto X, auto Y&gt;
constexpr auto mult = sizeof(char[X][Y]);

template&lt;auto X, auto N&gt;
constexpr auto exponent = ((N &amp; 1) == 0) ? mult&lt;exponent&lt;X, N/2&gt;, exponent&lt;X, N/2&gt;&gt; : mult&lt;X, exponent&lt;X, N-1&gt;&gt;;
template&lt;auto X&gt;
constexpr auto exponent&lt;X, 0&gt; = 1;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ve6d1v">https://godbolt.org/z/ve6d1v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto X, auto N&gt;
constexpr auto exponent = sizeof( char[N % 2 ? X : 1][exponent&lt;X, N / 2&gt;][exponent&lt;X, N / 2&gt;] );

template&lt;auto X&gt;
constexpr auto exponent&lt;X, 0&gt; = 1;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xh6xvf">https://godbolt.org/z/xh6xvf</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;size_t x, size_t n&gt;
constexpr auto carr() {
    if constexpr(n==0)
        return std::array&lt;char, 1&gt;{};
    else
        return std::array&lt; decltype(carr&lt;x,n-1&gt;()) , x&gt;{};
}

template&lt;auto x, auto n&gt;
constexpr auto exponent = sizeof(carr&lt;x,n&gt;());
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/19Yvs9">https://godbolt.org/z/19Yvs9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {

template &lt;auto Val&gt;
[[nodiscard]] consteval auto mult() {
  return Val;
}

template &lt;auto Val1, auto Val2, auto... Vals&gt;
[[nodiscard]] consteval auto mult() {
  return mult&lt;sizeof(std::byte[Val1][Val2]), Vals...&gt;();
}

[[nodiscard]] consteval auto only_first(auto first, auto...) {
    return first;
}

template &lt;auto Base, auto... PowerSequence&gt;
[[nodiscard]] consteval auto exponent_impl(std::index_sequence&lt;PowerSequence...&gt;) {
  return mult&lt;only_first(Base, PowerSequence)...&gt;();
};

}  // namespace detail

template &lt;auto X, auto N&gt;
constexpr auto exponent =
    detail::exponent_impl&lt;X&gt;(std::make_index_sequence&lt;N&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zevEGe">https://godbolt.org/z/zevEGe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, auto N, class U&gt;
consteval auto operator,(std::array&lt;T, N&gt;, U) { return std::array&lt;U, N&gt;{}; }

template&lt;auto X, auto N&gt;
constexpr auto exponent = []&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;){
  return sizeof((std::array&lt;std::byte, (Ns, X)&gt;{}, ...));
}(std::make_index_sequence&lt;N&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yc9nY5">https://godbolt.org/z/Yc9nY5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>200 - Did you know that C++23 added `is_scoped_enum` type trait to detect whether an enum is scoped?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/200.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/200.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++23 added <code>is_scoped_enum</code> type trait to detect whether an enum is scoped?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/P1048R1">https://wg21.link/P1048R1</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">enum class scoped_enum { };
static_assert(std::is_scoped_enum&lt;scoped_enum&gt;{});

enum class scoped_enum_type : int { };
static_assert(std::is_scoped_enum&lt;scoped_enum_type&gt;{});

enum not_scoped_enum { };
static_assert(not std::is_scoped_enum&lt;not_scoped_enum&gt;{});

enum not_scoped_enum_type : int { };
static_assert(not std::is_scoped_enum&lt;not_scoped_enum_type&gt;{});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/j1rc8c">https://godbolt.org/z/j1rc8c</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>scoped_enum</code> and <code>any_enum</code> concepts to constrain <code>foo</code> overloads accordingly?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/*TODO - scoped_num, any_enum*/

using std::literals::string_view_literals::operator&quot;&quot;sv;

constexpr auto foo(scoped_enum auto...) { return &quot;scoped enums&quot;sv; }
constexpr auto foo(any_enum auto...)    { return &quot;any enums&quot;sv; }
constexpr auto foo(auto...)             { return &quot;...&quot;sv; }

enum E { V1 };
enum ET : int { V2 };
enum class SEC : int { V3 };
enum struct SES : int { V4 };
enum : int { V5 };

static_assert(&quot;scoped enums&quot;sv == foo(SEC{}));
static_assert(&quot;scoped enums&quot;sv == foo(SEC::V3));
static_assert(&quot;scoped enums&quot;sv == foo(SEC::V3, SES::V4));
static_assert(&quot;scoped enums&quot;sv == foo(SEC::V3, SES::V4, SES{}, SES{}));

static_assert(&quot;any enums&quot;sv == foo(E{}));
static_assert(&quot;any enums&quot;sv == foo(E{}, ET::V2));
static_assert(&quot;any enums&quot;sv == foo(V5, ET::V2, E{}));
static_assert(&quot;any enums&quot;sv == foo(E{}, E::V1, V1, V5));

static_assert(&quot;...&quot;sv == foo(0));
static_assert(&quot;...&quot;sv == foo(0, V5));
static_assert(&quot;...&quot;sv == foo(0, V1, E::V1, SEC::V3, SES::V4));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s7ca5r">https://godbolt.org/z/s7ca5r</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">void call_with_integer(int x) {};

template &lt;typename T&gt;
concept scoped_enum = std::is_enum_v&lt;T&gt; and not requires { call_with_integer(T{}); };

template &lt;typename T&gt;
concept any_enum = std::is_enum_v&lt;T&gt; and not scoped_enum&lt;T&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GeEGrh">https://godbolt.org/z/GeEGrh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    template&lt;typename T&gt;
    concept enumeration = std::is_enum_v&lt;T&gt;;

    template&lt;typename T&gt;
    concept integer_convertible = std::convertible_to&lt;T, int&gt;;
}

template&lt;typename TEnum&gt;
concept scoped_enum = detail::enumeration&lt;TEnum&gt; and not detail::integer_convertible&lt;TEnum&gt;;

template&lt;typename TEnum&gt;
concept any_enum = detail::enumeration&lt;TEnum&gt; and detail::integer_convertible&lt;TEnum&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/95EaP9">https://godbolt.org/z/95EaP9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename... Ts&gt;
concept any_enum = (std::is_enum_v&lt;Ts&gt; and ...);

template &lt;typename... Ts&gt;
concept scoped_enum = any_enum&lt;Ts...&gt; and
    (not std::is_convertible_v&lt;Ts, std::underlying_type_t&lt;Ts&gt;&gt; and ...);

template &lt;typename... Ts&gt;
constexpr auto foo(Ts...) requires scoped_enum&lt;Ts...&gt; { return &quot;scoped enums&quot;sv; }
template &lt;typename... Ts&gt;
constexpr auto foo(Ts...) requires any_enum&lt;Ts...&gt; { return &quot;any enums&quot;sv; }
constexpr auto foo(auto...) { return &quot;...&quot;sv; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nfMG8W">https://godbolt.org/z/nfMG8W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt; using is_scoped_enum =
  std::bool_constant&lt;std::is_enum_v&lt;T&gt; and not std::is_convertible_v&lt;T, std::underlying_type_t&lt;T&gt;&gt;&gt;;
template&lt;class T&gt; concept scoped_enum = is_scoped_enum&lt;T&gt;::value;
template&lt;class T&gt; concept any_enum = std::is_enum&lt;T&gt;::value and not is_scoped_enum&lt;T&gt;::value;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xWYjT1">https://godbolt.org/z/xWYjT1</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt; concept any_enum = std::is_enum_v&lt;T&gt; &amp;&amp; std::is_convertible_v&lt;T, std::underlying_type_t&lt;T&gt;&gt;;
template &lt;typename T&gt; concept scoped_enum = std::is_enum_v&lt;T&gt; &amp;&amp; !std::is_convertible_v&lt;T, std::underlying_type_t&lt;T&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/68M7jT">https://godbolt.org/z/68M7jT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
concept scoped_enum = std::is_enum_v&lt;T&gt; and not std::is_convertible_v&lt;T, std::underlying_type_t&lt;T&gt;&gt;;

template&lt;typename T&gt;
concept any_enum = std::is_enum_v&lt;T&gt; and std::is_convertible_v&lt;T, std::underlying_type_t&lt;T&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xnPh3n">https://godbolt.org/z/xnPh3n</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>199 - Did you know about proposal to introduce constexpr ternary operator?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/199.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/199.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about proposal to introduce constexpr ternary operator?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2068">http://wg21.link/p2068</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo { int value{42}; };
struct bar { };

constexpr auto value = [](auto t) {
  if constexpr ( requires { t.value; } ) {
    return t.value;
  } else {
    return 0;
  }
};

static_assert(42 == value(foo{}));
static_assert(0  == value(bar{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v54aba">https://godbolt.org/z/v54aba</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a bash style constexpr ternary operator powered by C++20 concepts?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/* TODO
 * Bash style constexpr ternary operator powered by C++20 concepts
 * [[ $b = 5 ]] &amp;&amp; a=&quot;$c&quot; || a=&quot;$d&quot;
*/
int main() {
  struct foo { int value{42}; };
  struct bar { };

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } &amp;&amp; [](auto t) { return t.value; } || [](auto t) { return 0; };
  static_assert(0 == value(bar{}));
  static_assert(42 == value(foo{42}));
  }

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } and [](auto t) { return t.value; } or [](auto t) { return sizeof(t); };
  static_assert(sizeof(bar) == value(bar{}));
  static_assert(42 == value(foo{42}));
  }

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } and [](auto t) { return t.value; } or 0;
  static_assert(0 == value(bar{}));
  static_assert(42 == value(foo{42}));
  }

  {
  constexpr auto value = [](auto t) { return not requires { t.value; }; } and 1 or [](auto t) { return t.value; };
  static_assert(1 == value(bar{}));
  static_assert(42 == value(foo{42}));
  }

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } and 1 or 2;
  static_assert(2 == value(bar{}));
  static_assert(1 == value(foo{}));
  }

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } and 1;
  static_assert(0 == value(bar{}));
  static_assert(1 == value(foo{}));
  }

  {
  constexpr auto value = [](auto t) { return requires { t.value; }; } or 1;
  static_assert(1 == value(bar{}));
  static_assert(0 == value(foo{}));
  }

  {
  static_assert(4 == ([](auto t) { return requires { t.value; }; } and 4 or 2)(foo{}));
  static_assert(2 == ([](auto t) { return requires { t.value; }; } and 4 or 2)(bar{}));
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W5Pc3d">https://godbolt.org/z/W5Pc3d</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
constexpr auto call_or_value = [] (auto f, [[maybe_unused]] auto t) {
  if constexpr (requires { f(t); }) {
    return f(t);
  } else {
    return f;
  }
};

template &lt;class Cond, class Cons, class Alt&gt;
struct alt {
  template &lt;class T&gt;
  constexpr auto operator()(T t) const {
    if constexpr (Cond{}(T{})) {
      return call_or_value(c, t);
    } else {
      return call_or_value(a, t);
    }
  }

  Cons c;
  Alt a;
};

template &lt;class Cond, class Cons&gt;
struct cond {
  template &lt;class T&gt;
  constexpr auto operator()(T t) const {
    if constexpr (Cond{}(T{})) {
      return call_or_value(c, t);
    } else {
      return decltype(call_or_value(c, t)){};
    }
  }

  Cons c{};
};
}

template &lt;class Cond, class Cons&gt;
constexpr auto operator and(Cond, Cons c) {
  return detail::cond&lt;Cond, Cons&gt;{c};
}

template &lt;class Cond, class Cons, class Alt&gt;
constexpr auto operator or(detail::cond&lt;Cond, Cons&gt; cond, Alt a) {
  return detail::alt&lt;Cond, Cons, Alt&gt;{cond.c, a};
}

template &lt;class Cond, class Alt&gt;
constexpr auto operator or(Cond, Alt a) {
  constexpr auto neg = [] &lt;class T&gt; (T t) {
    return not Cond{}(t);
  };
  return detail::cond&lt;decltype(neg), Alt&gt;{a};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P1v8re">https://godbolt.org/z/P1v8re</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename T, bool B&gt;
struct test
{
private:
  T value;

public:
  constexpr test() : value{} {}
  constexpr test(T t) : value(t) {}

  template &lt;typename = std::enable_if&lt;not std::same_as&lt;bool, T&gt;&gt;&gt;
  constexpr operator bool() const { return B; }

  constexpr operator T() const { return value; }
};

template &lt;typename&gt;
struct has_value : std::false_type {};

template &lt;typename T, bool B&gt;
struct has_value&lt;test&lt;T, B&gt;&gt; { static constexpr bool value = B; };

template &lt;typename T&gt;
constexpr bool has_value_v = has_value&lt;T&gt;::value;

constexpr auto result(auto expr, auto val)
{
  if constexpr (requires { expr(val); }) return expr(val);
  else return expr;
}
} // namespace detail

template &lt;typename Pred, typename Expr&gt;
constexpr auto operator and(Pred, Expr expr)
{
  return [=]&lt;typename T&gt;(T value)
  {
    if constexpr (Pred{}(T{})) {
      auto result = detail::result(expr, value);
      return detail::test&lt;decltype(result), true&gt;(result);
    }
    else {
      return detail::test&lt;Expr, false&gt;{};
    }
  };
}

template &lt;typename Pred, typename Expr&gt;
constexpr auto operator or(Pred pred, Expr expr)
{
  return [=](auto value)
  {
    auto cond = pred(value);

    if constexpr (std::same_as&lt;decltype(cond), bool&gt;) {
      if (cond) {
        return detail::test&lt;Expr, true&gt;(Expr{});
      }
    }

    if constexpr (not detail::has_value_v&lt;decltype(cond)&gt;) {
      auto result = detail::result(expr, value);
      return detail::test&lt;decltype(result), true&gt;(result);
    }
    else {
      return cond;
    }
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/3KP1vn">https://godbolt.org/z/3KP1vn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
[[nodiscard]] constexpr auto call(auto f, auto v) {
  if constexpr (requires { f(v); }) {
    return f(v);
  } else {
    return f;
  }
}

template&lt;class TLhs, class TRhs&gt;
struct if_ {
  constexpr if_(TLhs lhs, TRhs rhs) : lhs{lhs}, rhs{rhs} {}

  [[nodiscard]] constexpr auto operator()(auto x, auto y) const {
    if constexpr (TLhs{}(decltype(x){})) {
      return call(rhs, x);
    } else {
      return call(y, x);
    }
  }

  [[nodiscard]] constexpr auto operator()(auto t) const {
    if constexpr (TLhs{}(decltype(t){})) {
      return call(rhs, t);
    } else {
      return decltype(call(rhs, t)){};
    }
  }

 private:
  TLhs lhs{};
  TRhs rhs{};
};

template&lt;class TLhs, class TRhs&gt;
struct else_ {
  constexpr else_(TLhs lhs, TRhs rhs) : lhs{lhs}, rhs{rhs} {}

  [[nodiscard]] constexpr auto operator()(auto t) const {
    if constexpr (requires { lhs(t, rhs); }) {
      return lhs(t, rhs);
    } else if constexpr (TLhs{}(decltype(t){})) {
      return decltype(call(rhs, lhs)){};
    } else {
      return call(rhs, lhs);
    }
  }

 private:
  TLhs lhs{};
  TRhs rhs{};
};

} // namespace detail

[[nodiscard]] constexpr auto operator and(auto lhs, auto rhs) { return detail::if_{lhs, rhs}; }
[[nodiscard]] constexpr auto operator  or(auto lhs, auto rhs) { return detail::else_{lhs, rhs}; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/67oY6M">https://godbolt.org/z/67oY6M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename FuncOrVal, typename Val&gt;
constexpr auto maybe_call(FuncOrVal funcorval, Val val) {
    if constexpr (requires{funcorval(Val{});})
        return funcorval(val);
    else
        return funcorval;
}

template &lt;typename Condition, typename IfTrue&gt;
struct and_t {
    Condition condition{};
    IfTrue iftrue{};

    template &lt;typename Value&gt;
    constexpr auto operator()(Value value) const {
        if constexpr (Condition{}(Value{})) {
            return maybe_call(iftrue, value);
        } else {
            return decltype(maybe_call(iftrue, value)){};
        }
    }
};

template &lt;typename Condition, typename IfTrue&gt;
constexpr auto operator&amp;&amp;(Condition condition, IfTrue iftrue) {
    return and_t{condition, iftrue};
}

template &lt;typename Condition, typename IfTrue, typename IfFalse&gt;
constexpr auto operator||(and_t&lt;Condition, IfTrue&gt; and_, IfFalse iffalse) {
    return [=]&lt;typename T&gt;(T value) {
        if constexpr (and_.condition(T{})) {
            return maybe_call(and_.iftrue, value);
        } else {
            return maybe_call(iffalse, value);
        }
    };
}

template &lt;typename Condition, typename IfFalse&gt;
constexpr auto operator||(Condition condition, IfFalse iffalse) {
    return [=]&lt;typename T&gt;(T value) {
        if constexpr (not condition(T{})) {
            return maybe_call(iffalse, value);
        } else {
            return decltype(maybe_call(iffalse, value)){};
        }
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4Kz4bY">https://godbolt.org/z/4Kz4bY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename Cond, typename TRes, typename FRes = int&gt;
struct Ternary {
    constexpr Ternary(Cond cond, TRes tres, FRes fres = 0) : cond(cond), tres(tres), fres(fres) {}
    template&lt;typename T&gt;
    auto constexpr operator()(const T&amp; t) const {
        TRes tresLocal = tres;
        FRes fresLocal = fres;
        Cond condLocal = cond;
        if constexpr( condLocal(T())) {
            if constexpr( std::is_fundamental_v&lt;TRes&gt;)
                return tresLocal;
            else
                return tresLocal(t);
        } else {
            if constexpr( std::is_fundamental_v&lt;FRes&gt;)
                return fresLocal;
            else
                return fresLocal(t);
        }
    }
    Cond cond;
    TRes tres;
    FRes fres;
};

template&lt;typename Cond, typename TRes, typename FRes&gt;
auto constexpr operator||(Ternary&lt;Cond, TRes&gt; ternary, FRes fres) {
    return Ternary(ternary.cond, ternary.tres, fres);
}

template&lt;typename Cond, typename FRes&gt;
auto constexpr operator||(Cond cond, FRes fres) {
    return Ternary(cond, 0, fres);
}

template&lt;typename Cond, typename TRes&gt;
auto constexpr operator&amp;&amp;(Cond cond, TRes tres) {
    return Ternary(cond, tres);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/evo9Mr">https://godbolt.org/z/evo9Mr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TCompare, typename TTrue, typename TFalse = int&gt;
struct compare {
    constexpr explicit(true) compare(const TCompare&amp;, const TTrue&amp; true_in) : true_val(true_in), false_val(0) {}
    constexpr explicit(true) compare(const compare&lt;TCompare, TTrue, int&gt;&amp; partial, const TFalse&amp; false_in)
        : true_val(partial.true_val)
        , false_val(false_in)
    {
    }

    template &lt;typename TValue&gt;
    constexpr auto operator()(const TValue&amp; value) const
    {
        if constexpr (TCompare{}(TValue{})) {
            if constexpr (requires(TValue v) { TTrue{}(v); }) {
                return TTrue{}(value);
            } else {
                return true_val;
            }
        } else {
            if constexpr (requires(TValue v) { TFalse{}(v); }) {
                return TFalse{}(value);
            } else {
                return false_val;
            }
        }
    }

    TTrue true_val;
    TFalse false_val;

    using compare_sentenel = void;
};

constexpr auto operator and(const auto&amp; compare_func, const auto&amp; true_in)
{
    return compare{compare_func, true_in};
}

template&lt;typename TCompare&gt;
constexpr auto operator or(const TCompare&amp; lhs, const auto&amp; false_in)
{
    if constexpr (requires{TCompare::compare_sentenel;}) {
        return compare{lhs, false_in};
    } else {
        return compare{compare{lhs, 0}, false_in};
    }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/debW6e">https://godbolt.org/z/debW6e</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>198 - Did you know about different ways of iterating over objects?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/198.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/198.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about different ways of iterating over objects?</strong></p>
</li>
<li>
<p><a href="http://eel.is/c++draft/variant#visit">http://eel.is/c++draft/variant#visit</a></p>
</li>
<li><a href="http://eel.is/c++draft/tuple#apply">http://eel.is/c++draft/tuple#apply</a></li>
<li><a href="http://eel.is/c++draft/alg.foreach">http://eel.is/c++draft/alg.foreach</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::variant&lt;int, std::string_view, double&gt; v = 3.14;
  std::visit([](const auto&amp; e) { std::cout &lt;&lt; e; }, v); // prints 3.14

  std::tuple t = {42, &quot;text&quot;, 3.14};
  std::apply([](const auto&amp;... args) { ((std::cout &lt;&lt; args &lt;&lt; ' '), ...); }, t); // prints 42 text 3.14

  std::array a{1, 2, 3};
  std::for_each(std::cbegin(a), std::cend(a), [](const auto&amp; e) { std::cout &lt;&lt; e &lt;&lt; ' '; }); // prints 1 2  3
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hnP4YT">https://godbolt.org/z/hnP4YT</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement a generic <code>iterate</code> function which can iterate over any object?</strong></p>
</li>
<li>
<p>Double points for applying concepts for overloading</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">auto iterate(auto&amp;&amp; t, auto&amp;&amp; expr) -&gt; void {
  // TODO
}

int main() {
  using namespace boost::ut;
  using std::literals::string_view_literals::operator&quot;&quot;sv;

  &quot;iterate&quot;_test = [] {
    std::stringstream str{};
    const auto out = [&amp;str](const auto&amp; value) { str &lt;&lt; value &lt;&lt; ' '; };

    &quot;tuple&quot;_test = [&amp;] {
      std::tuple t = {42, &quot;text&quot;, 3.14};
      iterate(t, out);
      expect(&quot;42 text 3.14 &quot;sv == str.str());
    };

    &quot;array&quot;_test = [&amp;] {
      std::array a{1, 2, 3};
      iterate(a, out);
      expect(&quot;1 2 3 &quot;sv == str.str());
    };

    &quot;vector&quot;_test = [&amp;] {
      std::vector v{1, 2, 3};
      iterate(v, out);
      expect(&quot;1 2 3 &quot;sv == str.str());
    };

    &quot;variant&quot;_test = [&amp;] {
      std::variant&lt;int, std::string_view, double&gt; v = 42;
      iterate(v, out);
      expect(&quot;42 &quot;sv == str.str());
    };

    &quot;array of tuples&quot;_test = [&amp;] {
      using tuple_t = std::tuple&lt;int, std::string_view, double&gt;;
      std::array at{tuple_t{1, &quot;1&quot;, 1.}, tuple_t{2, &quot;2&quot;, 2.}, tuple_t{3, &quot;3&quot;, 3.}};
      iterate(at, out);
      expect(&quot;1 1 1 2 2 2 3 3 3 &quot;sv == str.str());
    };

    &quot;vector of variants&quot;_test = [&amp;] {
      using variant_t = std::variant&lt;int, std::string_view, double&gt;;
      std::vector&lt;variant_t&gt; vv = {42, &quot;text&quot;, 3.14};
      iterate(vv, out);
      expect(&quot;42 text 3.14 &quot;sv == str.str());
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WejovP">https://godbolt.org/z/WejovP</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
  template &lt;class T&gt;
  concept gettable = requires (T t) {
    std::get&lt;0&gt;(t);
  };

  template &lt;class T&gt;
  concept container = requires (T t) {
    t.begin();
    t.end();
    t.capacity();
  };

  template &lt;class T&gt;
  concept visitable = gettable&lt;T&gt; and requires (T t) {
    t.index();
  };

  template &lt;class T, class TExpr&gt;
  auto iterate(T&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    std::invoke(std::forward&lt;TExpr&gt;(expr), std::forward&lt;T&gt;(t));
  }

  template &lt;container T&gt;
  auto iterate(T&amp;&amp; t, auto&amp;&amp; expr) -&gt; void;

  template &lt;visitable T, class TExpr&gt;
  auto iterate(T&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void;

  template &lt;gettable T&gt;
  auto iterate(T&amp;&amp; t, auto&amp;&amp; expr) -&gt; void {
    std::apply([&amp;] &lt;class... TElems&gt; (TElems&amp;&amp;... elems) {
      (detail::iterate(std::forward&lt;TElems&gt;(elems), expr), ...);
    }, std::forward&lt;T&gt;(t));
  }

  template &lt;container T&gt;
  auto iterate(T&amp;&amp; t, auto&amp;&amp; expr) -&gt; void {
    for (auto&amp;&amp; elem : std::forward&lt;T&gt;(t)) {
      detail::iterate(std::forward&lt;decltype(elem)&gt;(elem), expr);
    }
  }

  template &lt;visitable T, class TExpr&gt;
  auto iterate(T&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    std::visit([&amp;] &lt;class TElem&gt; (TElem&amp;&amp; elem) {
      detail::iterate(std::forward&lt;TElem&gt;(elem), std::forward&lt;TExpr&gt;(expr));
    }, std::forward&lt;T&gt;(t));
  }
}

template &lt;class T, class TExpr&gt;
auto iterate(T&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
  return detail::iterate(std::forward&lt;T&gt;(t), std::forward&lt;TExpr&gt;(expr));
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/T1vWKh">https://godbolt.org/z/T1vWKh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename Vis, typename Var&gt;
concept CanIterateWithVisit = requires(Vis vis, Var var) {
    var.index();
    var.valueless_by_exception();
    std::get&lt;0&gt;(var);
};

template&lt;typename UnaryF, typename C&gt;
concept CanIterateWithForEach = requires(C c, UnaryF unaryF, C::const_iterator citer) {
    c.begin();
    c.end();
    std::for_each(citer, citer, unaryF);
};

template&lt;typename Func, typename T&gt;
concept CanIterateWithApply = requires(T t, Func func) {
    std::tuple_size&lt;T&gt;{};
    std::get&lt;0&gt;(t);
};

auto iterate(auto&amp;&amp; t, auto&amp;&amp; expr) -&gt; void {
  using tType = std::remove_reference_t&lt;decltype(t)&gt;;
  using exprType = std::remove_reference_t&lt;decltype(expr)&gt;;

  if constexpr( CanIterateWithVisit&lt;decltype(expr), tType&gt;)
    std::visit(expr, t);
  else if constexpr( CanIterateWithForEach&lt;decltype(expr), tType&gt;)
    std::for_each( std::cbegin(t), std::cend(t), [&amp;](const auto&amp; arg) { iterate(arg, expr); } );
  else if constexpr( CanIterateWithApply&lt; exprType, tType&gt;)
    std::apply([&amp;](const auto&amp; ...args) { (expr(args),...); }, t);
  else
    expr(t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qdT53d">https://godbolt.org/z/qdT53d</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
concept For_Eachable = requires (const T&amp; t) {
  std::for_each(t.cbegin(), t.cend(), [](const auto&amp;) {});
};

template &lt;template &lt;typename...&gt; typename, typename&gt;
constexpr auto IsContainer = false;

template &lt;template &lt;typename...&gt; typename C, typename... Ts&gt;
constexpr auto IsContainer&lt;C, C&lt;Ts...&gt;&gt; = true;

void iterate(const auto&amp; t, const auto&amp; expr) {
  using T = decltype(t);

  if constexpr ( IsContainer&lt;std::variant, std::decay_t&lt;T&gt;&gt; ) {
    std::visit(expr, t);
  }
  else if constexpr ( IsContainer&lt;std::tuple, std::decay_t&lt;T&gt;&gt; ) {
    const auto f_apply = [&amp;](const auto&amp;... es) { (..., expr(es)); };

    std::apply(f_apply, t);
  }
  else if constexpr ( For_Eachable&lt;T&gt; ) {
    const auto f_for_each = [&amp;](const auto&amp; e) { iterate(e, expr); };

    std::for_each(t.cbegin(), t.cend(), f_for_each);
  }
  else {
    expr(t);
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9noMrx">https://godbolt.org/z/9noMrx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    template&lt;typename T&gt;
    concept gettable = requires(T t) {
        std::get&lt;0&gt;(t);
    };

    template&lt;typename T&gt;
    concept indexable = requires(T t) {
        t.index();
    };

    template&lt;typename T&gt;
    concept container = requires(T t) {
        t.begin();
        t.end();
        t.size();
        t.capacity();
    };

    template&lt;typename T&gt;
    concept apply_iterable = gettable&lt;T&gt;;

    template&lt;typename T&gt;
    concept for_iterable = container&lt;T&gt;;

    template&lt;typename T&gt;
    concept visit_iterable = gettable&lt;T&gt; &amp;&amp; indexable&lt;T&gt;;
}

template&lt;detail::apply_iterable TIterable, typename TExpr&gt;
auto iterate(TIterable&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    std::apply(
        [&amp;](const auto&amp;... args ){
            (iterate(args, expr), ...);
        },
        t);
}

template&lt;detail::for_iterable TIterable, typename TExpr&gt;
auto iterate(TIterable&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    for(const auto&amp; val : t) {
        iterate(val, expr);
    }
}

template&lt;detail::visit_iterable TIterable, typename TExpr&gt;
auto iterate(TIterable&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    std::visit(
        [&amp;](const auto&amp; var){
            expr(var);
        },
        t);
}

template&lt;typename TValue, typename TExpr&gt;
auto iterate(TValue&amp;&amp; t, TExpr&amp;&amp; expr) -&gt; void {
    expr(t);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Enosbe">https://godbolt.org/z/Enosbe</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">auto iterate(auto&amp;&amp; t, auto&amp;&amp; expr) -&gt; void {
  expr(t);
}

template&lt;class... Ts&gt;
auto iterate(std::tuple&lt;Ts...&gt; t, auto&amp;&amp; expr) -&gt; void {
  std::apply([expr](const auto&amp;... args) { (expr(args), ...); }, t);
}

template&lt;class... Ts&gt;
auto iterate(std::variant&lt;Ts...&gt; v, auto&amp;&amp; expr) -&gt; void {
  std::visit(expr, v);
}

template&lt;class T, auto N&gt;
auto iterate(std::array&lt;T, N&gt; a, auto&amp;&amp; expr) -&gt; void {
  std::for_each(std::cbegin(a), std::cend(a), [expr](const auto&amp; e){
    iterate(e, expr);
  });
}

template&lt;class T&gt;
auto iterate(std::vector&lt;T&gt; v, auto&amp;&amp; expr) -&gt; void {
  std::for_each(std::cbegin(v), std::cend(v), [expr](const auto&amp; e){
    iterate(e, expr);
  });
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/96bjP5">https://godbolt.org/z/96bjP5</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>197 - Did you know that Lambdas in Unevaluated Context combined with Template Constraints (Concepts) can be used with types?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/197.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/197.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Lambdas in Unevaluated Context combined with Template Constraints (Concepts) can be used with types?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0315">http://wg21.link/p0315</a></p>
</li>
<li><a href="http://eel.is/c++draft/temp.constr">http://eel.is/c++draft/temp.constr</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T, class TExpr&gt;
using underlying_value_t = decltype(
  [] {
    if constexpr (TExpr{}(T{})) {
      return T{};
    }
  }()
);

struct foo { int value; };
struct bar {};

static_assert(std::is_same_v&lt;foo, underlying_value_t&lt;foo, decltype([](auto t) { return requires { t.value; }; })&gt;&gt;);
static_assert(std::is_same_v&lt;void, underlying_value_t&lt;bar, decltype([](auto t) { return requires { t.value; }; })&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nT1v6G">https://godbolt.org/z/nT1v6G</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a <code>copy_if</code> type alias which returns a <code>type_list</code> which contains only types which have a <code>value</code> member?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct type_list {};

template&lt;class TExpr, class... Ts&gt;
using copy_if = /*TODO*/void;

struct foo { int value; };
struct bar {};

static_assert(std::is_same_v&lt;type_list&lt;&gt;,    copy_if&lt;decltype([](auto t) { return requires { t.value; }; })&gt;&gt;);
static_assert(std::is_same_v&lt;type_list&lt;foo&gt;, copy_if&lt;decltype([](auto t) { return requires { t.value; }; }), foo&gt;&gt;);
static_assert(std::is_same_v&lt;type_list&lt;&gt;,    copy_if&lt;decltype([](auto t) { return requires { t.value; }; }), bar&gt;&gt;);
static_assert(std::is_same_v&lt;type_list&lt;foo&gt;, copy_if&lt;decltype([](auto t) { return requires { t.value; }; }), foo, bar&gt;&gt;);
static_assert(std::is_same_v&lt;type_list&lt;foo&gt;, copy_if&lt;decltype([](auto t) { return requires { t.value; }; }), bar, foo&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/csYaej">https://godbolt.org/z/csYaej</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class TExprm, class O, class I&gt;
struct copy_if_impl;

template&lt;class TExpr, class ...Ns&gt;
struct copy_if_impl&lt;TExpr, type_list&lt;Ns...&gt;, type_list&lt;&gt;&gt; {
    using result = type_list&lt;Ns...&gt;;
};

template&lt;class TExpr, class ...Ns, class T, class ...Ts&gt;
struct copy_if_impl&lt;TExpr, type_list&lt;Ns...&gt;, type_list&lt;T, Ts...&gt; &gt; {
    using result = decltype(
    [] {
        if constexpr(TExpr{}(T{}))
            return typename copy_if_impl&lt; TExpr, type_list&lt;Ns..., T&gt;, type_list&lt;Ts...&gt; &gt;::result{};
        else
            return typename copy_if_impl&lt; TExpr, type_list&lt;Ns...&gt;, type_list&lt;Ts...&gt; &gt;::result{};
    }());
};

template&lt;class TExpr, class... Ts&gt;
using copy_if = typename copy_if_impl&lt;TExpr, type_list&lt;&gt;, type_list&lt;Ts...&gt;&gt;::result;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5cecWa">https://godbolt.org/z/5cecWa</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
using remove_void_t = boost::mp11::mp_remove_if_q&lt;T, boost::mp11::mp_quote_trait&lt;std::is_void&gt;&gt;;

template &lt;class TExpr, class... Ts&gt;
using copy_if = remove_void_t&lt;type_list&lt;decltype([] {
    if constexpr (TExpr {}(Ts {})) {
        return Ts {};
    }
}())...&gt;&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/edecdG">https://godbolt.org/z/edecdG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class...XArgs, class...YArgs&gt;
constexpr auto operator+(type_list&lt;XArgs...&gt;, type_list&lt;YArgs...&gt;) -&gt; type_list&lt;XArgs..., YArgs...&gt;;

template&lt;class TExpr, class... Ts&gt;
using copy_if = decltype(([] {
  if constexpr (TExpr{}(Ts{})) {
    return type_list&lt;Ts&gt;{};
  } else {
    return type_list&lt;&gt;{};
  }
}() + ... + type_list&lt;&gt;{}));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4nfTKP">https://godbolt.org/z/4nfTKP</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
// based on [https://codereview.stackexchange.com/a/201222](https://codereview.stackexchange.com/a/201222)
template &lt;typename TExpr, typename... T1s&gt;
constexpr auto filter_types(type_list&lt;T1s...&gt; acc, type_list&lt;&gt;) {
    return acc;
}

template &lt;typename TExpr, typename... T1s, typename T, typename... T2s&gt;
constexpr auto filter_types(type_list&lt;T1s...&gt; acc, type_list&lt;T, T2s...&gt;) {
    if constexpr (TExpr{}(T{}))
        return filter_types&lt;TExpr&gt;(type_list&lt;T1s..., T&gt;{}, type_list&lt;T2s...&gt;{});
    else
        return filter_types&lt;TExpr&gt;(acc, type_list&lt;T2s...&gt;{});
}

template &lt;typename TExpr, typename... Ts&gt;
using type_filter = decltype(filter_types&lt;TExpr&gt;(type_list&lt;&gt;{}, type_list&lt;Ts...&gt;{}));
}

template&lt;typename TExpr, typename... Ts&gt;
using copy_if = detail::type_filter&lt;TExpr, Ts...&gt;;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YEv31n">https://godbolt.org/z/YEv31n</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>196 - Did you know that Lambdas in Unevaluated Context combined with Immediately Invoked Function Expressions (IIFE) can be used to simplify Template Meta-Programming?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/196.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/196.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Lambdas in Unevaluated Context combined with Immediately Invoked Function Expressions (IIFE) can be used to simplify Template Meta-Programming?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0315">http://wg21.link/p0315</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(not std::is_same_v&lt;decltype([]{}), decltype([]{})&gt;);
static_assert(std::is_same_v&lt;void, decltype([]{}())&gt;);
static_assert(std::is_same_v&lt;decltype([]{}()), decltype([]{}())&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cr6Y5P">https://godbolt.org/z/cr6Y5P</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you implement an <code>add_pointer</code> routine which makes the usage of <code>decltype(IIFE)</code> and returns a list of pointer types to: { <code>value</code> field if present, <code>void</code> otherwise }?</strong></p>
</li>
<li>
<p>Consider applying C++20 concepts and Design by Introspection for fields detection</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt; struct type_list {};

template&lt;class... Ts&gt;
constinit auto add_pointer = type_list&lt;/*TODO*/&gt;{};

struct foo {
  int value;
};

struct bar { };

static_assert(std::is_same_v&lt;type_list&lt;&gt;, decltype(add_pointer&lt;&gt;)&gt;);
static_assert(std::is_same_v&lt;type_list&lt;int*&gt;, decltype(add_pointer&lt;foo&gt;)&gt;);
static_assert(std::is_same_v&lt;type_list&lt;void*&gt;, decltype(add_pointer&lt;bar&gt;)&gt;);
static_assert(std::is_same_v&lt;type_list&lt;int*, void*&gt;, decltype(add_pointer&lt;foo, bar&gt;)&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MKvWj9">https://godbolt.org/z/MKvWj9</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto value_from = [] (auto t) {
  if constexpr (requires { t.value; }) {
    return t.value;
  }
};

template &lt;class T&gt;
using value_t = std::add_pointer_t&lt;decltype(value_from(std::declval&lt;T&gt;()))&gt;;

template&lt;class... Ts&gt;
constinit auto add_pointer = type_list&lt;value_t&lt;Ts&gt;...&gt;{};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/PKc9c4">https://godbolt.org/z/PKc9c4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constinit auto add_pointer = type_list&lt;decltype(
  [] {
    if constexpr (requires(Ts t) { t.value; } ) {
      return Ts{}.value;
    }
  }())*...&gt;{};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ehhxsh">https://godbolt.org/z/ehhxsh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
concept HasValue = requires(T t) { t.value; };

auto ValueOrVoidPtr = []&lt;typename T&gt;(const T&amp;) {
    if constexpr (HasValue&lt;T&gt;)
        return (decltype(T::value)*)(nullptr);
    else
        return (void*)(nullptr);
};

template&lt;class... Ts&gt;
constinit auto add_pointer = type_list&lt; decltype(ValueOrVoidPtr(Ts())) ...&gt;{};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1Y7Ehs">https://godbolt.org/z/1Y7Ehs</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
constinit auto add_pointer = type_list&lt;decltype([](auto v)
{
    if constexpr (requires { v.value; })
    {
        return v.value;
    }
    else
    {
        return;
    }
}(std::declval&lt;Ts&gt;()))*...&gt;{};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Pn8v7Y">https://godbolt.org/z/Pn8v7Y</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>195 - Did you know that C++20 added support for `[[no_unique_address]]` attribute?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/195.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/195.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added support for <code>[[no_unique_address]]</code> attribute?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0840">http://wg21.link/p0840</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct empty {};
struct ebco : empty {}; // Empty Base Class Optimization (EBCO)

static_assert(sizeof(empty) == 1);
static_assert(sizeof(ebco) == 1);

struct no_unique_address {
  [[no_unique_address]] struct {} empty;
};

static_assert(sizeof(no_unique_address) == 1);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/P9KK84">https://godbolt.org/z/P9KK84</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li>
<p><strong>Can you add an optional field of type <code>T</code> to <code>foo</code> only when <code>Enable == true</code>?</strong></p>
</li>
<li>
<p>Preferably by leveraging <code>[[no_unique_address]]</code> attribute</p>
</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Enable, class T = void&gt;
struct [[gnu::packed]] foo {
  int i{};
  bool b{};
  /*TODO - optional field of type T when Enabled */
};

static_assert(sizeof(int) + sizeof(bool) == sizeof(foo&lt;false&gt;));
static_assert(sizeof(int) + sizeof(bool) + sizeof(int) == sizeof(foo&lt;true, int&gt;));

struct bar{};
static_assert(sizeof(int) + sizeof(bool) == sizeof(foo&lt;true, bar&gt;));

struct baz{ int i{}; };
static_assert(sizeof(int) + sizeof(bool)  + sizeof(baz) == sizeof(foo&lt;true, baz&gt;));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sj5bEx">https://godbolt.org/z/sj5bEx</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
struct disabled{};

template &lt;auto Enable, class T&gt;
  using when_enabled_t = std::conditional_t&lt;Enable, T, disabled&gt;;
}

template&lt;auto Enable, class T = void&gt;
struct [[gnu::packed]] foo {
  int i{};
  bool b{};
  [[no_unique_address]] detail::when_enabled_t&lt;Enable, T&gt; t{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/ov5d6z">https://godbolt.org/z/ov5d6z</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Enable, class T = void&gt;
struct [[gnu::packed]] foo {
  int i{};
  bool b{};
  struct empty{};
  [[no_unique_address]] std::conditional_t&lt;Enable, T, empty&gt; c;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9rGrTj">https://godbolt.org/z/9rGrTj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Enable, class T = void&gt;
struct [[gnu::packed]] foo {
  int i{};
  bool b{};
};

template&lt;class T&gt;
struct [[gnu::packed]] foo&lt;true,T&gt; {
    int i{};
    bool b{};
    [[no_unique_address]] T t{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oor65K">https://godbolt.org/z/oor65K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Enable, class T = void&gt;
struct [[gnu::packed]] foo {
  int i{};
  bool b{};
  [[no_unique_address]] std::conditional_t&lt;Enable, T, std::tuple&lt;&gt;&gt; t{};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fne13q">https://godbolt.org/z/fne13q</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>194 - Did you know about C++23 proposal to add `views::enumerate`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/194.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/194.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about C++23 proposal to add <code>views::enumerate</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p2164">http://wg21.link/p2164</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::vector items{1, 2, 3};
  for (auto [i, v] : std::views::enumerate(items)) {
    std::cout &lt;&lt; i &lt;&lt; v; // prints 011223
  }
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vash36">https://godbolt.org/z/vash36</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simplified, standard-compliant version of <code>views::enumerate</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/* TODO - views::enumerate */

int main() {
  using namespace boost::ut;

  &quot;enumerate numbers&quot;_test = [i = 0] {
    std::vector items{1, 2, 3};
    for (auto [index, value] : views::enumerate(items)) {
      expect(_i(i) == index and _i(i + 1) == value);
      ++mut(i);
    }
  };

  &quot;enumerate strings&quot;_test = [i = 0] {
    using std::literals::string_literals::operator&quot;&quot;s;
    std::vector items{&quot;1&quot;s, &quot;2&quot;s, &quot;3&quot;s};
    for (auto [index, value] : views::enumerate(items)) {
      expect(_i(i) == index and std::to_string(i + 1) == value);
      ++mut(i);
    }
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/W85MTj">https://godbolt.org/z/W85MTj</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace views {
    template &lt;typename C&gt;
    struct enumerate {
        constexpr enumerate(C&amp; c) : container(c) {}

        struct iterator {
            constexpr iterator(C&amp; c) : c_it{std::begin(c)} {}

            constexpr auto operator*() -&gt; std::pair&lt;int, typename C::reference&gt; {
                return {index, *c_it};
            }
            constexpr auto&amp; operator++() { ++c_it; ++index; return *this; }

            typename C::iterator c_it{};
            int index{};
        };

        struct sentinel {
            constexpr sentinel(C&amp; c) : c_it{std::end(c)} {}
            constexpr bool operator==(iterator i) const {
                return i.c_it == c_it;
            }
            typename C::iterator c_it{};
        };

        constexpr auto begin() { return iterator{container}; }
        constexpr auto end() { return sentinel{container}; }

        C&amp; container;
    };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hMoYhh">https://godbolt.org/z/hMoYhh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace views {
template &lt;typename TIterated, typename count_type = unsigned int&gt;
struct enumerate {
    constexpr explicit(true) enumerate(const std::vector&lt;TIterated&gt;&amp; items)
    {
        std::transform(std::begin(items), std::end(items), std::back_inserter(enumerated_items), [](const auto&amp; item) {
            static auto count = std::numeric_limits&lt;count_type&gt;::min();
            return std::pair(count++, item);
        });
    }
    auto begin() const { return std::begin(enumerated_items); }
    auto end() const { return std::end(enumerated_items); }

    std::vector&lt;std::pair&lt;count_type, TIterated&gt;&gt; enumerated_items {};
};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/73G3E5">https://godbolt.org/z/73G3E5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace views {
template&lt;template&lt;class...&gt; class C, class E&gt;
struct enumerate {
    struct iter  {
        iter(size_t index, C&lt;E&gt; const&amp; items) : index(index), items(items) {}
        bool operator!=(iter&amp; other) { return index != other.index; }
        void operator++() { index++; }
        auto operator*() { return std::make_pair(index, *(items.begin()+index)); }
        size_t index;
        const C&lt;E&gt;&amp; items;
    };
    enumerate(C&lt;E&gt; const&amp; items) : items(items) {}
    iter begin() const { return iter(0, items); }
    iter end() const { return iter(items.size(), items);}
    C&lt;E&gt; const&amp; items;
};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s1cY1K">https://godbolt.org/z/s1cY1K</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace views {
    template&lt;typename V&gt;
    class enumerate_view {
        V base_;

        class iterator {
            using Base = V;
            using iterator_t = decltype(std::declval&lt;Base&gt;().begin());
            using count_type = decltype(std::declval&lt;Base&gt;().size());
            using reference_t = typename Base::reference;

            iterator_t current_;
            count_type pos_;
        public:
            struct reference {
                const count_type index;
                reference_t value;
            };

            constexpr explicit iterator(iterator_t current, count_type pos) : current_(std::move(current)), pos_(pos) {}

            constexpr decltype(auto) operator*() const { return reference{pos_, *current_}; }

            constexpr iterator&amp; operator++() { ++pos_; ++current_; return *this; }

            friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y) { return x.current_ == y.current_; }
        };

    public:
        constexpr enumerate_view(V base) : base_(base) {}

        constexpr auto begin() { return iterator(base_.begin(), 0); }
        constexpr auto end() { return iterator(base_.end(), size()); }
        constexpr auto size() { return base_.size(); }
    };

    constexpr auto enumerate(auto values) { return enumerate_view(values); }
} // namespace views
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4h5MPe">https://godbolt.org/z/4h5MPe</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>193 - Did you know that C++20 added support for `constexpr new`?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/193.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/193.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added support for <code>constexpr new</code>?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0784">http://wg21.link/p0784</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto foo() {
  auto p = new int{42};
  delete p;
  return true;
}

constexpr auto bar() {
  auto p = new int{42};
  //delete p;
  return false;
}

static_assert(foo());
static_assert(bar()); // compilation error - allocation performed here was not deallocated
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oPd7zY">https://godbolt.org/z/oPd7zY</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simplified version of <code>unique_ptr</code> which will take advantage of <code>constexpr new</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/*TODO - constexpr unique_ptr */

template&lt;class T&gt;
constexpr auto foo(T value) {
  return unique_ptr{new T(value)};
}

static_assert(std::is_same_v&lt;unique_ptr&lt;int&gt;, decltype(foo(int{}))&gt;);
static_assert(std::is_same_v&lt;unique_ptr&lt;double&gt;, decltype(foo(double{}))&gt;);

static_assert(0 == *foo(0));
static_assert(42 == *foo(42));

static_assert(4.2f == *foo(4.2f));
static_assert(42.d == *foo(42.d));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rPb85a">https://godbolt.org/z/rPb85a</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
class unique_ptr {
public:
    constexpr unique_ptr(T* ptr) : ptr(ptr) {}
    constexpr T operator*() { return *ptr; }
    constexpr ~unique_ptr() { delete ptr; }
private:
    T* ptr = nullptr;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z6PcME">https://godbolt.org/z/z6PcME</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct unique_ptr {
    constexpr unique_ptr(T* p) : ptr_(p) {}
    constexpr ~unique_ptr() { delete ptr_; }
    constexpr const auto&amp; operator*() const { return *ptr_; }

private:
    T* ptr_;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rh5r5a">https://godbolt.org/z/rh5r5a</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename T&gt;
class unique_ptr
{
    public:
        constexpr unique_ptr(T* value) : _value(value) {}
        constexpr T&amp; operator*() {return *_value;}
        constexpr ~unique_ptr() {delete _value;}
    private:
        T* _value;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/fMEKTo">https://godbolt.org/z/fMEKTo</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
class unique_ptr {
    T* ptr;
public:
    constexpr unique_ptr(T* ptr) : ptr(ptr) {}
    constexpr std::add_lvalue_reference_t&lt;T&gt; operator*() { return *ptr; }
    constexpr ~unique_ptr() { delete ptr; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cGs9PG">https://godbolt.org/z/cGs9PG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct unique_ptr {
  constexpr explicit(true) unique_ptr(T *arg) : val(arg) {}
  constexpr ~unique_ptr() { delete val; }

  [[nodiscard]] constexpr T operator*() const noexcept { return *val; }

  T *val;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/v1abT6">https://godbolt.org/z/v1abT6</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>192 - Did you know about `std::expected` proposal for error handling?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/192.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/192.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about <code>std::expected</code> proposal for error handling?</strong></p>
</li>
<li>
<p><a href="http://wg21.link/p0323">http://wg21.link/p0323</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto error(auto has_error) -&gt; std::experimental::expected&lt;bool, int&gt; {
  if (has_error) {
    return std::experimental::unexpected{42};
  } else {
    return true;
  }
}

int main() {
  assert(error(false));
  assert(error(false).value());

  assert(not error(true).has_value());
  assert(42 == error(true).error());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/x1TKGv">https://godbolt.org/z/x1TKGv</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simplified version of <code>expected</code> proposal for error handling?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/*TODO - expected/unexpected*/

template&lt;auto Error, class TValue, class TError&gt;
constexpr auto handle_error(TValue value, TError error) -&gt; expected&lt;TValue, TError&gt; {
  if (Error) {
    return unexpected{error};
  } else {
    return value;
  }
}

int main() {
  using namespace boost::ut;
  using namespace std::string_literals;

  &quot;handle error&quot;_test = [] {
    constexpr auto error = true;
    constexpr auto no_error = false;

    should(&quot;be convertible to bool&quot;) = [] {
      struct {} _;
      expect(handle_error&lt;no_error&gt;(_, _) and
         not handle_error&lt;   error&gt;(_, _));
    };

    should(&quot;contain a value&quot;) = [] {
      const auto handle_error = ::handle_error&lt;no_error&gt;(42, std::runtime_error{&quot;error&quot;s});
      expect(handle_error and
             handle_error.has_value() and
             handle_error.value() == 42_i
      );
    };

    should(&quot;contain an error&quot;) = [] {
      const auto handle_error = ::handle_error&lt;error&gt;(42, std::runtime_error{&quot;error&quot;s});
      expect(not handle_error and
             not handle_error.has_value() and
             &quot;error&quot;s == handle_error.error().what()
      );
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/rf4sP5">https://godbolt.org/z/rf4sP5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct error_tag {};

template &lt;class TValue, class TError&gt;
struct expected {
    constexpr expected(TValue val) : value_{std::in_place_index&lt;0&gt;, val} {}
    constexpr expected(TError err, error_tag) : value_{std::in_place_index&lt;1&gt;, err} {}

    constexpr explicit operator bool() const { return has_value(); }
    constexpr auto has_value() const { return value_.index() == 0; }
    constexpr auto value() const { return std::get&lt;0&gt;(value_); }
    constexpr auto error() const { return std::get&lt;1&gt;(value_); }

private:
    std::variant&lt;TValue, TError&gt; value_;
};

template &lt;class TError&gt;
struct unexpected {
    constexpr unexpected(TError error) : error_(error) {}

    template &lt;class TValue&gt;
    constexpr operator expected&lt;TValue, TError&gt;() { return expected&lt;TValue, TError&gt;{error_, error_tag{}}; }

private:
    TError error_;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/E6M5nr">https://godbolt.org/z/E6M5nr</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class TError&gt;
struct unexpected {
    unexpected(TError error) :error(error) {}
    TError error;
};

template&lt;class TValue, class TError&gt;
struct expected {
    expected(TValue value) : value_(value), has_value_(true)  {}
    expected(unexpected&lt;TError&gt; un) : has_value_(false), error_(un.error) {}
    operator bool() const { return has_value_;}
    TValue value() const { return value_; }
    bool has_value() const { return has_value_; }
    TError error() const { return error_.value(); }
private:
    TValue value_;
    bool has_value_;
    std::optional&lt;TError&gt; error_;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4zbzTh">https://godbolt.org/z/4zbzTh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TValue, typename TError&gt;
struct expected {
  constexpr explicit(false) expected(const TValue&amp; value)
      : val_or_err{std::in_place_index&lt;VAL_INDEX&gt;, value} {}
  constexpr explicit(true) expected(const TError&amp; error, [[maybe_unused]] const auto is_value)
      : val_or_err{std::in_place_index&lt;ERR_INDEX&gt;, error} {}

  constexpr operator bool() const { return has_value(); }
  constexpr auto has_value() const { return val_or_err.index() == VAL_INDEX; }
  constexpr auto value() const { return std::get&lt;VAL_INDEX&gt;(val_or_err); }
  constexpr auto error() const { return std::get&lt;ERR_INDEX&gt;(val_or_err); }

  static const auto VAL_INDEX = 0;
  static const auto ERR_INDEX = 1;
  std::variant&lt;TValue, TError&gt; val_or_err;
};

template &lt;typename TError&gt;
struct unexpected {
  constexpr explicit(true) unexpected(const TError&amp; e) : error{e} {}

  template &lt;typename TValue&gt;
  constexpr operator expected&lt;TValue, TError&gt;() const {
    return expected&lt;TValue, TError&gt;{error, false};
  }

  TError error;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/q69dK5">https://godbolt.org/z/q69dK5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename E&gt;
struct unexpected
{
    unexpected(E e) : error(std::move(e)) { }
    E error;
};

template&lt;typename T, typename E&gt;
struct expected : std::optional&lt;T&gt;
{
    expected(T t) : std::optional&lt;T&gt;(std::move(t)) { }
    expected(unexpected&lt;E&gt; u) : err(std::move(u.error)) {}
    E error() const { return err.value(); }
    std::optional&lt;E&gt; err;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/EKxYhb">https://godbolt.org/z/EKxYhb</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>191 - Did you know that expression evaluation order is not specified?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/191.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/191.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that expression evaluation order is not specified?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p0145">https://wg21.link/p0145</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  struct arg { arg(int n) { std::printf(&quot;arg%d &quot;, n); } };
  auto il =    {arg{1}, arg{2}, arg{3}}; // arg1 arg2 arg3
  [](auto...){}(arg{1}, arg{2}, arg{3}); // order unspecified
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jEhj61">https://godbolt.org/z/jEhj61</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a subroutine <code>is_evaluating_args_from_left_to_right</code> which returns { true: if expression arguments are evaluated from left to right, false: otherwise }?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/*TODO - is_evaluating_args_from_left_to_right */

int main() {
  using namespace boost::ut;

  &quot;function arguments evaluation order&quot;_test = [] {
    #if defined(__clang__)
      expect(is_evaluating_args_from_left_to_right()) &lt;&lt; &quot;run-time&quot;;
      expect(constant&lt;is_evaluating_args_from_left_to_right()&gt;) &lt;&lt; &quot;compile-time&quot;;
    #else
      expect(not is_evaluating_args_from_left_to_right()) &lt;&lt; &quot;run-time&quot;;
      expect(constant&lt;is_evaluating_args_from_left_to_right()&gt;) &lt;&lt; &quot;compile-time&quot;;
    #endif
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z77eTT">https://godbolt.org/z/z77eTT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr bool is_evaluating_args_from_left_to_right() {
    std::array&lt;int, 3&gt; ex = {1,2,3};
    int i=0;
    std::array&lt;int, 3&gt; tst;
    auto f = [&amp;i, &amp;tst] (auto e) { return tst[i++]=e;};
    [](auto...){}(f(1),f(2),f(3));
    return std::equal(ex.begin(), ex.end(), tst.begin());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gv7P7d">https://godbolt.org/z/Gv7P7d</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto is_evaluating_args_from_left_to_right() {
    auto i = 0;
    struct S {
        constexpr S(int&amp; i) : first(i++ == 0) {}
        bool first;
    };
    return [](auto x, auto) { return x.first; }(S{i}, S{i});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jr74fT">https://godbolt.org/z/jr74fT</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto is_evaluating_args_from_left_to_right() {
    auto i = 0;
    auto f = [&amp;]() { return i++; };
    return [](auto lhs, auto rhs) { return lhs &lt; rhs; }(f(), f());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/va4d8v">https://godbolt.org/z/va4d8v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto is_evaluating_args_from_left_to_right = [] {
  auto result = false;
  [](auto...) { } (result = true, result = false);
  return not result;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oE1Tjj">https://godbolt.org/z/oE1Tjj</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>190 - Did you know that C++20 added `ostream_joiner` that writes successive objects into the basic_ostream separated by a delimiter?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/190.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/190.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++20 added <code>ostream_joiner</code> that writes successive objects into the basic_ostream separated by a delimiter?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p1293">https://wg21.link/p1293</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::vector v{1, 2, 3};
  std::copy(std::cbegin(v), std::cend(v), std::ostream_joiner{std::cout, &quot;, &quot;}); // prints 1, 2, 3
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/esavfj">https://godbolt.org/z/esavfj</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a simplified version of <code>std::ostream_joiner</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/* TODO - ostream_joiner */

int main() {
  using namespace boost::ut;
  using std::literals::string_literals::operator&quot;&quot;s;

  &quot;ostream joiner&quot;_test = [] {
    should(&quot;produce an empty&quot;) = [stream = std::stringstream{}, v = std::vector&lt;int&gt;{}] {
      std::copy(std::cbegin(v), std::cend(v), ostream_joiner{mut(stream), &quot;&quot;});
      expect(stream.str() == &quot;&quot;s);
    };

    should(&quot;join vector elements&quot;) = [stream = std::stringstream{}, v = std::vector{'a', 'b', 'c'}] {
      std::copy(std::cbegin(v), std::cend(v), ostream_joiner{mut(stream), &quot;&quot;});
      expect(stream.str() == &quot;abc&quot;s);
    };

    should(&quot;join vector elements with comma&quot;) = [stream = std::stringstream{}, v = std::vector{1, 2, 3}] {
      std::copy(std::cbegin(v), std::cend(v), ostream_joiner{mut(stream), &quot;, &quot;});
      expect(stream.str() == &quot;1, 2, 3&quot;s);
    };

    should(&quot;join array elements with pipe&quot;) = [stream = std::stringstream{}, v = std::array{&quot;ab&quot;, &quot;cd&quot;}] {
      std::copy(std::cbegin(v), std::cend(v), ostream_joiner{mut(stream), &quot; | &quot;});
      expect(stream.str() == &quot;ab | cd&quot;s);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/vb8jhb">https://godbolt.org/z/vb8jhb</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">struct ostream_joiner{
    ostream_joiner(std::ostream&amp; s, std::string_view separator)
        : s{s}, separator{separator} {}

    auto&amp; operator++() { return *this; }
    auto&amp; operator*() { return *this; }
    auto&amp; operator=(auto&amp;&amp; anything) {
        if (emit_separator)
            s &lt;&lt; separator;
        else
            emit_separator = true;
        s &lt;&lt; std::forward&lt;decltype(anything)&gt;(anything);
        return *this;
    }

 private:
    std::ostream&amp; s;
    const std::string_view separator;
    bool emit_separator{false};
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/hT6j77">https://godbolt.org/z/hT6j77</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct ostream_joiner {
    ostream_joiner(std::stringstream&amp; ss, std::string_view sep) : incr(false), ss(ss), sep(sep) {}
    template&lt;class T&gt;
    void operator=(T e) {
        if(incr)
            ss &lt;&lt; sep;
        incr = false;
        ss &lt;&lt; e; }

    ostream_joiner&amp; operator*() { return *this; }
    void operator++() { incr = true; }

    std::stringstream&amp; ss;
    std::string_view sep;
    bool incr;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/M9zjar">https://godbolt.org/z/M9zjar</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TStream, typename TSep&gt;
struct ostream_joiner {
    ostream_joiner(TStream&amp; stream, TSep sep) : stream_(stream), sep_(std::move(sep)) {}

    auto&amp; operator*() { return *this; }
    auto&amp; operator=(const auto&amp; c) {
        if (not std::exchange(first_, false)) {
            stream_ &lt;&lt; sep_;
        }
        stream_ &lt;&lt; c;
        return *this;
    }
    auto&amp; operator++() { return *this; }

private:
    TStream&amp; stream_;
    TSep sep_;
    bool first_ = true;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/4zKzeM">https://godbolt.org/z/4zKzeM</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct ostream_joiner {
private:
    std::ostream&amp; output;
    const std::string delimiter;
    bool first{true};

public:
    ostream_joiner(std::ostream&amp; stream, const std::string&amp; delim) : output(stream), delimiter(delim) {}

    template &lt;typename T&gt;
    auto&amp; operator=(T&amp;&amp; input)
    {
        if (first) {
            first = false;
        } else {
            output &lt;&lt; delimiter;
        }

        output &lt;&lt; std::forward&lt;T&gt;(input);
        return *this;
    }

    auto&amp; operator++() { return *this; }
    auto&amp; operator*() { return *this; }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/johae9">https://godbolt.org/z/johae9</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct ostream_joiner {
    constexpr explicit(true) ostream_joiner(auto&amp; stream, const auto&amp; sep)
        : output_stream(stream)
        , separator(sep)
    {}
    auto operator++() const noexcept { return *this; }
    auto operator*() const noexcept{ return *this; }
    auto operator=(const auto&amp; rhs)
    {
        static bool is_first = true;
        if (not is_first) {
            output_stream &lt;&lt; separator;
        } else {
            is_first = false;
        }
        output_stream &lt;&lt; rhs;
        return *this;
    }

    std::stringstream&amp; output_stream;
    std::string separator;
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Ke3Gxn">https://godbolt.org/z/Ke3Gxn</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>189 - Did you know that Compile Time Regular Expressions support extracting matches?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/189.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/189.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that Compile Time Regular Expressions support extracting matches?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p1433r0">https://wg21.link/p1433r0</a></p>
</li>
<li><a href="https://github.com/hanickadot/compile-time-regular-expressions">https://github.com/hanickadot/compile-time-regular-expressions</a></li>
<li><a href="https://regexr.com">https://regexr.com</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
   using namespace ctre::literals;
   if (const auto match = ctre::match&lt;&quot;([0-9]+)&quot;&gt;(&quot;42&quot;)) {
     std::cout &lt;&lt; match.get&lt;1&gt;().to_view(); // prints 42
   }
}
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/4Ps48P">https://gcc.godbolt.org/z/4Ps48P</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>parse_args</code> function which returns an initialized type <code>T</code> based on their patterns?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;ctll::fixed_string Pattern, class T&gt;
struct arg {
  static constexpr auto pattern = Pattern;
  constexpr operator auto() const { return value; }
  T value;
};

template&lt;class T&gt;
constexpr auto parse_args(std::string_view input) -&gt; T {
  return {}; // TODO
}

struct empty { };

struct args1 {
  arg&lt;&quot;num=([0-9]*)&quot;, int&gt; num;
};

struct args2 {
  arg&lt;&quot;quant=([0-9]*)&quot;, int&gt; quant;
  arg&lt;&quot;lab=([0-9]*)&quot;, int&gt; lab;
};

struct args3 {
  arg&lt;&quot;quant=([^\\s]*)&quot;, std::string_view&gt; quant;
  arg&lt;&quot;lab=([^\\s]*)&quot;, std::string_view&gt; lab;
  arg&lt;&quot;num=([0-9]*)&quot;, int&gt; num;
};

static_assert(std::is_same_v&lt;empty, decltype(parse_args&lt;empty&gt;(&quot;&quot;))&gt;);

static_assert(42 == parse_args&lt;args1&gt;(&quot;num=42&quot;).num);
static_assert(4 == parse_args&lt;args2&gt;(&quot;quant=4 lab=2&quot;).quant);
static_assert(2 == parse_args&lt;args2&gt;(&quot;quant=4 lab=2&quot;).lab);

using std::literals::string_view_literals::operator&quot;&quot;sv;
static_assert(&quot;Quant&quot;sv == parse_args&lt;args3&gt;(&quot;quant=Quant lab=Lab num=42&quot;).quant);
static_assert(&quot;Lab&quot;sv == parse_args&lt;args3&gt;(&quot;quant=Quant lab=Lab num=42&quot;).lab);
static_assert(42 == parse_args&lt;args3&gt;(&quot;quant=Quant lab=Lab num=42&quot;).num);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/qPao8G">https://godbolt.org/z/qPao8G</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename T&gt;
constexpr auto to_value(std::string_view sv) {
  return T{sv};
}

template &lt;std::integral T&gt;
constexpr auto to_value(std::string_view sv) {
  T ret{};
  nonstd::from_chars(std::data(sv), std::data(sv) + std::size(sv), ret);
  return ret;
}

template &lt;class T&gt;
constexpr auto parse_arg(std::string_view input) {
  if (const auto [whole, val] = ctre::search&lt;T::pattern&gt;(input); whole) {
    return T{.value = to_value&lt;decltype(T::value)&gt;(val)};
  } else {
    return T{};
  }
}

template &lt;class T, template &lt;class...&gt; class TList, class... Args&gt;
constexpr auto parse_args(std::string_view input, TList&lt;Args...&gt;) {
  return T{parse_arg&lt;Args&gt;(input)...};
}

} // namespace detail

template&lt;class T&gt;
constexpr auto parse_args(std::string_view input) -&gt; T {
  return detail::parse_args&lt;T&gt;(input, detail::members_list_t&lt;T&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7W6EeY">https://godbolt.org/z/7W6EeY</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr auto parse_args(std::string_view input) -&gt; T {
  return [input]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) {
     constexpr auto tuple = to_tuple(T{});
     constexpr auto pattern = ((std::get&lt;Ns&gt;(tuple).pattern + ctll::fixed_string(&quot;\\s*&quot;)) + ...);
     const auto match = ctre::match&lt;pattern&gt;(input);
     return T{
       []&lt;class TValue&gt;(auto arg) {
         if constexpr (std::is_integral_v&lt;TValue&gt;) {
           return stoi(arg);
         } else {
           return arg;
         }
       }.template operator()&lt;decltype(std::get&lt;Ns&gt;(tuple).value)&gt;(match.template get&lt;Ns + 1&gt;().to_view())...
     };
  }(std::make_index_sequence&lt;std::tuple_size_v&lt;decltype(to_tuple(T{}))&gt;&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Tbox4b">https://godbolt.org/z/Tbox4b</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class T&gt;
constexpr auto parse_args(std::string_view input)
{
    const auto extract_match = [&amp;input]&lt;typename TArg&gt;() {
        const auto [_, match] = ctre::search&lt;TArg::pattern&gt;(input);
        if constexpr (std::is_integral_v&lt;typename TArg::value_t&gt;) {
            return detail::stoi(match);
        } else {
            return match;
        }
    };

    auto output = T {};
    if constexpr (requires { output.num; }) {
        output.num = extract_match.template operator()&lt;decltype(T {}.num)&gt;();
    }
    if constexpr (requires { output.quant; }) {
        output.quant = extract_match.template operator()&lt;decltype(T {}.quant)&gt;();
    }
    if constexpr (requires { output.lab; }) {
        output.lab = extract_match.template operator()&lt;decltype(T {}.lab)&gt;();
    }
    return output;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5W3vG4">https://godbolt.org/z/5W3vG4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
template &lt;typename&gt;
constexpr auto parse_arg(auto arg) {
  return arg;
}

template &lt;typename T&gt; requires std::is_integral_v&lt;T&gt;
constexpr auto parse_arg(auto arg) {
  return stoi(arg);
}
} // namespace detail

template &lt;typename T&gt;
constexpr auto parse_args(std::string_view input) {
  constexpr auto members = detail::make_members_tuple&lt;T&gt;();

  auto expand_args = [&amp;]&lt;auto... Ns&gt;(std::index_sequence&lt;Ns...&gt;) -&gt; T {
    return {
      detail::parse_arg&lt;decltype(std::get&lt;Ns&gt;(members).value)&gt;(
        ctre::search&lt;std::get&lt;Ns&gt;(members).pattern&gt;(input)
          .template get&lt;1&gt;()
          .to_view())...};
  };

  return expand_args(
    std::make_index_sequence&lt;std::tuple_size_v&lt;decltype(members)&gt;&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/7KKcbW">https://godbolt.org/z/7KKcbW</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
constexpr T fromSV(std::string_view input);

template&lt;&gt;
constexpr std::string_view fromSV&lt;std::string_view&gt;(std::string_view input) {
    return input;
}

template&lt;&gt;
constexpr int fromSV&lt;int&gt;(std::string_view input) {
    int v = 0;
    for(size_t i=0; i&lt;input.size(); i++)
        v = v*10 + (input[i]-'0');
    return v;
}

template&lt;ctll::fixed_string Pattern, class T&gt;
struct arg {
  constexpr arg(std::string_view input) {
    if (const auto match = ctre::search&lt;pattern&gt;(input))
      value = fromSV&lt;T&gt;( match.template get&lt;1&gt;().to_view());
    else
      value = {};
  };
  static constexpr auto pattern = Pattern;
  constexpr operator auto() const { return value; }
  T value;
};

template&lt;class T&gt;
constexpr auto parse_args(std::string_view input) -&gt; T {
  using sv = std::string_view;
  if constexpr (std::is_constructible&lt;T, sv, sv, sv&gt;::value)
    return {input,input,input};
  if constexpr (std::is_constructible&lt;T, sv, sv&gt;::value)
    return {input, input};
  if constexpr (std::is_constructible&lt;T, sv&gt;::value)
    return {input};
}

struct empty { };

template&lt;&gt;
constexpr auto parse_args&lt;empty&gt;(std::string_view input) -&gt; empty {
    return empty{};
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dhGPj7">https://godbolt.org/z/dhGPj7</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>188 - Did you know about proposal to add Compile Time Regular Expressions?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/188.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/188.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about proposal to add Compile Time Regular Expressions?</strong></p>
</li>
<li>
<p><a href="https://wg21.link/p1433r0">https://wg21.link/p1433r0</a></p>
</li>
<li><a href="https://github.com/hanickadot/compile-time-regular-expressions">https://github.com/hanickadot/compile-time-regular-expressions</a></li>
<li><a href="https://regexr.com">https://regexr.com</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">static_assert(not ctre::match&lt;&quot;hello&quot;&gt;(&quot;world&quot;));

static_assert(ctre::match&lt;&quot;hello world&quot;&gt;(&quot;hello world&quot;));
static_assert(ctre::match&lt;&quot;.*&quot;&gt;(&quot;hello world&quot;));
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/dKKTo5">https://gcc.godbolt.org/z/dKKTo5</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you fill <code>TODO</code> with appropriate regular expressions?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  using namespace boost::ut;

  &quot;regex&quot;_test = [] {
    should(&quot;match numbers&quot;) = [] {
       constexpr auto number = ctll::fixed_string{&quot;&quot;}; // TODO

       expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

       expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
       expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
       expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
       expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
       expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
    };

    should(&quot;match an IPv4 address&quot;) = [] {
      constexpr auto ipv4 = ctll::fixed_string{&quot;&quot;}; // TODO

      expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

      expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/KhPaEo">https://gcc.godbolt.org/z/KhPaEo</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">&quot;regex&quot;_test = [] {
  should(&quot;match numbers&quot;) = [] {
     constexpr auto number = ctll::fixed_string{R&quot;(^-?\d+(\.\d+)?$)&quot;};

     expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

     expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multiple&quot;;
     expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
  };

  should(&quot;match an IPv4 address&quot;) = [] {
    constexpr auto ipv4 = ctll::fixed_string{R&quot;(^(\d{1,3}\.){3}\d{1,3}$)&quot;};

    expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
  };
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/aevP8M">https://gcc.godbolt.org/z/aevP8M</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;regex&quot;_test = [] {
  should(&quot;match numbers&quot;) = [] {
     constexpr auto number = ctll::fixed_string{&quot;-?\\d+(\\.\\d+)?&quot;}; // TODO

     expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

     expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
     expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
  };

  should(&quot;match an IPv4 address&quot;) = [] {
    constexpr auto ipv4 = ctll::fixed_string{&quot;\\d+\\.\\d+\\.\\d+\\.\\d+&quot;}; // TODO

    expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
  };
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/3E1W93">https://gcc.godbolt.org/z/3E1W93</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;regex&quot;_test = [] {
  should(&quot;match numbers&quot;) = [] {
     constexpr auto number = ctll::fixed_string{R&quot;(^-?\d+(\.\d+)?$)&quot;};

     expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

     expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
     expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
  };

  should(&quot;match an IPv4 address&quot;) = [] {
    constexpr auto ipv4 = ctll::fixed_string{R&quot;(^\d+(\.\d+){3}$)&quot;};

    expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
  };
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/h785Ka">https://gcc.godbolt.org/z/h785Ka</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">  &quot;regex&quot;_test = [] {
    should(&quot;match numbers&quot;) = [] {
       constexpr auto number = ctll::fixed_string{R&quot;(-?\d+(\.\d+)?)&quot;};

       expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
       expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

       expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
       expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
       expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
       expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
       expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
    };

    should(&quot;match an IPv4 address&quot;) = [] {
      constexpr auto ipv4 = ctll::fixed_string{R&quot;(^\d{1,3}(\.\d{1,3}){3})&quot;};

      expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
      expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

      expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
      expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
    };
  };
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/7Yfo4v">https://gcc.godbolt.org/z/7Yfo4v</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;regex&quot;_test = [] {
  should(&quot;match numbers&quot;) = [] {
     constexpr auto number = ctll::fixed_string{R&quot;(-?\d+(\.\d+)?)&quot;};

     expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

     expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
     expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
  };

  should(&quot;match an IPv4 address&quot;) = [] {
    constexpr auto ipv4 = ctll::fixed_string{R&quot;((\d{1,3}\.){3}\d{1,3})&quot;};

    expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
  };
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/cvEMzG">https://gcc.godbolt.org/z/cvEMzG</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;regex&quot;_test = [] {
  should(&quot;match numbers&quot;) = [] {
     constexpr auto number = ctll::fixed_string{&quot;-?\\d+\\.?\\d*&quot;}; // TODO

     expect(not ctre::match&lt;number&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;O&quot;)) &lt;&lt; &quot;letter&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;abc&quot;)) &lt;&lt; &quot;string&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.a&quot;)) &lt;&lt; &quot;partial number&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;multiple dots&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;1 2&quot;)) &lt;&lt; &quot;spaces&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;--42&quot;)) &lt;&lt; &quot;double minus&quot;;
     expect(not ctre::match&lt;number&gt;(&quot;42-&quot;)) &lt;&lt; &quot;minus at the end&quot;;

     expect(ctre::match&lt;number&gt;(&quot;1&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;9&quot;)) &lt;&lt; &quot;single&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1234&quot;)) &lt;&lt; &quot;multipv4le&quot;;
     expect(ctre::match&lt;number&gt;(&quot;-42&quot;)) &lt;&lt; &quot;negative&quot;;
     expect(ctre::match&lt;number&gt;(&quot;1.234&quot;)) &lt;&lt; &quot;floating-point&quot;;
  };

  should(&quot;match an IPv4 address&quot;) = [] {
    constexpr auto ipv4 = ctll::fixed_string{&quot;(?:[0-9]{1,3}\\.){3}[0-9]{1,3}&quot;}; // TODO

    expect(not ctre::match&lt;ipv4&gt;(&quot;&quot;)) &lt;&lt; &quot;empty&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1 2 3 4&quot;)) &lt;&lt; &quot;spaces instead of spaces&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;.1.2.3.4.&quot;)) &lt;&lt; &quot;too many dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3&quot;)) &lt;&lt; &quot;too litle dots&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;1.2.3.&quot;)) &lt;&lt; &quot;missing number&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;
    expect(not ctre::match&lt;ipv4&gt;(&quot;a.b.c.d&quot;)) &lt;&lt; &quot;letters instead of numbers&quot;;

    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;1.2.3.4&quot;)) &lt;&lt; &quot;simple&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;10.0.0.0&quot;)) &lt;&lt; &quot;A&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;172.16.0.1&quot;)) &lt;&lt; &quot;B&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;192.168.0.2&quot;)) &lt;&lt; &quot;C&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;127.0.0.1&quot;)) &lt;&lt; &quot;loopback&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;224.0.0.1&quot;)) &lt;&lt; &quot;multicast&quot;;
    expect(ctre::match&lt;ipv4&gt;(&quot;255.255.255.255&quot;)) &lt;&lt; &quot;broadcast&quot;;
  };
};
</code></pre>

<blockquote>
<p><a href="https://gcc.godbolt.org/z/EYWcfs">https://gcc.godbolt.org/z/EYWcfs</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>187 - Did you know that C++17 made exception specifications be part of the type system?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/187.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/187.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that C++17 made exception specifications be part of the type system?</strong></p>
</li>
<li>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  void (*f1)();
  void (*f2)() noexcept;

  f1 = f2; // okay
  f2 = f1; // ill-formed since C++17
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Majq8f">https://godbolt.org/z/Majq8f</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>function_args_t</code> type trait which takes an invocable, respect <code>noexcept</code> and returns its arguments?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">struct args{};
struct va_args {};

template&lt;class T&gt;
using function_args_t = /*TODO*/

int f1();
int f2() noexcept;
constexpr auto f3() noexcept -&gt; void;
constexpr auto f4(...) noexcept -&gt; void;
constexpr auto f5(int, ...) noexcept -&gt; void;
constexpr auto f6(int...) noexcept -&gt; void;

auto l1 = [] {};
auto l2 = [](int...) noexcept {};
auto l3 = [](auto...) noexcept {};
auto l4 = [](auto......) noexcept {};
constexpr auto l5 = [](auto..., auto......) constexpr noexcept {};
constexpr auto l6 = []&lt;class... Ts&gt;(Ts..., auto......) constexpr noexcept {};
constexpr auto l7 = []&lt;auto...&gt;(...) constexpr noexcept {};

struct f {
  constexpr auto operator()(int, double, float) noexcept(false) -&gt; void;
};

static_assert(std::is_same_v&lt;std::tuple&lt;&gt;, function_args_t&lt;decltype(&amp;f1)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;&gt;, function_args_t&lt;decltype(&amp;f2)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;&gt;, function_args_t&lt;decltype(&amp;f3)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;va_args&gt;, function_args_t&lt;decltype(&amp;f4)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;int, va_args&gt;, function_args_t&lt;decltype(&amp;f5)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;int, va_args&gt;, function_args_t&lt;decltype(&amp;f6)&gt;&gt;);

static_assert(std::is_same_v&lt;std::tuple&lt;&gt;, function_args_t&lt;decltype(l1)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;int, va_args&gt;, function_args_t&lt;decltype(l2)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;args&gt;, function_args_t&lt;decltype(l3)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;args, va_args&gt;, function_args_t&lt;decltype(l4)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;args, va_args&gt;, function_args_t&lt;decltype(l5)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;args, va_args&gt;, function_args_t&lt;decltype(l6)&gt;&gt;);
static_assert(std::is_same_v&lt;std::tuple&lt;va_args&gt;, function_args_t&lt;decltype(l7)&gt;&gt;);

static_assert(std::is_same_v&lt;std::tuple&lt;int, double, float&gt;, function_args_t&lt;f&gt;&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Gq1Pxe">https://godbolt.org/z/Gq1Pxe</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">// forward decl for later specialization
template &lt;class T&gt; struct function_args;

// specialization for regular function
template &lt;class R, class... Ts, auto NE&gt;
struct function_args&lt;R(Ts...) noexcept(NE)&gt; {
  using arg_list_t = std::tuple&lt;Ts...&gt;;
};

// specialization for varargs function
template &lt;class R, class... Ts, auto NE&gt;
struct function_args&lt;R(Ts..., ...) noexcept(NE)&gt; {
  using arg_list_t = std::tuple&lt;Ts..., va_args&gt;;
};

// combinatorial explosion ahead

// specializations for const and non-const member functions
// with and without varargs
template &lt;class C, class R, class... Ts, auto NE&gt;
struct function_args&lt;R(C::*)(Ts...) const noexcept(NE)&gt; : function_args&lt;R(Ts...) noexcept(NE)&gt; {};

template &lt;class C, class R, class... Ts, auto NE&gt;
struct function_args&lt;R(C::*)(Ts..., ...) const noexcept(NE)&gt; : function_args&lt;R(Ts..., ...) noexcept(NE)&gt; {};

template &lt;class C, class R, class... Ts, auto NE&gt;
struct function_args&lt;R(C::*)(Ts...) noexcept(NE)&gt; : function_args&lt;R(Ts...) noexcept(NE)&gt; {};

// technically not needed for test
//template &lt;class C, class R, class... Ts, auto NE&gt;
//struct function_args&lt;R(C::*)(Ts..., ...) noexcept(NE)&gt; : function_args&lt;R(Ts..., ...) noexcept(NE)&gt; {};

// function overloads for getting the right thing out
// raw function pointers
template &lt;class T&gt; requires std::is_pointer_v&lt;T&gt;
constexpr auto fn_args() -&gt; function_args&lt;std::remove_pointer_t&lt;T&gt;&gt;;

// non-generic lambdas
template &lt;class T&gt; requires requires { &amp;T::operator(); }
constexpr auto fn_args() -&gt; function_args&lt;decltype(&amp;T::operator())&gt;;

// generic lambdas with class template parms
template &lt;typename T&gt; requires requires { &amp;T::template operator()&lt;args&gt;; }
constexpr auto fn_args() -&gt; function_args&lt;decltype(&amp;T::template operator()&lt;args&gt;)&gt;;

// generic lambdas with NTTPs
template &lt;typename T&gt; requires requires { &amp;T::template operator()&lt;1&gt;; }
constexpr auto fn_args() -&gt; function_args&lt;decltype(&amp;T::template operator()&lt;1&gt;)&gt;;

// one alias to rule them all
template &lt;class T&gt;
using function_args_t = decltype(fn_args&lt;T&gt;())::arg_list_t;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/s7h3Tn">https://godbolt.org/z/s7h3Tn</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class T&gt;
struct function_traits : function_traits&lt;decltype(&amp;T::operator())&gt; {};

template&lt;class T&gt; requires requires { T::template operator()&lt;args&gt;; }
struct function_traits&lt;T&gt; : function_traits&lt;decltype(&amp;T::template operator()&lt;args&gt;)&gt; {};

template&lt;class T&gt; requires requires { T::template operator()&lt;0&gt;; }
struct function_traits&lt;T&gt; : function_traits&lt;decltype(&amp;T::template operator()&lt;0&gt;)&gt; {};

template&lt;class R, class... TArgs, auto Noexcept&gt;
struct function_traits&lt;R(*)(TArgs...) noexcept(Noexcept)&gt; { using args = std::tuple&lt;TArgs...&gt;; };

template&lt;class R, class B, class... TArgs&gt;
struct function_traits&lt;R(B::*)(TArgs...)&gt; { using args = std::tuple&lt;TArgs...&gt;; };

template&lt;class R, class... TArgs, auto Noexcept&gt;
struct function_traits&lt;R(*)(TArgs......) noexcept(Noexcept)&gt; { using args = std::tuple&lt;TArgs..., va_args&gt;; };

template&lt;class R, class B, class... TArgs, auto Noexcept&gt;
struct function_traits&lt;R(B::*)(TArgs...) const noexcept(Noexcept)&gt; { using args = std::tuple&lt;TArgs...&gt;; };

template&lt;class R, class B, class... TArgs, auto Noexcept&gt;
struct function_traits&lt;R(B::*)(TArgs......) const noexcept(Noexcept)&gt; { using args = std::tuple&lt;TArgs..., va_args&gt;; };

template&lt;class T&gt;
using function_args_t = typename function_traits&lt;T&gt;::args;
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/9zcMe5">https://godbolt.org/z/9zcMe5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">namespace detail {
    constexpr int some_nttp = 0;
}

template&lt;typename T&gt; struct func_info_t;
template&lt;typename Ret, typename... Args, auto no_except_val&gt;
struct func_info_t&lt;Ret(*)(Args...) noexcept(no_except_val)&gt; {
    using args_t = std::tuple&lt;Args...&gt;;
};
template&lt;typename Ret, typename... Args, auto no_except_val&gt;
struct func_info_t&lt;Ret(*)(Args..., ...) noexcept(no_except_val)&gt; {
    using args_t = std::tuple&lt;Args..., va_args&gt;;
};
template&lt;typename Class, typename Ret, typename... Args, auto no_except_val&gt;
struct func_info_t&lt;Ret(Class::*)(Args...) noexcept(no_except_val)&gt; {
    using args_t = std::tuple&lt;Args...&gt;;
};
template&lt;typename Class, typename Ret, typename... Args, auto no_except_val&gt;
struct func_info_t&lt;Ret(Class::*)(Args...) const noexcept(no_except_val)&gt; {
    using args_t = std::tuple&lt;Args...&gt;;
};
template&lt;typename Class, typename Ret, typename... Args, auto no_except_val&gt;
struct func_info_t&lt;Ret(Class::*)(Args..., ...) const noexcept(no_except_val)&gt; {
    using args_t = std::tuple&lt;Args..., va_args&gt;;
};

template&lt;typename T&gt; requires std::is_pointer_v&lt;T&gt;
constexpr auto function_pointer_maker() -&gt; T;
template&lt;typename T&gt; requires requires { &amp;T::operator(); }
constexpr auto function_pointer_maker() -&gt; decltype(&amp;T::operator());
template&lt;typename T&gt; requires requires { &amp;T::template operator()&lt;args&gt;; }
constexpr auto function_pointer_maker() -&gt; decltype(&amp;T::template operator()&lt;args&gt;);
template&lt;typename T&gt; requires requires { &amp;T::template operator()&lt;detail::some_nttp&gt;; }
constexpr auto function_pointer_maker() -&gt; decltype(&amp;T::template operator()&lt;detail::some_nttp&gt;);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/d9YxP9">https://godbolt.org/z/d9YxP9</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>186 - Did you know Non-Type Template Parameters (NTTP) with User-Defined Literals (UDL) can be used to get compile-time strings?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/186.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/186.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know Non-Type Template Parameters (NTTP) with User-Defined Literals (UDL) can be used to get compile-time strings?</strong></p>
</li>
<li>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r2.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r2.pdf</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;auto Size&gt;
struct fixed_string {
  char data[Size + 1]{};
  static constexpr auto size = Size;
  constexpr explicit(false) fixed_string(char const* str) { std::copy_n(str, Size + 1, data); }
  constexpr explicit(false) operator std::string_view() const { return {data, Size}; }
};
template&lt;auto Size&gt; fixed_string(char const (&amp;)[Size]) -&gt; fixed_string&lt;Size - 1&gt;;

template&lt;fixed_string Str&gt; constexpr auto operator&quot;&quot;_s() { return Str; }

static_assert(sizeof(&quot;Quantlab&quot;) == sizeof(&quot;Quantlab&quot;_s));
static_assert(&quot;Quantlab&quot;sv == std::string_view{&quot;Quantlab&quot;_s});
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/zaqjMG">https://godbolt.org/z/zaqjMG</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement <code>fixed_format</code> subroutine which produces minimal size compile-time <code>fixed_string</code>?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto fixed_format(auto format, auto... args); /* TODO */

static_assert(fixed_format(&quot;&quot;_fmt) == &quot;&quot;sv);
static_assert(sizeof(&quot;&quot;) == sizeof(fixed_format(&quot;&quot;_fmt)));

static_assert(fixed_format(&quot;{}&quot;_fmt, &quot;Quantlab&quot;_s) == &quot;Quantlab&quot;sv);
static_assert(sizeof(&quot;Quantlab&quot;) == sizeof(fixed_format(&quot;{}&quot;_fmt, &quot;Quantlab&quot;_s)));

static_assert(fixed_format(&quot;|{}|{}|&quot;_fmt, &quot;Quant&quot;_s, &quot;lab&quot;_s) == &quot;|Quant|lab|&quot;sv);
static_assert(sizeof(&quot;|Quant|lab|&quot;) == sizeof(fixed_format(&quot;|{}|{}|&quot;_fmt, &quot;Quant&quot;_s, &quot;lab&quot;_s)));

static_assert(fixed_format(&quot;{}+{}={}&quot;_fmt, &quot;1&quot;_s, &quot;2&quot;_s, &quot;3&quot;_s) == &quot;1+2=3&quot;sv);
static_assert(sizeof(&quot;1+2=3&quot;) == sizeof(fixed_format(&quot;{}+{}={}&quot;_fmt, &quot;1&quot;_s, &quot;2&quot;_s, &quot;3&quot;_s)));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/h1d5Wh">https://godbolt.org/z/h1d5Wh</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr const std::string_view field{&quot;{}&quot;};

constexpr void fixed_format_arg(auto&amp; first, const auto&amp; last, auto&amp; d_first, const auto arg) {
  constexpr const auto size = decltype(arg)::size;
  const auto next = std::search(first, last, field.cbegin(), field.cend());
  const auto dist = std::distance(first, next);

  std::copy(first, next, d_first);
  std::copy_n(arg.data, size, d_first + dist);
  std::advance(first, dist + field.size());
  std::advance(d_first, dist + size);
}

constexpr auto fixed_format(const auto fmt, const auto... args) {
  fixed_string&lt;(decltype(fmt)::size + ... + (decltype(args)::size - field.size()))&gt; out;
  auto first = fmt.data;
  const auto last = first + sizeof fmt.data;
  auto d_first = out.data;

  (fixed_format_arg(first, last, d_first, args), ...);
  std::copy(first, last, d_first);

  return out;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xer4fc">https://godbolt.org/z/xer4fc</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto fixed_format(auto format, auto... args) {
    constexpr auto spec = &quot;{}&quot;sv;
    constexpr auto spec_size = std::size(spec);
    constexpr auto formatted_size = std::size(format) - sizeof...(args)*spec_size + (std::size(args) + ... + 0);

    fixed_string&lt;formatted_size&gt; ret{};
    auto write_ptr = std::data(ret);
    std::string_view s = format;

    ([&amp;] (const auto&amp; arg) {
      const auto arg_pos = s.find(spec);
      write_ptr = std::copy_n(std::data(s), arg_pos, write_ptr);
      write_ptr = std::copy_n(std::data(arg), std::size(arg), write_ptr);
      s.remove_prefix(arg_pos + spec_size);
    }(args), ...);
    std::copy_n(std::data(s), std::size(s), write_ptr);

    return ret;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/jsY7xv">https://godbolt.org/z/jsY7xv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto fixed_format(auto format, auto... args) {
    constexpr auto len = format.size - 2*sizeof...(args) + (args.size + ... + 0);
    std::array&lt;char, len+1&gt; fstr{};
    std::array&lt;std::string_view, sizeof...(args)&gt; argView{ std::string_view(args)...};

    char* in_it = format.data;
    char* out_it = fstr.data();
    uint argIdx = 0;
    while(in_it &lt; format.data+format.size)
        if (*in_it != '{')
            *out_it++ = *in_it++;
        else {
            std::copy_n(argView[argIdx].data(), argView[argIdx].size(), out_it);
            out_it += argView[argIdx].size();
            in_it += 2;
            argIdx++;
        }
    return fixed_string&lt;len&gt;(fstr.data());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/r93rh5">https://godbolt.org/z/r93rh5</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto fixed_format(auto format, auto... args) {
    constexpr auto to_replace = &quot;{}&quot;sv;
    constexpr auto replace_len = std::size(to_replace) * sizeof...(args);
    constexpr auto args_sum_len = (std::size(args) + ... + 0);
    constexpr auto output_len = std::size(format) - replace_len + args_sum_len;

    auto ret = fixed_string&lt;output_len&gt;{};
    auto loc = std::begin(ret);

    auto s = std::string_view(format);

    ([] (auto&amp; s, auto&amp; loc, const auto&amp; to_replace, const auto&amp; arg) {
      const auto pos = s.find(to_replace);
      loc = std::copy(std::begin(s), std::begin(s) + pos, loc);
      loc = std::copy(std::begin(arg), std::begin(arg) + std::size(arg), loc);
      s.remove_prefix(pos + std::size(to_replace));
    }(s, loc, to_replace, args), ...);

    std::copy(std::begin(s), std::begin(s) + std::size(s), loc);

    return ret;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Yjr4x6">https://godbolt.org/z/Yjr4x6</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto replace_unnamed_arg(const auto format, const auto replacement) {
  constexpr std::string_view unnamed_arg_str = &quot;{}&quot;;
  constexpr auto new_size =
      format.size - std::size(unnamed_arg_str) + replacement.size;

  auto replace_start = std::distance(
      std::begin(format.data),
      std::find(std::begin(format.data), std::end(format.data), '{'));
  auto replace_end = replace_start + std::size(unnamed_arg_str);

  fixed_str&lt;new_size&gt; output{};
  auto write_loc = std::copy_n(format.data, replace_start, output.data);
  write_loc = std::copy_n(replacement.data, replacement.size, write_loc);
  std::copy_n(format.data + replace_end, format.size - replace_end, write_loc);
  return output;
}

constexpr auto apply_formatting(const auto format) { return format; }
constexpr auto apply_formatting(const auto format, const auto arg, auto... args) {
  return apply_formatting(replace_unnamed_arg(format, arg), args...);
}

constexpr auto fixed_format(auto format, auto... args) {
  return apply_formatting(format, args...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/bTcY6r">https://godbolt.org/z/bTcY6r</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>185 - Did you know about the proposal to make `printf` compile-time safe and with named arguments?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/185.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/185.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know about the proposal to make <code>printf</code> compile-time safe and with named arguments?</strong></p>
</li>
<li>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html</a></p>
</li>
<li><a href="https://fmt.dev/latest/api.html">https://fmt.dev/latest/api.html</a></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  fmt::print(FMT_STRING(&quot;{}&quot;), 42);
  fmt::print(FMT_STRING(&quot;{}, {}&quot;), 42); // Compilation Error
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/xdsbvr">https://godbolt.org/z/xdsbvr</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a subroutine <code>has_valid_args</code> which verifies that named arguments match the format?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">constexpr auto has_valid_args(auto fmt, auto... args) {
  return /*TODO*/ false;
}

static_assert(not has_valid_args(&quot;&quot;_fmt, &quot;arg1&quot;_arg = 42));
static_assert(not has_valid_args(&quot;&quot;_fmt, &quot;arg1&quot;_arg = 42, &quot;arg2&quot;_arg = &quot;Quantlab&quot;));
static_assert(not has_valid_args(&quot;{}&quot;_fmt, &quot;arg1&quot;_arg = 42));
static_assert(not has_valid_args(&quot;{arg2}&quot;_fmt, &quot;arg1&quot;_arg = 42));

static_assert(not has_valid_args(&quot;{arg1}&quot;_fmt, &quot;arg1&quot;_arg = 42, &quot;arg2&quot;_arg = &quot;Quantlab&quot;));
static_assert(not has_valid_args(&quot;{arg1}&quot;_fmt, &quot;arg1&quot;_arg = 42, &quot;ARG2&quot;_arg = &quot;Quantlab&quot;));

static_assert(has_valid_args(&quot;{arg1}, {arg2}&quot;_fmt, &quot;arg1&quot;_arg = 42, &quot;arg2&quot;_arg = &quot;Quantlab&quot;));
static_assert(has_valid_args(&quot;{arg2}, {arg1}&quot;_fmt, &quot;arg1&quot;_arg = 42, &quot;arg2&quot;_arg = &quot;Quantlab&quot;));
static_assert(has_valid_args(&quot;{arg1}, {arg2}&quot;_fmt, &quot;arg2&quot;_arg = &quot;Quantlab&quot;, &quot;arg1&quot;_arg = 42));
static_assert(has_valid_args(&quot;{arg2}, {arg1}&quot;_fmt, &quot;arg2&quot;_arg = &quot;Quantlab&quot;, &quot;arg1&quot;_arg = 42));
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/dr5zK5">https://godbolt.org/z/dr5zK5</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr std::string_view operator &quot;&quot; _fmt(char const * str, std::size_t n)
{
    return std::string_view{str, n};
}

struct arg_type
{
    template &lt;typename T&gt;
    constexpr arg_type operator=(T const &amp; val)
    {
        return *this;
    }

    std::string_view name;
};

constexpr arg_type operator &quot;&quot; _arg(char const * str, std::size_t n)
{
    return arg_type{ { str, n } };
}

constexpr auto has_valid_args(auto fmt, auto... args)
{
    auto begin = std::begin(fmt);
    auto end = std::end(fmt);

    int named_args_count = 0;
    bool result = true;

    auto p = begin;
    while(p != end) {
        auto c = *p++;
        if(c == '{') {
            auto c = *p;
            if(c != '}') {
                auto it = p;
                do {
                    ++it;
                    c = *it;
                }
                while(it != end &amp;&amp; (( 'a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || ('0' &lt;= c &amp;&amp; c &lt;= '9')));

                // p -&gt; it = fmt_arg_name
                ++named_args_count;
                auto fmt_arg_name = std::string_view{ p, it };
                result = result &amp;&amp; ((fmt_arg_name == args.name) || ... );

                p = it;
            }

            ++p;
        }
    }

    return sizeof...(args) == named_args_count &amp;&amp; result;
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MsY914">https://godbolt.org/z/MsY914</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto contains_arg(const auto&amp; fmt, const auto&amp; arg_name) {
    auto it = std::cbegin(fmt);
    while (it != std::cend(fmt)) {
      it = std::search(it, std::cend(fmt),
                       std::cbegin(arg_name), std::cend(arg_name));
      if (it == std::cend(fmt)) {
        break;
      }
      const auto close_brace_it = std::next(it, std::size(arg_name));
      if (it != std::cbegin(fmt) and close_brace_it != std::cend(fmt)
          and *std::prev(it) == '{' and *close_brace_it == '}') {
        return true;
      }
      it = close_brace_it;
    }
    return false;
}

constexpr auto operator&quot;&quot;_fmt(const char* ptr, std::size_t sz) {
  return std::string_view{ptr, ptr + sz};
}

struct arg {
  constexpr auto&amp; operator=(const auto&amp;) { return *this; }
  std::string_view name;
};

constexpr auto operator&quot;&quot;_arg(const char* ptr, std::size_t sz) {
  return arg{.name = {ptr, sz}};
}

constexpr auto has_valid_args(auto fmt, auto... args) {
  return (contains_arg(fmt, args.name) and ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/Kn7zcx">https://godbolt.org/z/Kn7zcx</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct udl_arg {
  const std::string_view name;

  constexpr auto operator=(const auto&amp;) {
    return name;
  }
};

constexpr std::string_view operator&quot;&quot;_fmt(const char* str, std::size_t len) {
  return {str, len};
}

constexpr udl_arg operator&quot;&quot;_arg(const char* str, std::size_t len) {
  const std::string_view sv{str, len};
  return {sv};
}

constexpr auto has_valid_args(const auto&amp; fmt, const auto&amp;&amp;... args) {
  const std::array&lt;std::string_view, sizeof...(args)&gt; a{args...};
  std::array&lt;bool, sizeof...(args)&gt; b{};

  for (const auto&amp; [m, name] : ctre::range&lt;&quot;\\{([A-Z_a-z][A-Z_a-z0-9]*)\\}&quot;&gt;(fmt)) {
    const auto it = std::find(std::cbegin(a), std::cend(a), name);
    if (it == std::cend(a)) return false;
    b[std::distance(std::cbegin(a), it)] = true;
  }

  return std::reduce(std::cbegin(b), std::cend(b), true, std::logical_and&lt;&gt;());
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/WvP7Yh">https://godbolt.org/z/WvP7Yh</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr bool contains(auto fmt, auto arg) {
    for(int i=0; i&lt;fmt.arr.size(); i++) {
        if( fmt.arr[i] == arg.first.arr[0] ) {
            int j = 0;
            for(; j&lt;arg.first.arr.size(); j++)
                if( fmt.arr[i+j] != arg.first.arr[j])
                    break;
            if(j == arg.first.arr.size())
                return true;
        }
    }
    return false;
}

constexpr auto has_valid_args(auto fmt, auto... args) {
  return   (contains(fmt, args) &amp; ... &amp; true);
}

template&lt;char...s&gt; struct arg {
    template&lt;typename T&gt;
    std::pair&lt;arg&lt;s...&gt;, T&gt; constexpr operator=(T value) {
        return {{}, value};
    }
    std::array&lt;char, sizeof...(s)&gt; arr{s...};
};

template&lt;typename charT, charT...s&gt;
arg&lt;s...&gt; constexpr operator&quot;&quot; _arg() { return {}; }

template&lt;char...s&gt; struct fmt {
    std::array&lt;char, sizeof...(s)&gt; arr{s...};
};

template&lt;typename charT, charT...s&gt;
fmt&lt;s...&gt; constexpr operator&quot;&quot; _fmt() { return{}; }
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/cEc6Ee">https://godbolt.org/z/cEc6Ee</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">constexpr auto operator&quot;&quot;_fmt(const char* first_char, const std::size_t length) {
    return std::string_view{first_char, first_char + length};
}

struct arg : std::string_view {
    constexpr auto operator=(const auto&amp;) { return *this; }
};

constexpr auto operator&quot;&quot;_arg (const char* first_char, const std::size_t length) {
    return arg(std::string_view{first_char, first_char + length});
}

consteval auto all_args_in_string(const auto &amp;fmt) {
    return true;
}

consteval auto all_args_in_string(const auto &amp;fmt, const auto arg, const auto... args) {
    const bool arg_in_string = fmt.find(arg) != std::string_view::npos;
    return arg_in_string and all_args_in_string(fmt, args...);
}

consteval auto has_valid_args(const auto fmt, const auto... args) {
    return all_args_in_string(fmt, args...);
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/MWEW6Y">https://godbolt.org/z/MWEW6Y</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">struct arg {
  constexpr auto&amp; operator=(const auto&amp;) { return *this; }
  constexpr operator auto() const { return name; }
  std::string_view name;
};

constexpr auto operator&quot;&quot;_arg(const char* name, std::size_t size) {
  return arg{.name = {name, size}};
}

constexpr auto operator&quot;&quot;_fmt(const char* name, std::size_t size) {
  return std::string_view{name, size};
}

constexpr auto has_valid_args(auto fmt, auto... args) {
  return ((fmt.find(args) != std::string_view::npos) and ...);
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/85boK9">https://godbolt.org/z/85boK9</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>184 - **Did you know that you can customize formatter for your classes with `std::format`**?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/184.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/184.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that you can customize formatter for your classes with <code>std::format</code></strong>?</p>
</li>
<li>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html</a></p>
</li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">struct foo {
  int value{};
};

template&lt;&gt;
struct fmt::formatter&lt;foo&gt; : fmt::formatter&lt;int&gt; {
  template&lt;class FormatContext&gt;
  auto format(foo f, FormatContext&amp; ctx) {
    return fmt::formatter&lt;int&gt;::format(f.value, ctx);
  }
};

int main() {
  std::cout &lt;&lt; fmt::format(&quot;{}&quot;, foo{.value = 42}); // prints 42
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/K3hv69">https://godbolt.org/z/K3hv69</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you implement a custom formatter for <code>foo</code></strong>?</li>
</ul>
<pre class="codehilite"><code class="language-cpp">template&lt;class...&gt;
struct foo;

int main() {
  using namespace boost::ut;
  using namespace std::literals;

  &quot;custom formatter&quot;_test = [] {
    should(&quot;format empty with no spaces&quot;) = [] {
      expect(&quot;foo()&quot;sv == fmt::format(&quot;{}&quot;, foo{}));
    };

    should(&quot;format fields seperated by space&quot;) = [] {
      expect(&quot;foo( 1 )&quot;sv == fmt::format(&quot;{}&quot;, foo{1}));
      expect(&quot;foo( 1 2 )&quot;sv == fmt::format(&quot;{}&quot;, foo{1, 2}));
      expect(&quot;foo( 1 2 3 )&quot;sv == fmt::format(&quot;{}&quot;, foo{1, 2, 3}));
    };

    should(&quot;format fields seperated by space with different types&quot;) = [] {
      expect(&quot;foo( Quant Lab )&quot;sv == fmt::format(&quot;{}&quot;, foo{&quot;Quant&quot;, &quot;Lab&quot;}));
      expect(&quot;foo( Q 42 B )&quot;sv == fmt::format(&quot;{}&quot;, foo{'Q', 42, &quot;B&quot;}));
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/nob8c9">https://godbolt.org/z/nob8c9</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">template &lt;class... Ts&gt;
struct foo {
  std::tuple&lt;Ts...&gt; values;
  foo(const Ts... args) : values(std::make_tuple(args...)){};
};

template &lt;class... Ts&gt;
struct fmt::formatter&lt;foo&lt;Ts...&gt;&gt; {
  constexpr auto parse(format_parse_context&amp; ctx) {
    return ctx.end();
  }
  template &lt;class FormatContext&gt;
  auto format(foo&lt;Ts...&gt; f, FormatContext&amp; ctx) {
    return fmt::format_to(
        ctx.out(),
        std::tuple_size&lt;decltype(f.values)&gt;::value ? &quot;foo( {} )&quot; : &quot;foo({})&quot;,
        fmt::join(f.values, &quot; &quot;));
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G596ov">https://godbolt.org/z/G596ov</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;typename... Ts&gt;
struct foo {
    foo(Ts...t) : data{t...} {}

    std::tuple&lt;Ts...&gt; data{};
};

template&lt;typename ...Ts&gt;
struct fmt::formatter&lt;foo&lt;Ts...&gt;&gt; {
    constexpr auto parse(auto&amp; ctx) {
        return ctx.end();
    }

    auto format(foo&lt;Ts...&gt; f, auto&amp; ctx) {
        if constexpr (0 == sizeof...(Ts)) {
            return fmt::format_to(ctx.out(), &quot;foo()&quot;);
        } else {
            return fmt::format_to(ctx.out(), &quot;foo( {} )&quot;, fmt::join(f.data, &quot; &quot;));
        }
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6WGo4P">https://godbolt.org/z/6WGo4P</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TArgs&gt;
struct foo {
  constexpr foo(TArgs... args) : val{args...} {}
  std::tuple&lt;TArgs...&gt; val;
};

template &lt;class... TArgs&gt;
struct fmt::formatter&lt;foo&lt;TArgs...&gt;&gt; {
  constexpr auto parse(format_parse_context&amp; ctx) const { return ctx.end(); }

  constexpr auto format(foo&lt;TArgs...&gt; f, auto&amp; ctx) const {
    if constexpr (sizeof...(TArgs)) {
      return fmt::format_to(ctx.out(), &quot;foo( {} )&quot;, fmt::join(f.val, &quot; &quot;));
    }
    return fmt::format_to(ctx.out(), &quot;foo()&quot;);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/YfKsf3">https://godbolt.org/z/YfKsf3</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TArgs&gt;
struct foo : std::tuple&lt;TArgs...&gt; {
  constexpr foo(TArgs... args) : std::tuple&lt;TArgs...&gt;{args...} {}
};

template &lt;typename... Ts&gt;
struct fmt::formatter&lt;foo&lt;Ts...&gt;&gt; : fmt::formatter&lt;std::string_view&gt; {
  template &lt;class FormatContext&gt;
  auto format(foo&lt;Ts...&gt; f, FormatContext&amp; ctx) {
    if (sizeof...(Ts) == 0) {
      return fmt::format_to(ctx.out(), &quot;foo()&quot;);
    }
    return fmt::format_to(ctx.out(), &quot;foo( {} )&quot;, fmt::join(f, &quot; &quot;));
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/sn131T">https://godbolt.org/z/sn131T</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;class... TArgs&gt;
struct foo : std::tuple&lt;TArgs...&gt; {
  using std::tuple&lt;TArgs...&gt;::tuple;
};

template &lt;class... TArgs&gt;
foo(TArgs...) -&gt; foo&lt;TArgs...&gt;;

template &lt;class... TArgs&gt;
struct fmt::formatter&lt;foo&lt;TArgs...&gt;&gt; {
  template &lt;class TParseContext&gt;
  constexpr auto parse(TParseContext &amp;ctx) {
    return std::begin(ctx);
  }

  template &lt;class FormatContext&gt;
  auto format(foo&lt;TArgs...&gt; f, FormatContext&amp; ctx) {
    if constexpr (sizeof...(TArgs) == 0) {
      return fmt::format_to(ctx.out(), &quot;foo()&quot;);
    }

    fmt::format_to(ctx.out(), &quot;foo( &quot;);
    [&amp;]&lt;auto... Is&gt;(std::index_sequence&lt;Is...&gt;) {
      (fmt::format_to(ctx.out(), &quot;{} &quot;, std::get&lt;Is&gt;(f)), ...);
    }(std::index_sequence_for&lt;TArgs...&gt;{});
    return fmt::format_to(ctx.out(), &quot;)&quot;);
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/6rKar4">https://godbolt.org/z/6rKar4</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Args&gt;
struct foo : std::tuple&lt;Args...&gt; {
    using std::tuple&lt;Args...&gt;::tuple;
};

template&lt;class...Args&gt; foo(Args...) -&gt; foo&lt;Args...&gt;;

template&lt;class...T&gt;
struct fmt::formatter&lt;foo&lt;T...&gt;&gt; : fmt::formatter&lt;int&gt; {
    template&lt;class FormatContext&gt;
    auto format(foo&lt;T...&gt; f, FormatContext&amp; ctx) {
        std::string fmtString = sizeof...(T) &gt; 0 ? &quot;foo( &quot; : &quot;foo(&quot;;
        for (int i=0; i&lt;sizeof...(T); i++)
            fmtString += &quot;{} &quot;;
        fmtString += &quot;)&quot;;
        auto formatOut = [&amp;](auto...args) { return fmt::format_to(ctx.out(), fmtString, args...); };
        return std::apply(formatOut, static_cast&lt;std::tuple&lt;T...&gt;&gt;(f));
    }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/a6Eb9h">https://godbolt.org/z/a6Eb9h</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts&gt;
struct foo : std::tuple&lt;Ts...&gt; {
  constexpr explicit(true) foo(Ts... ts) : std::tuple&lt;Ts...&gt;(ts...) {}
};

template&lt;class... Ts&gt;
struct fmt::formatter&lt;foo&lt;Ts...&gt;&gt; {
  constexpr auto parse(format_parse_context&amp; ctx) { return ctx.begin(); }

  template&lt;class TCtx&gt;
  auto format(foo&lt;Ts...&gt; f, TCtx&amp; ctx) {
    if constexpr(sizeof...(Ts) == 0) {
      return format_to(ctx.out(), &quot;foo()&quot;);
    } else {
      return std::apply([&amp;](auto... args) {
        return format_to(
            ctx.out(),
            std::string{&quot;foo( &quot;} + ((args, std::string{&quot;{} &quot;}) + ...) + &quot;)&quot;,
            args...);
      }, static_cast&lt;const std::tuple&lt;Ts...&gt;&amp;&gt;(f));
    }
  }
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5E9KKW">https://godbolt.org/z/5E9KKW</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>183 - Did you know that `Formatted output` has been accepted into C++20?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/183.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/183.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li>
<p><strong>Did you know that <code>Formatted output</code> has been accepted into C++20?</strong></p>
</li>
<li>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2093r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2093r0.html</a></p>
</li>
<li>
<p><a href="https://fmt.dev/7.0.1/syntax.html">https://fmt.dev/7.0.1/syntax.html</a></p>
<ul>
<li>Grammar</li>
</ul>
</li>
</ul>
<pre class="codehilite"><code>replacement_field ::=  &quot;{&quot; [arg_id] [&quot;:&quot; format_spec] &quot;}&quot;
arg_id            ::=  integer | identifier
integer           ::=  digit+
digit             ::=  &quot;0&quot;...&quot;9&quot;
identifier        ::=  id_start id_continue*
id_start          ::=  &quot;a&quot;...&quot;z&quot; | &quot;A&quot;...&quot;Z&quot; | &quot;_&quot;
id_continue       ::=  id_start | digit
</code></pre>

</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">int main() {
  std::cout &lt;&lt; fmt::format(&quot;1 + 1 = {}&quot;, 1+1); // prints 1 + 1 = 2
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/GsbsWj">https://godbolt.org/z/GsbsWj</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>Can you fill <code>TODO</code> with appropriate formattings?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">int main() {
  using namespace boost::ut;
  using namespace std::literals;

  &quot;format single&quot;_test = [] {
    expect(&quot;42&quot;sv         == fmt::format(&quot;TODO&quot;, 42));
    expect(&quot;42..&quot;sv       == fmt::format(&quot;TODO&quot;, 42));
    expect(&quot;..42&quot;sv       == fmt::format(&quot;TODO&quot;, 42));
    expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;TODO&quot;, 42)); // use 0 parameter
    expect(&quot;  QL  &quot;sv     == fmt::format(&quot;TODO&quot;, &quot;QL&quot;));
    expect(&quot;  QL  &quot;sv     == fmt::format(&quot;TODO&quot;, &quot;QL&quot;));
    expect(&quot;QL        &quot;sv == fmt::format(&quot;TODO&quot;, &quot;QL&quot;, 10));
  };

  &quot;format multiple&quot;_test = [] {
    expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;TODO&quot;, 1, 2, 1+2));
    expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;TODO&quot;, 1.234, 2, 0, 42));
  };

  &quot;format named&quot;_test = [] {
    using namespace fmt::literals;
    expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;TODO&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/aWsMa3">https://godbolt.org/z/aWsMa3</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">&quot;format single&quot;_test = [] {
  expect(&quot;42&quot;sv         == fmt::format(&quot;{}&quot;, 42));
  expect(&quot;42..&quot;sv       == fmt::format(&quot;{:.&lt;4}&quot;, 42));
  expect(&quot;..42&quot;sv       == fmt::format(&quot;{:.&gt;4}&quot;, 42));
  expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;{0} {0:#x}&quot;, 42)); // use 0 parameter
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{:^6}&quot;, &quot;QL&quot;));
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{:&gt;4}  &quot;, &quot;QL&quot;));
  expect(&quot;QL        &quot;sv == fmt::format(&quot;{:&lt;{}}&quot;, &quot;QL&quot;, 10));
};

&quot;format multiple&quot;_test = [] {
  expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;{}+{}={}&quot;, 1, 2, 1+2));
  expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;{0:.{1}f}, {2:#06b}, {3:#x}&quot;, 1.234, 2, 0, 42));
};

&quot;format named&quot;_test = [] {
  using namespace fmt::literals;
  expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;named={arg1}:{arg2}&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/5nq88W">https://godbolt.org/z/5nq88W</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;format single&quot;_test = [] {
  expect(&quot;42&quot;sv         == fmt::format(&quot;{}&quot;, 42));
  expect(&quot;42..&quot;sv       == fmt::format(&quot;{}..&quot;, 42));
  expect(&quot;..42&quot;sv       == fmt::format(&quot;..{}&quot;, 42));
  expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;{0} {0:#4x}&quot;, 42)); // use 0 parameter
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;  {}  &quot;, &quot;QL&quot;));
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{:^6}&quot;, &quot;QL&quot;));
  expect(&quot;QL        &quot;sv == fmt::format(&quot;{:&lt;{}}&quot;, &quot;QL&quot;, 10));
};

&quot;format multiple&quot;_test = [] {
  expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;{}+{}={}&quot;, 1, 2, 1+2));
  expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;{:.{}f}, {:#06b}, {:#4x}&quot;, 1.234, 2, 0, 42));
};

&quot;format named&quot;_test = [] {
  using namespace fmt::literals;
  expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;named={arg1}:{arg2}&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/e6oqdv">https://godbolt.org/z/e6oqdv</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;format single&quot;_test = [] {
  expect(&quot;42&quot;sv         == fmt::format(&quot;{}&quot;, 42));
  expect(&quot;42..&quot;sv       == fmt::format(&quot;{}..&quot;, 42));
  expect(&quot;..42&quot;sv       == fmt::format(&quot;..{}&quot;, 42));
  expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;{0} {0:#x}&quot;, 42)); // use 0 parameter
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;  {}  &quot;, &quot;QL&quot;));
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;  {}  &quot;, &quot;QL&quot;)); // Duplicate??
  expect(&quot;QL        &quot;sv == fmt::format(&quot;{:&lt;{}}&quot;, &quot;QL&quot;, 10));
};

&quot;format multiple&quot;_test = [] {
  expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;{}+{}={}&quot;, 1, 2, 1+2));
  expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;{:0.{}f}, {:#06b}, {:#x}&quot;, 1.234, 2, 0, 42));
};

&quot;format named&quot;_test = [] {
  using namespace fmt::literals;
  expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;named={arg1}:{arg2}&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/G83ofz">https://godbolt.org/z/G83ofz</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;format single&quot;_test = [] {
  expect(&quot;42&quot;sv         == fmt::format(&quot;{}&quot;, 42));
  expect(&quot;42..&quot;sv       == fmt::format(&quot;{0:.&lt;4}&quot;, 42));
  expect(&quot;..42&quot;sv       == fmt::format(&quot;{0:.&gt;4}&quot;, 42));
  expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;{0:&lt;3}{0:#x}&quot;, 42)); // use 0 parameter
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{0:^6}&quot;, &quot;QL&quot;));
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{0:^6}&quot;, &quot;QL&quot;));
  expect(&quot;QL        &quot;sv == fmt::format(&quot;{0:{1}}&quot;, &quot;QL&quot;, 10));
};

&quot;format multiple&quot;_test = [] {
  expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;{0}+{1}={2}&quot;, 1, 2, 1+2));
  expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;{0:.{1}f}, {2:#06b}, {3:#x}&quot;, 1.234, 2, 0, 42));
};

&quot;format named&quot;_test = [] {
  using namespace fmt::literals;
  expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;named={arg1}:{arg2}&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/boErsd">https://godbolt.org/z/boErsd</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">&quot;format single&quot;_test = [] {
  expect(&quot;42&quot;sv         == fmt::format(&quot;{:d}&quot;, 42));
  expect(&quot;42..&quot;sv       == fmt::format(&quot;{:.&lt;4d}&quot;, 42));
  expect(&quot;..42&quot;sv       == fmt::format(&quot;{:.&gt;4d}&quot;, 42));
  expect(&quot;42 0x2a&quot;sv    == fmt::format(&quot;{0:d} {0:#x}&quot;, 42)); // use 0 parameter
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{:^6}&quot;, &quot;QL&quot;));
  expect(&quot;  QL  &quot;sv     == fmt::format(&quot;{:^6}&quot;, &quot;QL&quot;));
  expect(&quot;QL        &quot;sv == fmt::format(&quot;{:&lt;10}&quot;, &quot;QL&quot;, 10));
};

&quot;format multiple&quot;_test = [] {
  expect(&quot;1+2=3&quot;sv              == fmt::format(&quot;{0:d}+{1:d}={2:d}&quot;, 1, 2, 1+2));
  expect(&quot;1.23, 0b0000, 0x2a&quot;sv == fmt::format(&quot;{0:4.2f}, {2:#06b}, {3:#x}&quot;, 1.234, 2, 0, 42));
};

&quot;format named&quot;_test = [] {
  using namespace fmt::literals;
  expect(&quot;named=quant:lab&quot;sv == fmt::format(&quot;named={arg1}:{arg2}&quot;, &quot;arg1&quot;_a = &quot;quant&quot;, &quot;arg2&quot;_a = &quot;lab&quot;));
};
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/oxhKEf">https://godbolt.org/z/oxhKEf</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>
<item>
            <title>182 - Did you know about the proposal to add Non-terminal variadic template parameters?</title>
            <link>https://github.com/tip-of-the-week/cpp/blob/master/tips/182.md</link>
            <guid>https://github.com/tip-of-the-week/cpp/blob/master/tips/182.md</guid>
            <pubDate>Mon, 11 Mar 2024 15:19:21 GMT</pubDate>
            <description><![CDATA[ <div>
<p><details open=true><summary>Info</summary>
<ul>
<li><strong>Did you know about the proposal to add Non-terminal variadic template parameters?</strong></li>
</ul>
</details><details open=true><summary>Example</summary>
<pre class="codehilite"><code class="language-cpp">template&lt;class... Ts, class T&gt;
auto foo(Ts..., T t) { return t; }
int main() {
  std::cout &lt;&lt; foo(1); // prints 1
  std::cout &lt;&lt; foo(1, 2, 3, 4); // prints 4
  std::cout &lt;&lt; foo(); // compilation error
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/z9jvd4vhx">https://godbolt.org/z/z9jvd4vhx</a></p>
</blockquote>
</details><details open=true><summary>Puzzle</summary>
<ul>
<li><strong>[NTVTP] Can you implement <code>last_using_{get,apply,inplace_lambda}</code> functions which will return the last element of given tuple?</strong></li>
</ul>
<pre class="codehilite"><code class="language-cpp">/* TODO */
constexpr auto last_using_get(...);
constexpr auto last_using_apply(...);
constexpr auto last_using_inplace_lambda(...);

int main() {
  &quot;tuple - get last&quot;_test = [] {
    should(&quot;return the only element&quot;) = []{
      auto tuple = std::tuple{42};
      42_i == last_using_get(tuple) and
      42_i == last_using_apply(tuple) and
      42_i == last_using_inplace_lambda(tuple);
    };
    should(&quot;return the last element with same types&quot;) = [] {
      auto tuple = std::tuple{4l, 2l, 42l};
      42_l == last_using_get(tuple) and
      42_l == last_using_apply(tuple) and
      42_l == last_using_inplace_lambda(tuple);
    };
    should(&quot;return the last element with differen types&quot;) = [] {
      auto tuple = std::tuple{1, 2.0, &quot;3&quot;, 4ul};
      4_ul == last_using_get(tuple) and
      4_ul == last_using_apply(tuple) and
      4_ul == last_using_inplace_lambda(tuple);
    };
  };
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/111hzT">https://godbolt.org/z/111hzT</a></p>
</blockquote>
</details><details><summary>Solutions</summary>
<pre class="codehilite"><code class="language-cpp">constexpr auto last_using_get(const auto&amp; tuple) noexcept
{
    using tuple_type = std::decay_t&lt;decltype(tuple)&gt;;
    return std::get&lt;std::tuple_size_v&lt;tuple_type&gt; - 1&gt;(tuple);
}
constexpr auto last_using_apply(const auto&amp; tuple)
{
    return std::apply([](const auto... args) { return (args, ...); }, tuple);
}
constexpr auto last_using_inplace_lambda(const auto&amp; tuple) {
    return [&amp;](){
        return last_using_get(tuple);
    }();
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/1P3Mcj">https://godbolt.org/z/1P3Mcj</a></p>
</blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename TTuple&gt;
constexpr auto last_using_get(TTuple&amp;&amp; t) -&gt; decltype(auto) {
    constexpr auto size = std::tuple_size_v&lt;std::remove_reference_t&lt;TTuple&gt;&gt;;
    return std::get&lt;size-1&gt;(std::forward&lt;TTuple&gt;(t));
}

template &lt;typename TTuple&gt;
constexpr auto last_using_apply(TTuple&amp;&amp; t) -&gt; decltype(auto) {
    return std::apply(
        [](auto&amp;&amp;...args) -&gt; decltype(auto) {
            return (std::forward&lt;decltype(args)&gt;(args), ...);
        },
        std::forward&lt;TTuple&gt;(t));
}

template &lt;typename TTuple&gt;
constexpr auto last_using_inplace_lambda(TTuple&amp;&amp; t) -&gt; decltype(auto) {
    constexpr auto size = std::tuple_size_v&lt;std::remove_reference_t&lt;TTuple&gt;&gt;;
    return [&amp;] &lt;auto... I&gt; (std::index_sequence&lt;I...&gt;) -&gt; decltype(auto) {
        return std::get&lt;(I,...)&gt;(std::forward&lt;TTuple&gt;(t));
    }(std::make_index_sequence&lt;size&gt;{});
}
</code></pre>

<blockquote>
<p><a href="https://godbolt.org/z/c5PzYK">https://godbolt.org/z/c5PzYK</a></p>
</blockquote>
</details></p>
</div>]]></description>
        </item>

    </channel>
</rss>
